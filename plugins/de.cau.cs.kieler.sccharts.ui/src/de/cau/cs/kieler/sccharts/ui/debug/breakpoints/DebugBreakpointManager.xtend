/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://rtsys.informatik.uni-kiel.de/kieler
 * 
 * Copyright ${year} by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 */
package de.cau.cs.kieler.sccharts.ui.debug.breakpoints

import de.cau.cs.kieler.sccharts.State
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.ui.debug.highlighting.DebugHighlighter
import org.eclipse.jdt.debug.core.IJavaBreakpoint
import java.util.HashSet
import java.util.List
import org.eclipse.ui.texteditor.ITextEditor
import org.eclipse.core.runtime.IProgressMonitor
import org.eclipse.ui.progress.UIJob
import org.eclipse.ui.PlatformUI
import org.eclipse.core.runtime.Status
import org.eclipse.swt.widgets.Display
import java.util.regex.Pattern
import de.cau.cs.kieler.sccharts.processors.statebased.DebugAnnotations

/**
 * Central class to synchronize and manage all breakpoints generated by the debugger.
 * 
 * @author stu121235
 *
 */
class DebugBreakpointManager {
   
    private static var DebugBreakpointManager instance
    
    private val DebugHighlighter debugHighlighter
    
    val statesWithBreakpoint = <State> newHashSet 
    val transitionsWithBreakpoint = <Transition> newHashSet
    
    val stateToBreakpoint = <State, List<IJavaBreakpoint>> newHashMap
    val transitionToBreakpoint = <Transition, List<IJavaBreakpoint>> newHashMap
    
    /**
     * Private for singleton behavior.
     */
    private new() {
        debugHighlighter = DebugHighlighter.instance
        
    }
    
    static def getInstance() {
        if (instance === null) {
            instance = new DebugBreakpointManager()
        }
        return instance
    }
    
    def toggleBreakpoint(State state) {
        if (statesWithBreakpoint.contains(state)) {
            statesWithBreakpoint.remove(state)
            debugHighlighter.removeBreakpointHighlight(state)
            state.clearBreakpoints
            stateToBreakpoint.remove(state)
        } else {
            statesWithBreakpoint.add(state)
            debugHighlighter.addBreakpointHighlight(state)
            val breakpoints = <IJavaBreakpoint> newLinkedList
            for (line : state.findStateLines) {
                val bp = createBreakpointOnLine(line)
                breakpoints.add(bp)
            }
            stateToBreakpoint.put(state, breakpoints)
        }
    }
    
    def toggleBreakpoint(Transition transition) {
        if (transitionsWithBreakpoint.contains(transition)) {
            transitionsWithBreakpoint.remove(transition)
            debugHighlighter.removeBreakpointDecorator(transition)
            transition.clearBreakpoints
            transitionToBreakpoint.remove(transition)
        } else {
            transitionsWithBreakpoint.add(transition)
            debugHighlighter.addBreakpointDecorator(transition)
            val breakpoints = <IJavaBreakpoint> newLinkedList
            for (line : transition.findTransitionLines) {
                val bp = createBreakpointOnLine(line)
                breakpoints.add(bp)
            }
            transitionToBreakpoint.put(transition, breakpoints)
        }
    }
    
    private def IJavaBreakpoint createBreakpointOnLine(int line) {
        // TODO
        return null
    }
    
    private def findTransitionLines(Transition transition) {
        
        val editor = getActiveEditor
        
        val transitionLines = <Integer> newLinkedList
        
        val document = editor.documentProvider.getDocument(editor.editorInput)
        
        val nameHash = DebugAnnotations.getFullNameHash(transition)
        
        // Use Regex to find transition marker comment format
        val matcher = Pattern.compile("// Transition [a-zA-Z]+ \\(Priority \\d+\\) -> [a-zA-Z]+ \\(" + nameHash + "\\)")
            .matcher(document.get)
        
        // Record all lines with matching comment in them
        while(matcher.find) {
            transitionLines.add(document.getLineOfOffset(matcher.start))
        }
        
        
//        val lines = document.numberOfLines
//        for (var line = 0; line < lines; line++) {
//            val lineOffset = document.getLineOffset(line)
//            val lineLength = document.getLineLength(line)
//            val lineText = document.get(lineOffset, lineLength)
//            if (lineText.matches("// Transition [a-zA-Z]+ \\(Priority \\d+\\) -> [a-zA-Z]+ \\([\\-]?\\d+\\)")) {
//                // TODO check whether this is actually for the right transition
//                // Maybe store this in a map?
//                transitionLines.add(line)
//                println("Match on line " + line)
//            }
//        }
        
        // TODO debug
        for (line : transitionLines) {
            println(line)
        }
        
        return transitionLines
    }
    
    private def findStateLines(State state) {
        // TODO
        return <Integer> newLinkedList
    }
    
    private def clearBreakpoints(Transition transition) {
        // TODO
    }
    
    private def clearBreakpoints(State state) {
        // TODO
    }
    
    private def getActiveEditor() {
         // Use UIJob to get active editor -----------------------------------------
            val ITextEditor[] editorArr = newArrayOfSize(1)
            
            Display.^default.syncExec(new Runnable() {
                override run() {
                    editorArr.set(0,PlatformUI.workbench?.activeWorkbenchWindow?.activePage?.activeEditor as ITextEditor)
                }
            })
            
            return editorArr.head
    }
    
}