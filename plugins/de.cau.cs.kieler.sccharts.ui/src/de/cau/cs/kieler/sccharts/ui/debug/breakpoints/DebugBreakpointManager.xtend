/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://rtsys.informatik.uni-kiel.de/kieler
 * 
 * Copyright ${year} by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 */
package de.cau.cs.kieler.sccharts.ui.debug.breakpoints

import de.cau.cs.kieler.sccharts.State
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.processors.statebased.DebugAnnotations
import de.cau.cs.kieler.sccharts.ui.debug.highlighting.DebugHighlighter
import java.util.List
import java.util.regex.Pattern
import org.eclipse.jdt.debug.core.IJavaBreakpoint
import org.eclipse.swt.widgets.Display
import org.eclipse.ui.IFileEditorInput
import org.eclipse.ui.PlatformUI
import org.eclipse.ui.texteditor.ITextEditor
import org.eclipse.core.resources.IResource
import org.eclipse.jdt.ui.JavaUI
import org.eclipse.jdt.core.ICompilationUnit
import org.eclipse.debug.core.model.IBreakpoint
import org.eclipse.core.resources.IMarker
import org.eclipse.jdt.debug.core.JDIDebugModel
import org.eclipse.debug.core.model.ILineBreakpoint
import org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint

/**
 * Central class to synchronize and manage all breakpoints generated by the debugger.
 * 
 * @author stu121235
 *
 */
class DebugBreakpointManager {
   
    private static var DebugBreakpointManager instance
    
    private val DebugHighlighter debugHighlighter
    
    val statesWithBreakpoint = <State> newHashSet 
    val transitionsWithBreakpoint = <Transition> newHashSet
    
    val stateToBreakpoint = <State, List<IJavaBreakpoint>> newHashMap
    val transitionToBreakpoint = <Transition, List<IJavaBreakpoint>> newHashMap
    
    /**
     * Private for singleton behavior.
     */
    private new() {
        debugHighlighter = DebugHighlighter.instance
        
    }
    
    static def getInstance() {
        if (instance === null) {
            instance = new DebugBreakpointManager()
        }
        return instance
    }
    
    def toggleBreakpoint(State state) {
        if (statesWithBreakpoint.contains(state)) {
            statesWithBreakpoint.remove(state)
            debugHighlighter.removeBreakpointHighlight(state)
            state.clearBreakpoints
            stateToBreakpoint.remove(state)
        } else {
            statesWithBreakpoint.add(state)
            debugHighlighter.addBreakpointHighlight(state)
            val breakpoints = <IJavaBreakpoint> newLinkedList
            for (line : state.findStateLines) {
                val bp = createBreakpointOnLine(line, BreakpointType.TRANSITION_CHECK_BREAKPOINT)
                breakpoints.add(bp)
            }
            stateToBreakpoint.put(state, breakpoints)
        }
    }
    
    def toggleBreakpoint(Transition transition) {
        if (transitionsWithBreakpoint.contains(transition)) {
            transitionsWithBreakpoint.remove(transition)
            debugHighlighter.removeBreakpointDecorator(transition)
            transition.clearBreakpoints
            transitionToBreakpoint.remove(transition)
        } else {
            transitionsWithBreakpoint.add(transition)
            debugHighlighter.addBreakpointDecorator(transition)
            val breakpoints = <IJavaBreakpoint> newLinkedList
            for (line : transition.findTransitionLines) {
                val bp = createBreakpointOnLine(line, BreakpointType.TRANSITION_CHECK_BREAKPOINT)
                breakpoints.add(bp)
            }
            transitionToBreakpoint.put(transition, breakpoints)
        }
    }
    
    private def IJavaBreakpoint createBreakpointOnLine(int line, BreakpointType breakpointType) {
        
        val editor = activeEditor
        val resource = editor.editorInput.getAdapter(IResource)
        val typeRoot = JavaUI.getEditorInputTypeRoot(editor.editorInput)
        val compilationUnit = (typeRoot.getAdapter(ICompilationUnit) as ICompilationUnit)
        val type = compilationUnit.types.head
        
        // TODO
        /*
         * -1, -1: No associated start / end characters
         * 0: Always suspend (after 0 hits)
         * true: Register in breakpoint manager
         * empty map: No attributes (for now)
         */
        val attributes = <String, Object> newHashMap
        attributes.put(IBreakpoint.ENABLED, true)
        attributes.put(IBreakpoint.PERSISTED, true)
        attributes.put(IMarker.LINE_NUMBER, line)
        
        var IJavaBreakpoint breakpoint
         
        switch(breakpointType) {
            case TRANSITION_CHECK_BREAKPOINT:
                breakpoint = new TransitionCheckBreakpoint(resource, type.fullyQualifiedName, line + 1, -1, -1, 0, true, attributes) 
            case STATE_BREAKPOINT:
                breakpoint =  new StateBreakpoint(resource, type.fullyQualifiedName, line + 1, -1, -1, 0, true, attributes)
        } 
        
        Display.^default.asyncExec(new Runnable() {
            override run() {
                Display.^default.update
            }
        })
       
        return breakpoint
    }
    
    private def findTransitionLines(Transition transition) {
        
        val editor = getActiveEditor
        val transitionLines = <Integer> newLinkedList
        val document = editor.documentProvider.getDocument(editor.editorInput)
        val nameHash = DebugAnnotations.getFullNameHash(transition)
        
        // Use Regex to find transition marker comment format
        val matcher = Pattern.compile("// Transition [a-zA-Z]+ \\(Priority \\d+\\) -> [a-zA-Z]+ \\(" + nameHash + "\\)")
            .matcher(document.get)
        
        // Record all lines with matching comment in them
        while(matcher.find) {
            transitionLines.add(document.getLineOfOffset(matcher.start))
        }
        
        return transitionLines
    }
    
    private def findStateLines(State state) {
        val editor = getActiveEditor
        val stateLines = <Integer> newLinkedList
        
        val document = editor.documentProvider.getDocument(editor.editorInput)
        val nameHash = DebugAnnotations.getFullNameHash(state)
        
        // Use Regex to find state marker comment format
        val matcher = Pattern.compile("\\* State [a-zA-Z0-9]+ \\(" + nameHash + "\\)")
            .matcher(document.get)
            
        while(matcher.find) {
            // Comment format always has a closing comment marker in the next line.
            // After that comes the method signature and the breakpoint needs to be set on the line after that,
            // thus matching line + 3.
            stateLines.add(document.getLineOfOffset(matcher.start) + 3)
        }    
        
        return stateLines
    }
    
    private def clearBreakpoints(Transition transition) {
        for (breakpoint : transitionToBreakpoint.get(transition)) {
            breakpoint.delete
        }
    }
    
    private def clearBreakpoints(State state) {
        for (breakpoint : stateToBreakpoint.get(state)) {
            breakpoint.delete
        }
    }
    
    private def getActiveEditor() {
        // Use UIJob to get active editor -----------------------------------------
        val ITextEditor[] editorArr = newArrayOfSize(1)

        Display.^default.syncExec(new Runnable() {
            override run() {
                editorArr.set(0, PlatformUI.workbench?.activeWorkbenchWindow?.activePage?.activeEditor as ITextEditor)
            }
        })

        return editorArr.head
    }
    
}