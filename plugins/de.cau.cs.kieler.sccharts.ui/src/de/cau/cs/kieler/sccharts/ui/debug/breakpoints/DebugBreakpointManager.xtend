/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 *
 * http://rtsys.informatik.uni-kiel.de/kieler
 * 
 * Copyright ${year} by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 */
package de.cau.cs.kieler.sccharts.ui.debug.breakpoints

import de.cau.cs.kieler.sccharts.State
import de.cau.cs.kieler.sccharts.Transition
import de.cau.cs.kieler.sccharts.processors.statebased.DebugAnnotations
import de.cau.cs.kieler.sccharts.ui.debug.highlighting.DebugHighlighter
import java.util.List
import java.util.regex.Pattern
import org.eclipse.jdt.debug.core.IJavaBreakpoint
import org.eclipse.swt.widgets.Display
import org.eclipse.ui.IFileEditorInput
import org.eclipse.ui.PlatformUI
import org.eclipse.ui.texteditor.ITextEditor
import org.eclipse.core.resources.IResource
import org.eclipse.jdt.ui.JavaUI
import org.eclipse.jdt.core.ICompilationUnit
import org.eclipse.debug.core.model.IBreakpoint
import org.eclipse.core.resources.IMarker
import org.eclipse.jdt.debug.core.JDIDebugModel
import org.eclipse.debug.core.model.ILineBreakpoint
import org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint
import de.cau.cs.kieler.sccharts.SCCharts
import de.cau.cs.kieler.sccharts.extensions.SCChartsScopeExtensions
import com.google.inject.Inject
import com.google.inject.Guice

/**
 * Central class to synchronize and manage all breakpoints generated by the debugger.
 * 
 * @author stu121235
 *
 */
class DebugBreakpointManager {
   
    private static var DebugBreakpointManager instance
    
    private val DebugHighlighter debugHighlighter
    
    public static val MODEL_ELEMENT = "Model Element"
    
    val statesWithBreakpoint = <State> newHashSet 
    val transitionsWithBreakpoint = <Transition> newHashSet
    
    val stateToBreakpoint = <State, List<IJavaBreakpoint>> newHashMap
    val transitionToBreakpoint = <Transition, List<IJavaBreakpoint>> newHashMap
    
    @Inject extension SCChartsScopeExtensions
    
    /**
     * Private for singleton behavior.
     */
    private new() {
        debugHighlighter = DebugHighlighter.instance
        Guice.createInjector.injectMembers(this)
    }
    
    static def getInstance() {
        if (instance === null) {
            instance = new DebugBreakpointManager()
        }
        return instance
    }
    
    def toggleBreakpoint(State state) {
        if (statesWithBreakpoint.contains(state)) {
            statesWithBreakpoint.remove(state)
            debugHighlighter.removeBreakpointHighlight(state)
            state.clearBreakpoints
            stateToBreakpoint.remove(state)
        } else {
            statesWithBreakpoint.add(state)
            debugHighlighter.addBreakpointHighlight(state)
            val breakpoints = <IJavaBreakpoint> newLinkedList
            for (line : state.findStateLines) {
                val bp = createBreakpointOnLine(line, BreakpointType.STATE_BREAKPOINT, state, null)
                breakpoints.add(bp)
            }
            stateToBreakpoint.put(state, breakpoints)
        }
    }
    
    def toggleBreakpoint(Transition transition) {
        if (transitionsWithBreakpoint.contains(transition)) {
            transitionsWithBreakpoint.remove(transition)
            debugHighlighter.removeBreakpointDecorator(transition)
            transition.clearBreakpoints
            transitionToBreakpoint.remove(transition)
        } else {
            transitionsWithBreakpoint.add(transition)
            debugHighlighter.addBreakpointDecorator(transition)
            val breakpoints = <IJavaBreakpoint> newLinkedList
            for (line : transition.findTransitionLines) {
                val bp = createBreakpointOnLine(line, BreakpointType.TRANSITION_CHECK_BREAKPOINT, null, transition)
                breakpoints.add(bp)
            }
            transitionToBreakpoint.put(transition, breakpoints)
        }
    }
    
    /**
     * Checks a loaded breakpoint and registers it if this hasn't happened yet.
     * Required since the registered breakpoints are lost after restarting Eclipse, but the markers remain there.
     */
    def presentBreakpoint(IJavaBreakpoint breakpoint, SCCharts model) {
        
        if (breakpoint instanceof TransitionCheckBreakpoint) {
            var transition = breakpoint.transition
            if (transition === null) {
                // the transition reference was lost over the restart of Eclipse.
                // use name hash to recover it.
                val hash = breakpoint.marker.attributes.get(MODEL_ELEMENT) as Integer
                val allStates = model.rootStates.map[allStates].map[toList].flatten
                val allTransitions = allStates.map[outgoingTransitions].map[toList].flatten
                transition = allTransitions.findFirst[DebugAnnotations.getFullNameHash(it) == hash]
            }
            if (!transitionsWithBreakpoint.contains(transition)) {
                transitionsWithBreakpoint.add(transition)
                transitionToBreakpoint.put(transition, newLinkedList(breakpoint))
            } else {
                // else, check whether this one is registered and if not, add it to the list
                val breakpoints = transitionToBreakpoint.get(transition)
                if (breakpoints !== null && !breakpoints.contains(breakpoint)) {
                    breakpoints.add(breakpoint)
                }
            }
        } else if (breakpoint instanceof StateBreakpoint) {
            var state = breakpoint.state
            if (state === null) {
                // the state reference was lost over the restart of Eclipse.
                // use name hash to recover it.
                val hash = breakpoint.marker.attributes.get(MODEL_ELEMENT) as Integer
                val allStates = model.rootStates.map[allStates].map[toList].flatten
                state = allStates.findFirst[DebugAnnotations.getFullNameHash(it as State) == hash]
            }
            if (!statesWithBreakpoint.contains(state)) {
                statesWithBreakpoint.add(state)
                stateToBreakpoint.put(state, newLinkedList(breakpoint))
            } else {
                // else, check whether this one is registered and if not, add it to the list
                val breakpoints = stateToBreakpoint.get(state)
                if (breakpoints !== null && !breakpoints.contains(breakpoint)) {
                    breakpoints.add(breakpoint)   
                }
            }
        }
    }
    
    private def IJavaBreakpoint createBreakpointOnLine(int line, BreakpointType breakpointType, State state, Transition transition) {
        
        val editor = activeEditor
        val resource = editor.editorInput.getAdapter(IResource)
        val typeRoot = JavaUI.getEditorInputTypeRoot(editor.editorInput)
        val compilationUnit = (typeRoot.getAdapter(ICompilationUnit) as ICompilationUnit)
        val type = compilationUnit.types.head
        
        // TODO
        /*
         * -1, -1: No associated start / end characters
         * 0: Always suspend (after 0 hits)
         * true: Register in breakpoint manager
         * empty map: No attributes (for now)
         */
        val attributes = <String, Object> newHashMap
        attributes.put(IBreakpoint.ENABLED, true)
        attributes.put(IBreakpoint.PERSISTED, true)
        attributes.put(IMarker.LINE_NUMBER, line)
        
        var IJavaBreakpoint breakpoint
         
        switch(breakpointType) {
            case TRANSITION_CHECK_BREAKPOINT:
                {
                    attributes.put(MODEL_ELEMENT, DebugAnnotations.getFullNameHash(transition))
                    breakpoint = new TransitionCheckBreakpoint(resource, type.fullyQualifiedName, line + 1, -1, -1, 0, true, attributes, transition)
                } 
            case STATE_BREAKPOINT:
                {
                    attributes.put(MODEL_ELEMENT, DebugAnnotations.getFullNameHash(state))
                    breakpoint =  new StateBreakpoint(resource, type.fullyQualifiedName, line + 1, -1, -1, 0, true, attributes, state)
                }
        } 
        
        Display.^default.asyncExec(new Runnable() {
            override run() {
                Display.^default.update
            }
        })
       
        return breakpoint
    }
    
    private def findTransitionLines(Transition transition) {
        
        val editor = getActiveEditor
        val transitionLines = <Integer> newLinkedList
        val document = editor.documentProvider.getDocument(editor.editorInput)
        val nameHash = DebugAnnotations.getFullNameHash(transition)
        
        // Use Regex to find transition marker comment format
        val matcher = Pattern.compile("// Transition [a-zA-Z]+ \\(Priority \\d+\\) -> [a-zA-Z]+ \\(" + nameHash + "\\)")
            .matcher(document.get)
        
        // Record all lines with matching comment in them
        while(matcher.find) {
            transitionLines.add(document.getLineOfOffset(matcher.start))
        }
        
        return transitionLines
    }
    
    private def findStateLines(State state) {
        val editor = getActiveEditor
        val stateLines = <Integer> newLinkedList
        
        val document = editor.documentProvider.getDocument(editor.editorInput)
        val nameHash = DebugAnnotations.getFullNameHash(state)
        
        // Use Regex to find state marker comment format
        val matcher = Pattern.compile("\\* State [a-zA-Z0-9]+ \\(" + nameHash + "\\)")
            .matcher(document.get)
            
        while(matcher.find) {
            // Comment format always has a closing comment marker in the next line.
            // After that comes the method signature and the breakpoint needs to be set on the line after that,
            // thus matching line + 3.
            stateLines.add(document.getLineOfOffset(matcher.start) + 3)
        }    
        
        return stateLines
    }
    
    private def clearBreakpoints(Transition transition) {
        for (breakpoint : transitionToBreakpoint.get(transition)) {
            breakpoint.delete
        }
    }
    
    private def clearBreakpoints(State state) {
        for (breakpoint : stateToBreakpoint.get(state)) {
            breakpoint.delete
        }
    }
    
    private def getActiveEditor() {
        // Use UIJob to get active editor -----------------------------------------
        val ITextEditor[] editorArr = newArrayOfSize(1)

        Display.^default.syncExec(new Runnable() {
            override run() {
                editorArr.set(0, PlatformUI.workbench?.activeWorkbenchWindow?.activePage?.activeEditor as ITextEditor)
            }
        })

        return editorArr.head
    }
    
}