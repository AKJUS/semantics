grammar de.cau.cs.kieler.sccharts.text3.Sct3 with de.cau.cs.kieler.sccharts.text.actions.Actions

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions 
import "http://kieler.cs.cau.de/keffects/0.1.0" as keffects
import "http://kieler.cs.cau.de/kext/kext" as kext
import "http://kieler.cs.cau.de/sccharts/0.1.0" as sccharts

//generate sct3 "http://kieler.cs.cau.de/sccharts/textual3/0.1.0"

// ---------------------------------------------------------------------------------------------------

SCCharts returns sccharts::SCCharts:
    rootStates += RootState*;


RootState returns sccharts::State:
    (annotations += Annotation)*
    'scchart' id=ID label=STRING?
  	
  	(('is' expression = Expression)
  	|
    ('{'
    	(declarations+=DeclarationWOSemicolon | localActions+=LocalAction)*
        ((regions+=SingleDataflowRegion|regions+=SingleControlflowRegion)(regions += Region)*)?
    '}'));
    

State returns sccharts::State:
    (annotations += Annotation)*
    initial?= 'initial'? final?='final'? type=StateType? 
    'state' id=ID label=STRING?
  
  	(('is' expression = Expression)
  	|
    ('{'
    	(declarations+=DeclarationWOSemicolon | localActions+=LocalAction)*
        ((regions+=SingleDataflowRegion|regions+=SingleControlflowRegion)(regions += Region)*)?
    '}'))?
     // The semicolon is mandatory for backtracking!
    (outgoingTransitions+=Transition)*;
    

Transition returns sccharts::Transition:
    (annotations += Annotation)*
    (type=TransitionType) 
    targetState=[sccharts::State|ID] 
	immediate?='immediate'? 
	deferred?='deferred'? 
	history=HistoryType?
	(('if' (delay=INT? trigger=BoolExpression)? ('then' effects+=Effect (';'effects+=Effect)*)?)
    |
	('if' label=STRING))?;


SingleControlflowRegion returns sccharts::ControlflowRegion:
	{sccharts::ControlflowRegion}
    ((annotations += Annotation)*
    	'region' (id=ID)? (label=STRING)? ':'
    	(declarations+=DeclarationWOSemicolon)*
    )?
    (states+=State)*;


SingleDataflowRegion returns sccharts::DataflowRegion:
    {sccharts::DataflowRegion}
    ((annotations += Annotation)*
    	'dataflow' (id=ID)? (label=STRING)? ':'
    	(declarations+=DeclarationWOSemicolon)*
    )
    (equations += Equation)*;


Region returns sccharts::Region:
    ControlflowRegion | DataflowRegion;


ControlflowRegion returns sccharts::ControlflowRegion:
	{sccharts::ControlflowRegion}
    (annotations += Annotation)*
    'region' (id=ID)? (label=STRING)? ':'
    (declarations+=DeclarationWOSemicolon)*
    (states+=State)+;


DataflowRegion returns sccharts::DataflowRegion:
    {sccharts::DataflowRegion}
    (annotations += Annotation)*
    'dataflow' (id=ID)? (label=STRING)? ':'
    (declarations+=DeclarationWOSemicolon)*
    (
        (equations += Equation)
        |
        (scopeDeclarations += ScopeDeclaration)
    )*
;


ScopeDeclaration returns sccharts::ScopeDeclaration:
    {sccharts::ScopeDeclaration}
    (annotations+=Annotation)*
    scopeObjects += ScopeObject* 
;

ScopeObject returns sccharts::ScopeObject:
    name=ID 'is' scope= [sccharts::Scope|ID]
;


Equation returns sccharts::Equation:
    {sccharts::Equation}
    (
        (valuedObject = [kexpressions::ValuedObject]) '=' (expression = Expression) ';'
    );





    
    
LocalAction returns sccharts::LocalAction:
    EntryAction | DuringAction | ExitAction | SuspendAction | IterateAction;    
    




ScopeReference returns sccharts::ScopeReference:
    scope=[sccharts::Scope|ID];

ScopeCall returns sccharts::ScopeCall:
    '[' scope=[sccharts::Scope|ID]
    	(('(' parameters += Parameter (',' parameters += Parameter)* ')') | '()')? 
    ']'
    ('.' valuedObject = [kexpressions::ValuedObject])
;


Binding returns sccharts::Binding:
    (annotations+=Annotation)*
	formal = [kexpressions::ValuedObject|ID] 
	'to' 
	actual = [kexpressions::ValuedObject|ID]
;

AtomicExpression returns kexpressions::Expression:
    BoolValue
    | ValuedObjectTestExpression 
    | '(' BoolExpression ')'
    | FunctionCall
    | ScopeCall
    | TextExpression;



enum StateType returns sccharts::StateType:
	NORMAL = 'normal' | CONNECTOR = 'connector' | REFERENCE = 'reference' | TEXTUAL = 'textual';

enum TransitionType returns sccharts::TransitionType:
	WEAKABORT = '--' | STRONGABORT = '-- abort' | TERMINATION = '-- join';
	
	
	
//Node returns sccharts::Node:
//    ReferenceNode | CallNode | DefineNode;
//    
//
////CallNode returns sccharts::CallNode:
////    {sccharts::CallNode}
////    (id=ID) '=' callReference = [sccharts::DefineNode|ID]
////    '(' (parameters+=ValuedObjectReference)? (',' parameters+=ValuedObjectReference)* ')'
////    ';';
////    
////
////DefineNode returns sccharts::DefineNode:
////    {sccharts::DefineNode}
////    'node' (id=ID) '(' (inputs+=DeclarationWOSemicolon)* ')'
////    'returns' '(' (outputs+=DeclarationWOSemicolon)* ')' '{'
////    (
////        ((valuedObjects += [kexpressions::ValuedObject]) '=' (expressions += Expression) ';')*
////        | // keep that? yes, but do not allow to mix them
////        (states+=State)*
////    )
////    '}';
////    
////
////ReferenceNode returns sccharts::ReferenceNode:
////    {sccharts::ReferenceNode}
////    (id=ID) (label=STRING)? '=' 'ref' referencedScope = [sccharts::State|ID]
////    '(' (parameters+=ValuedObjectReference)? (',' parameters+=ValuedObjectReference)* ')'
////    ';';	
	
	