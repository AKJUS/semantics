grammar de.cau.cs.kieler.sccharts.text.sct.Sct with de.cau.cs.kieler.sccharts.text.actions.Actions

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions 
import "http://kieler.cs.cau.de/sccharts/0.1.0" as sccharts

generate sct "http://kieler.cs.cau.de/sccharts/textual/0.1.0"

// ---------------------------------------------------------------------------------------------------

Root returns sccharts::State:
    SCChart
;

// ---------------------------------------------------------------------------------------------------

SingleRegion returns sccharts::Region:
	{sccharts::Region}
    (
      (annotations += Annotation)*
      'region' (id=ID)? (label=STRING)? ('['for=For']')?  ':'
      (declarations+=Declaration)*
//      (bodyText+=TextualCode)* 
     )?
    (states+=State)*;
    

// ---------------------------------------------------------------------------------------------------

SingleDataflow returns sccharts::Dataflow:
    {sccharts::Dataflow}
    (
      (annotations += Annotation)*
      'dataflow' (id=ID)? (label=STRING)? ('['for=For']')?  ':'
      (declarations+=Declaration)*
     )?
    
//    ((valuedObjects += [kexpressions::ValuedObject]) '=' (expressions += Expression) ';')*
//    (nodes+=Node)*
    (
        (features += Feature) 
        |
        (nodes+=Node) // alt: + (nodes+=Node)+
    )*
;

// ---------------------------------------------------------------------------------------------------

For returns sccharts::For:
    {sccharts::For}
    valuedObject=ValuedObject '=' from=INT '..' to=INT 
;

// ---------------------------------------------------------------------------------------------------

Region returns sccharts::Region:
	{sccharts::Region}
    (annotations += Annotation)*
    'region' (id=ID)? (label=STRING)? ('['for=For']')? ':'
      (declarations+=Declaration)*
    (states+=State)+;


// ---------------------------------------------------------------------------------------------------

Dataflow returns sccharts::Dataflow:
    {sccharts::Dataflow}
    (annotations += Annotation)*
    'dataflow' (id=ID)? (label=STRING)? ('['for=For']')? ':'
      (declarations+=Declaration)*
//    (
//        (valuedObjects += [kexpressions::ValuedObject]) '=' (expressions += Expression) ';'
//        |
//        (valuedObjects += [kexpressions::ValuedObject]) '=' /*(nodes+=TestReferenceNode|ID'.')?*/ (expressions += ValuedObjectReference) ';'
//    )*
    (
        (features += Feature) 
        |
        (nodes+=Node) // alt: + (nodes+=Node)+
    )*
;

Feature returns sccharts::DataflowFeature:
    {sccharts::DataflowFeature}
    (
        //(valuedObjects += [kexpressions::ValuedObject]) '=' (expressions += Expression) ';'
        (valuedObject = [kexpressions::ValuedObject]) '=' (expression = Expression) ';'
        |
        //(valuedObjects += [kexpressions::ValuedObject]) '=' (expressions += ValuedObjectReference) ';'
        //(valuedObject = [kexpressions::ValuedObject]) '=' (expressions += ValuedObjectReference) ';'
        //|
        //node = [sccharts::Node|ID] ('.' valuedObject = [kexpressions::ValuedObject])?
        //(valuedObjects += [kexpressions::ValuedObject]) '=' (node = [sccharts::Node|ID] '.')? (expressions += ValuedObjectReference) ';'
        (valuedObject = [kexpressions::ValuedObject]) '=' (node = [sccharts::Node|ID] '.')? (expression = ValuedObjectReference) ';'
    )
;

// ---------------------------------------------------------------------------------------------------

SCChart returns sccharts::State:
//    ('package' name = QualifiedName)?
//    imports += ImportDecl*
//    
    (annotations += Annotation)*
    ('scchart') (id=ID) (label=STRING)?
  
    (
      ('references' referencedScope = [sccharts::State|ID]
        ('bind' bindings += Binding (',' bindings += Binding)*)?
       )
     | 
      ('{'
          (
            (declarations+=Declaration |
             localActions+=LocalAction)*
            (
//                (concurrencies+=SingleRegion)|
//             	(concurrencies+=SingleDataflow)|
//             	(concurrencies+=Concurrency)*
//				(concurrencies+=SingleRegion)(concurrencies+=Region)*
				(concurrencies+=SingleRegion|concurrencies+=SingleDataflow)(concurrencies+=Concurrency)*
             )?
            )
          '}') 
     )?
;

Concurrency returns sccharts::Concurrency:
	Region | Dataflow	
;

ImportDecl: 
    'import' 
        (importedType=[sccharts::State|QualifiedName] 
        | importedNamespace=QualifiedNameWithWildcard)
;

QualifiedName:
  ID ('.' ID)*;

QualifiedNameWithWildcard :
    QualifiedName  '.' '*';

// ---------------------------------------------------------------------------------------------------

State returns sccharts::State:
    (annotations += Annotation)*
    (
      ((initial?='initial') (final?='final')?)
     |
      ((final?='final') (initial?='initial')?)
     )?
  
    (type=StateType)? ('state') (id=ID) (label=STRING)?
  
    (
      ('references' referencedScope = [sccharts::State|ID]
        ('bind' bindings += Binding (',' bindings += Binding)*)?
       )
     | 
      ('{'
          (
            (declarations+=Declaration |
             localActions+=LocalAction)*
            (
//                (concurrencies+=SingleRegion)|
//             	(concurrencies+=SingleDataflow)|
//             	(concurrencies+=Concurrency)*
				(concurrencies+=SingleRegion|concurrencies+=SingleDataflow)(concurrencies+=Concurrency)*
             )
            )
          '}') 
     )?
     // The semicolon is mandatory for backtracking!
    (outgoingTransitions+=Transition)* ';';


Node returns sccharts::Node:
    InputNode | OutputNode | ReferencedNode | TestReferenceNode | CallNode | DefineNode
;

CallNode returns sccharts::CallNode:
    {sccharts::CallNode}
    (id=ID) '=' callReference = [sccharts::DefineNode|ID]
//    (( 
//        callReference = [sccharts::DefineNode|ID]
//        
//        )?
//    |
//        (
//        referencedScope = [sccharts::State|ID]
//        )?
//    )
    '(' (parameters+=Expression)? (',' parameters+=Expression)* ')'
    ';'
;

DefineNode returns sccharts::DefineNode:
    {sccharts::DefineNode}
    'node' (id=ID) '(' (inputs+=Declaration)* ')'
    'returns' '(' (outputs+=Declaration)* ')' '{'
    (
        ((valuedObjects += [kexpressions::ValuedObject]) '=' (expressions += Expression) ';')*
        | // keep that?
        (states+=State)*
    )
    '}'
;

InputNode returns sccharts::InputNode:
    {sccharts::InputNode}
    'node' (id=ID) (label=STRING)? 'input' ':'
    (senders += SenderInput) ';'
;

OutputNode returns sccharts::OutputNode:
    {sccharts::OutputNode}
    'node' (id=ID) (label=STRING)? 'output' ':'
    valuedObject = [kexpressions::ValuedObject]
    ';'
;

ReferencedNode returns sccharts::ReferencedNode:
    {sccharts::ReferencedNode}
    'node' (id=ID) (label=STRING)? ':'
    referencedScope = [sccharts::State|ID]
    (senders += Sender)* ';'
;

/*
 * alte (erste) Testreferenz, mit umgedrehter Notation
 */
//TestReferenceNode returns sccharts::TestReferenceNode:
//    {sccharts::TestReferenceNode}
//    'node' (id=ID) (label=STRING)? 'testRef' ':'
//    referencedScope = [sccharts::State|ID]
//    '(' (testReceivers += ReceiverTest)* ')'
//    ';'
//;

TestReferenceNode returns sccharts::TestReferenceNode:
    {sccharts::TestReferenceNode}
    (id=ID) (label=STRING)? '=' 'ref' referencedScope = [sccharts::State|ID]
    '(' (parameters+=Expression)? (',' parameters+=Expression)* ')'
    ';'
;

SenderInput returns sccharts::Sender:
    {sccharts::Sender}
    expression = Expression
    ('-->' receivers += Receiver)*
;

Sender returns sccharts::Sender:
	{sccharts::Sender}
	expression = ValuedObjectReference
    ('-->' receivers += Receiver)*
;

Receiver returns sccharts::Receiver:
    {sccharts::Receiver}
    node = [sccharts::Node|ID] ('.' valuedObject = [kexpressions::ValuedObject])?
;
    
// ---------------------------------------------------------------------------------------------------

LocalAction returns sccharts::LocalAction:
    EntryAction | DuringAction | ExitAction | SuspendAction
;    
    
// ---------------------------------------------------------------------------------------------------

Transition returns sccharts::Transition:
    (annotations += Annotation)*
    (type=TransitionTypeLegacy | type=TransitionType) 
    targetState=[sccharts::State|ID] 
//	type=TransitionType (priority=INT)? targetState=[sccharts::State|ID] 
	( (immediate?='immediate')? (deferred?='deferred')? (history=HistoryType)?  (
	 (
	   ((('with' (delay=INT)? trigger=BoolExpression)|'with')? (('/'|'do') effects+=Effect (';'effects+=Effect)*)? )
	  |
	   ( 'with' label=STRING )
	  )
	 )?)? 	
	;

// ---------------------------------------------------------------------------------------------------

Declaration returns kexpressions::Declaration:
    (annotations+=Annotation)*
    (
        ((extern?='extern')?
        (static?='static')?
	    (const?='const')?
        (input?='input')?
        (output?='output')?
        (
            ((signal?='signal')? type = ValueType)
            |
            (signal?='signal')
        ))
        |
        ((extern?='extern')
        (static?='static')?
        (const?='const')?
        (input?='input')?
        (output?='output')?        
        (signal?='signal')? 
        (type = ValueType)?)
    )
    valuedObjects+=ValuedObject (',' valuedObjects+=ValuedObject)* ';'?
;

// ---------------------------------------------------------------------------------------------------

ValuedObject returns kexpressions::ValuedObject:
    name=ID
    ('[' cardinalities+=INT ']')* 
    ('=' initialValue=Expression)?
    ( 'combine'
      (combineOperator = CombineOperator)
    )?
;

// ---------------------------------------------------------------------------------------------------

TextualCode returns kexpressions::TextExpression:
    text = HOSTCODE ';';

// ---------------------------------------------------------------------------------------------------

Binding returns sccharts::Binding:
    (annotations+=Annotation)*
	formal = [kexpressions::ValuedObject|ID] 
	'to' 
	actual = [kexpressions::ValuedObject|ID]
;


// ---------------------------------------------------------------------------------------------------


// ---------------------------------------------------------------------------------------------------

enum StateType returns sccharts::StateType:
	NORMAL = 'normal' | CONNECTOR = 'connector' | REFERENCE = 'reference' | TEXTUAL = 'textual';

enum TransitionType returns sccharts::TransitionType:
	WEAKABORT = 'goto' | STRONGABORT = 'abort to' | TERMINATION = 'join to';
	
enum TransitionTypeLegacy returns sccharts::TransitionType:
    WEAKABORT = '-->' | STRONGABORT = 'o->' | TERMINATION = '>->';
	