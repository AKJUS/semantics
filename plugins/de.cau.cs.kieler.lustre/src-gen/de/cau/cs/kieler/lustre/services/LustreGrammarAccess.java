/*
 * generated by Xtext
 */
package de.cau.cs.kieler.lustre.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class LustreGrammarAccess extends AbstractGrammarElementFinder {
	
	public class LustreProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LustreProgram");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIncludesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIncludesIncludeParserRuleCall_0_0 = (RuleCall)cIncludesAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cPackBodyAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cPackBodyPackBodyParserRuleCall_1_0_0 = (RuleCall)cPackBodyAssignment_1_0.eContents().get(0);
		private final Assignment cPackListAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cPackListPackListParserRuleCall_1_1_0 = (RuleCall)cPackListAssignment_1_1.eContents().get(0);
		
		//LustreProgram hidden(WS, LUSTRE_COMMENT):
		//	includes+=Include* (packBody=PackBody | packList=PackList);
		@Override public ParserRule getRule() { return rule; }
		
		//includes+=Include* (packBody=PackBody | packList=PackList)
		public Group getGroup() { return cGroup; }
		
		//includes+=Include*
		public Assignment getIncludesAssignment_0() { return cIncludesAssignment_0; }
		
		//Include
		public RuleCall getIncludesIncludeParserRuleCall_0_0() { return cIncludesIncludeParserRuleCall_0_0; }
		
		//packBody=PackBody | packList=PackList
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//packBody=PackBody
		public Assignment getPackBodyAssignment_1_0() { return cPackBodyAssignment_1_0; }
		
		//PackBody
		public RuleCall getPackBodyPackBodyParserRuleCall_1_0_0() { return cPackBodyPackBodyParserRuleCall_1_0_0; }
		
		//packList=PackList
		public Assignment getPackListAssignment_1_1() { return cPackListAssignment_1_1; }
		
		//PackList
		public RuleCall getPackListPackListParserRuleCall_1_1_0() { return cPackListPackListParserRuleCall_1_1_0; }
	}
	public class IncludeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Include");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIncludeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cSTRING_CONSTANTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		///*
		// * ---------- Include
		// */ Include:
		//	'include' STRING_CONSTANT;
		@Override public ParserRule getRule() { return rule; }
		
		//'include' STRING_CONSTANT
		public Group getGroup() { return cGroup; }
		
		//'include'
		public Keyword getIncludeKeyword_0() { return cIncludeKeyword_0; }
		
		//STRING_CONSTANT
		public RuleCall getSTRING_CONSTANTTerminalRuleCall_1() { return cSTRING_CONSTANTTerminalRuleCall_1; }
	}
	public class PackBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.PackBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cConstantsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cConstantsConstantsDeclarationParserRuleCall_0_0 = (RuleCall)cConstantsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTypeKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypesTypeDeclarationParserRuleCall_1_1_0 = (RuleCall)cTypesAssignment_1_1.eContents().get(0);
		private final Assignment cExternalsAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cExternalsExternalNodeDeclarationParserRuleCall_2_0 = (RuleCall)cExternalsAssignment_2.eContents().get(0);
		private final Assignment cNodesAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cNodesNodeDeclarationParserRuleCall_3_0 = (RuleCall)cNodesAssignment_3.eContents().get(0);
		
		///*
		// * ---------- PackBody
		// */ PackBody:
		//	(constants+=ConstantsDeclaration
		//	| 'type' types+=TypeDeclaration+ | externals+=ExternalNodeDeclaration
		//	| nodes+=NodeDeclaration)+;
		@Override public ParserRule getRule() { return rule; }
		
		//(constants+=ConstantsDeclaration | 'type' types+=TypeDeclaration+ | externals+=ExternalNodeDeclaration |
		//nodes+=NodeDeclaration)+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//constants+=ConstantsDeclaration
		public Assignment getConstantsAssignment_0() { return cConstantsAssignment_0; }
		
		//ConstantsDeclaration
		public RuleCall getConstantsConstantsDeclarationParserRuleCall_0_0() { return cConstantsConstantsDeclarationParserRuleCall_0_0; }
		
		//'type' types+=TypeDeclaration+
		public Group getGroup_1() { return cGroup_1; }
		
		//'type'
		public Keyword getTypeKeyword_1_0() { return cTypeKeyword_1_0; }
		
		//types+=TypeDeclaration+
		public Assignment getTypesAssignment_1_1() { return cTypesAssignment_1_1; }
		
		//TypeDeclaration
		public RuleCall getTypesTypeDeclarationParserRuleCall_1_1_0() { return cTypesTypeDeclarationParserRuleCall_1_1_0; }
		
		//externals+=ExternalNodeDeclaration
		public Assignment getExternalsAssignment_2() { return cExternalsAssignment_2; }
		
		//ExternalNodeDeclaration
		public RuleCall getExternalsExternalNodeDeclarationParserRuleCall_2_0() { return cExternalsExternalNodeDeclarationParserRuleCall_2_0; }
		
		//nodes+=NodeDeclaration
		public Assignment getNodesAssignment_3() { return cNodesAssignment_3; }
		
		//NodeDeclaration
		public RuleCall getNodesNodeDeclarationParserRuleCall_3_0() { return cNodesNodeDeclarationParserRuleCall_3_0; }
	}
	public class ConstantsDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ConstantsDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConstantsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstantsLustreTypedValuedIdsParserRuleCall_1_0 = (RuleCall)cConstantsAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cConstantsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cConstantsLustreTypedValuedIdsParserRuleCall_3_0_0 = (RuleCall)cConstantsAssignment_3_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//ConstantsDeclaration:
		//	'const'
		//	constants+=LustreTypedValuedIds ';' (constants+=LustreTypedValuedIds ';')*;
		@Override public ParserRule getRule() { return rule; }
		
		//'const' constants+=LustreTypedValuedIds ';' (constants+=LustreTypedValuedIds ';')*
		public Group getGroup() { return cGroup; }
		
		//'const'
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }
		
		//constants+=LustreTypedValuedIds
		public Assignment getConstantsAssignment_1() { return cConstantsAssignment_1; }
		
		//LustreTypedValuedIds
		public RuleCall getConstantsLustreTypedValuedIdsParserRuleCall_1_0() { return cConstantsLustreTypedValuedIdsParserRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
		
		//(constants+=LustreTypedValuedIds ';')*
		public Group getGroup_3() { return cGroup_3; }
		
		//constants+=LustreTypedValuedIds
		public Assignment getConstantsAssignment_3_0() { return cConstantsAssignment_3_0; }
		
		//LustreTypedValuedIds
		public RuleCall getConstantsLustreTypedValuedIdsParserRuleCall_3_0_0() { return cConstantsLustreTypedValuedIdsParserRuleCall_3_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3_1() { return cSemicolonKeyword_3_1; }
	}
	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cTypesAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cTypesTypeParserRuleCall_1_1_0_0 = (RuleCall)cTypesAssignment_1_1_0.eContents().get(0);
		private final Assignment cEnumsAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cEnumsEnumTypeParserRuleCall_1_1_1_0 = (RuleCall)cEnumsAssignment_1_1_1.eContents().get(0);
		private final Assignment cStructAssignment_1_1_2 = (Assignment)cAlternatives_1_1.eContents().get(2);
		private final RuleCall cStructStructTypeParserRuleCall_1_1_2_0 = (RuleCall)cStructAssignment_1_1_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//TypeDeclaration:
		//	name=IDENT ('=' (types=Type
		//	| enums=EnumType
		//	| struct=StructType))?
		//	';';
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT ('=' (types=Type | enums=EnumType | struct=StructType))? ';'
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//('=' (types=Type | enums=EnumType | struct=StructType))?
		public Group getGroup_1() { return cGroup_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_0() { return cEqualsSignKeyword_1_0; }
		
		//types=Type | enums=EnumType | struct=StructType
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//types=Type
		public Assignment getTypesAssignment_1_1_0() { return cTypesAssignment_1_1_0; }
		
		//Type
		public RuleCall getTypesTypeParserRuleCall_1_1_0_0() { return cTypesTypeParserRuleCall_1_1_0_0; }
		
		//enums=EnumType
		public Assignment getEnumsAssignment_1_1_1() { return cEnumsAssignment_1_1_1; }
		
		//EnumType
		public RuleCall getEnumsEnumTypeParserRuleCall_1_1_1_0() { return cEnumsEnumTypeParserRuleCall_1_1_1_0; }
		
		//struct=StructType
		public Assignment getStructAssignment_1_1_2() { return cStructAssignment_1_1_2; }
		
		//StructType
		public RuleCall getStructStructTypeParserRuleCall_1_1_2_0() { return cStructStructTypeParserRuleCall_1_1_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final Keyword cNameBoolKeyword_0_0_0 = (Keyword)cNameAssignment_0_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cNameIntKeyword_0_1_0 = (Keyword)cNameAssignment_0_1.eContents().get(0);
		private final Assignment cNameAssignment_0_2 = (Assignment)cAlternatives_0.eContents().get(2);
		private final Keyword cNameRealKeyword_0_2_0 = (Keyword)cNameAssignment_0_2.eContents().get(0);
		private final Assignment cNameAssignment_0_3 = (Assignment)cAlternatives_0.eContents().get(3);
		private final RuleCall cNameIDENTTerminalRuleCall_0_3_0 = (RuleCall)cNameAssignment_0_3.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCircumflexAccentKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cArraySizeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cArraySizeLustreExpressionParserRuleCall_1_1_0 = (RuleCall)cArraySizeAssignment_1_1.eContents().get(0);
		
		//Type:
		//	(name='bool'
		//	| name='int'
		//	| name='real'
		//	| name=IDENT) ('^' arraySize+=LustreExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//(name='bool' | name='int' | name='real' | name=IDENT) ('^' arraySize+=LustreExpression)*
		public Group getGroup() { return cGroup; }
		
		//name='bool' | name='int' | name='real' | name=IDENT
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//name='bool'
		public Assignment getNameAssignment_0_0() { return cNameAssignment_0_0; }
		
		//'bool'
		public Keyword getNameBoolKeyword_0_0_0() { return cNameBoolKeyword_0_0_0; }
		
		//name='int'
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//'int'
		public Keyword getNameIntKeyword_0_1_0() { return cNameIntKeyword_0_1_0; }
		
		//name='real'
		public Assignment getNameAssignment_0_2() { return cNameAssignment_0_2; }
		
		//'real'
		public Keyword getNameRealKeyword_0_2_0() { return cNameRealKeyword_0_2_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_3() { return cNameAssignment_0_3; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_3_0() { return cNameIDENTTerminalRuleCall_0_3_0; }
		
		//('^' arraySize+=LustreExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1_0() { return cCircumflexAccentKeyword_1_0; }
		
		//arraySize+=LustreExpression
		public Assignment getArraySizeAssignment_1_1() { return cArraySizeAssignment_1_1; }
		
		//LustreExpression
		public RuleCall getArraySizeLustreExpressionParserRuleCall_1_1_0() { return cArraySizeLustreExpressionParserRuleCall_1_1_0; }
	}
	public class EnumTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.EnumType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValuesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuesIDENTTerminalRuleCall_2_0 = (RuleCall)cValuesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cValuesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cValuesIDENTTerminalRuleCall_3_1_0 = (RuleCall)cValuesAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//EnumType:
		//	'enum' '{' values+=IDENT (',' values+=IDENT)* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'enum' '{' values+=IDENT (',' values+=IDENT)* '}'
		public Group getGroup() { return cGroup; }
		
		//'enum'
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//values+=IDENT
		public Assignment getValuesAssignment_2() { return cValuesAssignment_2; }
		
		//IDENT
		public RuleCall getValuesIDENTTerminalRuleCall_2_0() { return cValuesIDENTTerminalRuleCall_2_0; }
		
		//(',' values+=IDENT)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//values+=IDENT
		public Assignment getValuesAssignment_3_1() { return cValuesAssignment_3_1; }
		
		//IDENT
		public RuleCall getValuesIDENTTerminalRuleCall_3_1_0() { return cValuesIDENTTerminalRuleCall_3_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class StructTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.StructType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStructKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cElementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cElementsLustreTypedValuedIdsParserRuleCall_2_0 = (RuleCall)cElementsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cSemicolonKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cElementsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cElementsLustreTypedValuedIdsParserRuleCall_3_1_0 = (RuleCall)cElementsAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//StructType:
		//	'struct'? '{' elements+=LustreTypedValuedIds (';' elements+=LustreTypedValuedIds)* ';'? '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'struct'? '{' elements+=LustreTypedValuedIds (';' elements+=LustreTypedValuedIds)* ';'? '}'
		public Group getGroup() { return cGroup; }
		
		//'struct'?
		public Keyword getStructKeyword_0() { return cStructKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//elements+=LustreTypedValuedIds
		public Assignment getElementsAssignment_2() { return cElementsAssignment_2; }
		
		//LustreTypedValuedIds
		public RuleCall getElementsLustreTypedValuedIdsParserRuleCall_2_0() { return cElementsLustreTypedValuedIdsParserRuleCall_2_0; }
		
		//(';' elements+=LustreTypedValuedIds)*
		public Group getGroup_3() { return cGroup_3; }
		
		//';'
		public Keyword getSemicolonKeyword_3_0() { return cSemicolonKeyword_3_0; }
		
		//elements+=LustreTypedValuedIds
		public Assignment getElementsAssignment_3_1() { return cElementsAssignment_3_1; }
		
		//LustreTypedValuedIds
		public RuleCall getElementsLustreTypedValuedIdsParserRuleCall_3_1_0() { return cElementsLustreTypedValuedIdsParserRuleCall_3_1_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class ExternalNodeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ExternalNodeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsUnsafeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsUnsafeUnsafeKeyword_0_0 = (Keyword)cIsUnsafeAssignment_0.eContents().get(0);
		private final Keyword cExternKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cFunctionKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Assignment cHasStateAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final Keyword cHasStateNodeKeyword_2_1_0 = (Keyword)cHasStateAssignment_2_1.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameIDENTTerminalRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Assignment cInputAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInputParamsParserRuleCall_4_0 = (RuleCall)cInputAssignment_4.eContents().get(0);
		private final Keyword cReturnsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOutputAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cOutputParamsParserRuleCall_6_0 = (RuleCall)cOutputAssignment_6.eContents().get(0);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//// External Node Declaration
		//ExternalNodeDeclaration:
		//	isUnsafe?='unsafe'? 'extern' ('function' | hasState?='node') name=IDENT
		//	input=Params
		//	'returns'
		//	output=Params
		//	';'?;
		@Override public ParserRule getRule() { return rule; }
		
		//isUnsafe?='unsafe'? 'extern' ('function' | hasState?='node') name=IDENT input=Params 'returns' output=Params ';'?
		public Group getGroup() { return cGroup; }
		
		//isUnsafe?='unsafe'?
		public Assignment getIsUnsafeAssignment_0() { return cIsUnsafeAssignment_0; }
		
		//'unsafe'
		public Keyword getIsUnsafeUnsafeKeyword_0_0() { return cIsUnsafeUnsafeKeyword_0_0; }
		
		//'extern'
		public Keyword getExternKeyword_1() { return cExternKeyword_1; }
		
		//'function' | hasState?='node'
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'function'
		public Keyword getFunctionKeyword_2_0() { return cFunctionKeyword_2_0; }
		
		//hasState?='node'
		public Assignment getHasStateAssignment_2_1() { return cHasStateAssignment_2_1; }
		
		//'node'
		public Keyword getHasStateNodeKeyword_2_1_0() { return cHasStateNodeKeyword_2_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_3_0() { return cNameIDENTTerminalRuleCall_3_0; }
		
		//input=Params
		public Assignment getInputAssignment_4() { return cInputAssignment_4; }
		
		//Params
		public RuleCall getInputParamsParserRuleCall_4_0() { return cInputParamsParserRuleCall_4_0; }
		
		//'returns'
		public Keyword getReturnsKeyword_5() { return cReturnsKeyword_5; }
		
		//output=Params
		public Assignment getOutputAssignment_6() { return cOutputAssignment_6; }
		
		//Params
		public RuleCall getOutputParamsParserRuleCall_6_0() { return cOutputParamsParserRuleCall_6_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}
	public class NodeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.NodeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsUnsafeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsUnsafeUnsafeKeyword_0_0 = (Keyword)cIsUnsafeAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cFunctionKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Assignment cHasStateAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final Keyword cHasStateNodeKeyword_1_1_0 = (Keyword)cHasStateAssignment_1_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDENTTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLessThanSignLessThanSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cStaticParamsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cStaticParamsStaticParamParserRuleCall_3_1_0 = (RuleCall)cStaticParamsAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cSemicolonKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cStaticParamsAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cStaticParamsStaticParamParserRuleCall_3_2_1_0 = (RuleCall)cStaticParamsAssignment_3_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_3_3 = (Keyword)cGroup_3.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Group cGroup_4_0 = (Group)cAlternatives_4.eContents().get(0);
		private final Assignment cInputAssignment_4_0_0 = (Assignment)cGroup_4_0.eContents().get(0);
		private final RuleCall cInputParamsParserRuleCall_4_0_0_0 = (RuleCall)cInputAssignment_4_0_0.eContents().get(0);
		private final Keyword cReturnsKeyword_4_0_1 = (Keyword)cGroup_4_0.eContents().get(1);
		private final Assignment cOutputAssignment_4_0_2 = (Assignment)cGroup_4_0.eContents().get(2);
		private final RuleCall cOutputParamsParserRuleCall_4_0_2_0 = (RuleCall)cOutputAssignment_4_0_2.eContents().get(0);
		private final Alternatives cAlternatives_4_0_3 = (Alternatives)cGroup_4_0.eContents().get(3);
		private final Group cGroup_4_0_3_0 = (Group)cAlternatives_4_0_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4_0_3_0_0 = (Keyword)cGroup_4_0_3_0.eContents().get(0);
		private final Assignment cEffectiveNodeAssignment_4_0_3_0_1 = (Assignment)cGroup_4_0_3_0.eContents().get(1);
		private final RuleCall cEffectiveNodeIdentRefParserRuleCall_4_0_3_0_1_0 = (RuleCall)cEffectiveNodeAssignment_4_0_3_0_1.eContents().get(0);
		private final Group cGroup_4_0_3_0_2 = (Group)cGroup_4_0_3_0.eContents().get(2);
		private final Keyword cLessThanSignLessThanSignKeyword_4_0_3_0_2_0 = (Keyword)cGroup_4_0_3_0_2.eContents().get(0);
		private final Assignment cStaticArgsAssignment_4_0_3_0_2_1 = (Assignment)cGroup_4_0_3_0_2.eContents().get(1);
		private final RuleCall cStaticArgsStaticArgParserRuleCall_4_0_3_0_2_1_0 = (RuleCall)cStaticArgsAssignment_4_0_3_0_2_1.eContents().get(0);
		private final Group cGroup_4_0_3_0_2_2 = (Group)cGroup_4_0_3_0_2.eContents().get(2);
		private final Keyword cSemicolonKeyword_4_0_3_0_2_2_0 = (Keyword)cGroup_4_0_3_0_2_2.eContents().get(0);
		private final Assignment cStaticArgsAssignment_4_0_3_0_2_2_1 = (Assignment)cGroup_4_0_3_0_2_2.eContents().get(1);
		private final RuleCall cStaticArgsStaticArgParserRuleCall_4_0_3_0_2_2_1_0 = (RuleCall)cStaticArgsAssignment_4_0_3_0_2_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_4_0_3_0_2_3 = (Keyword)cGroup_4_0_3_0_2.eContents().get(3);
		private final Group cGroup_4_0_3_1 = (Group)cAlternatives_4_0_3.eContents().get(1);
		private final Keyword cSemicolonKeyword_4_0_3_1_0 = (Keyword)cGroup_4_0_3_1.eContents().get(0);
		private final Alternatives cAlternatives_4_0_3_1_1 = (Alternatives)cGroup_4_0_3_1.eContents().get(1);
		private final Assignment cConstantsAssignment_4_0_3_1_1_0 = (Assignment)cAlternatives_4_0_3_1_1.eContents().get(0);
		private final RuleCall cConstantsConstantsDeclarationParserRuleCall_4_0_3_1_1_0_0 = (RuleCall)cConstantsAssignment_4_0_3_1_1_0.eContents().get(0);
		private final Group cGroup_4_0_3_1_1_1 = (Group)cAlternatives_4_0_3_1_1.eContents().get(1);
		private final Keyword cVarKeyword_4_0_3_1_1_1_0 = (Keyword)cGroup_4_0_3_1_1_1.eContents().get(0);
		private final Assignment cVariablesAssignment_4_0_3_1_1_1_1 = (Assignment)cGroup_4_0_3_1_1_1.eContents().get(1);
		private final RuleCall cVariablesLustreClockedIdDeclarationParserRuleCall_4_0_3_1_1_1_1_0 = (RuleCall)cVariablesAssignment_4_0_3_1_1_1_1.eContents().get(0);
		private final Group cGroup_4_0_3_1_1_1_2 = (Group)cGroup_4_0_3_1_1_1.eContents().get(2);
		private final Keyword cSemicolonKeyword_4_0_3_1_1_1_2_0 = (Keyword)cGroup_4_0_3_1_1_1_2.eContents().get(0);
		private final Assignment cVariablesAssignment_4_0_3_1_1_1_2_1 = (Assignment)cGroup_4_0_3_1_1_1_2.eContents().get(1);
		private final RuleCall cVariablesLustreClockedIdDeclarationParserRuleCall_4_0_3_1_1_1_2_1_0 = (RuleCall)cVariablesAssignment_4_0_3_1_1_1_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_0_3_1_1_1_3 = (Keyword)cGroup_4_0_3_1_1_1.eContents().get(3);
		private final Keyword cLetKeyword_4_0_3_1_2 = (Keyword)cGroup_4_0_3_1.eContents().get(2);
		private final Alternatives cAlternatives_4_0_3_1_3 = (Alternatives)cGroup_4_0_3_1.eContents().get(3);
		private final Assignment cEquationsAssignment_4_0_3_1_3_0 = (Assignment)cAlternatives_4_0_3_1_3.eContents().get(0);
		private final RuleCall cEquationsEquationParserRuleCall_4_0_3_1_3_0_0 = (RuleCall)cEquationsAssignment_4_0_3_1_3_0.eContents().get(0);
		private final Assignment cAssertionsAssignment_4_0_3_1_3_1 = (Assignment)cAlternatives_4_0_3_1_3.eContents().get(1);
		private final RuleCall cAssertionsAssertionParserRuleCall_4_0_3_1_3_1_0 = (RuleCall)cAssertionsAssignment_4_0_3_1_3_1.eContents().get(0);
		private final Assignment cAutomatonsAssignment_4_0_3_1_3_2 = (Assignment)cAlternatives_4_0_3_1_3.eContents().get(2);
		private final RuleCall cAutomatonsAutomatonParserRuleCall_4_0_3_1_3_2_0 = (RuleCall)cAutomatonsAssignment_4_0_3_1_3_2.eContents().get(0);
		private final Keyword cTelKeyword_4_0_3_1_4 = (Keyword)cGroup_4_0_3_1.eContents().get(4);
		private final Alternatives cAlternatives_4_0_3_1_5 = (Alternatives)cGroup_4_0_3_1.eContents().get(5);
		private final Keyword cFullStopKeyword_4_0_3_1_5_0 = (Keyword)cAlternatives_4_0_3_1_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_0_3_1_5_1 = (Keyword)cAlternatives_4_0_3_1_5.eContents().get(1);
		private final Group cGroup_4_1 = (Group)cAlternatives_4.eContents().get(1);
		private final Keyword cEqualsSignKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cEffectiveNodeAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cEffectiveNodeIdentRefParserRuleCall_4_1_1_0 = (RuleCall)cEffectiveNodeAssignment_4_1_1.eContents().get(0);
		private final Group cGroup_4_1_2 = (Group)cGroup_4_1.eContents().get(2);
		private final Keyword cLessThanSignLessThanSignKeyword_4_1_2_0 = (Keyword)cGroup_4_1_2.eContents().get(0);
		private final Assignment cStaticArgsAssignment_4_1_2_1 = (Assignment)cGroup_4_1_2.eContents().get(1);
		private final RuleCall cStaticArgsStaticArgParserRuleCall_4_1_2_1_0 = (RuleCall)cStaticArgsAssignment_4_1_2_1.eContents().get(0);
		private final Group cGroup_4_1_2_2 = (Group)cGroup_4_1_2.eContents().get(2);
		private final Keyword cSemicolonKeyword_4_1_2_2_0 = (Keyword)cGroup_4_1_2_2.eContents().get(0);
		private final Assignment cStaticArgsAssignment_4_1_2_2_1 = (Assignment)cGroup_4_1_2_2.eContents().get(1);
		private final RuleCall cStaticArgsStaticArgParserRuleCall_4_1_2_2_1_0 = (RuleCall)cStaticArgsAssignment_4_1_2_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_4_1_2_3 = (Keyword)cGroup_4_1_2.eContents().get(3);
		
		//// Node Declaration
		//NodeDeclaration:
		//	isUnsafe?='unsafe'? ('function' | hasState?='node') name=IDENT ('<<' staticParams+=StaticParam (';'
		//	staticParams+=StaticParam)* '>>')? (input=Params 'returns' output=Params ('=' effectiveNode=IdentRef ('<<'
		//	staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')? | ';'? (constants+=ConstantsDeclaration | 'var'
		//	variables+=LustreClockedIdDeclaration (';' variables+=LustreClockedIdDeclaration)* ';')*
		//	// Body 
		//	'let' (equations+=Equation
		//	| assertions+=Assertion
		//	| automatons+=Automaton)*
		//	'tel' ('.' | ';'?)) | // --- Effective Node (without interface)
		//	'=' effectiveNode=IdentRef ('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?);
		@Override public ParserRule getRule() { return rule; }
		
		//isUnsafe?='unsafe'? ('function' | hasState?='node') name=IDENT ('<<' staticParams+=StaticParam (';'
		//staticParams+=StaticParam)* '>>')? (input=Params 'returns' output=Params ('=' effectiveNode=IdentRef ('<<'
		//staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')? | ';'? (constants+=ConstantsDeclaration | 'var'
		//variables+=LustreClockedIdDeclaration (';' variables+=LustreClockedIdDeclaration)* ';')* // Body 
		//'let' (equations+=Equation | assertions+=Assertion | automatons+=Automaton)* 'tel' ('.' | ';'?)) | // --- Effective Node (without interface)
		//'=' effectiveNode=IdentRef ('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?)
		public Group getGroup() { return cGroup; }
		
		//isUnsafe?='unsafe'?
		public Assignment getIsUnsafeAssignment_0() { return cIsUnsafeAssignment_0; }
		
		//'unsafe'
		public Keyword getIsUnsafeUnsafeKeyword_0_0() { return cIsUnsafeUnsafeKeyword_0_0; }
		
		//'function' | hasState?='node'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'function'
		public Keyword getFunctionKeyword_1_0() { return cFunctionKeyword_1_0; }
		
		//hasState?='node'
		public Assignment getHasStateAssignment_1_1() { return cHasStateAssignment_1_1; }
		
		//'node'
		public Keyword getHasStateNodeKeyword_1_1_0() { return cHasStateNodeKeyword_1_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_2_0() { return cNameIDENTTerminalRuleCall_2_0; }
		
		//('<<' staticParams+=StaticParam (';' staticParams+=StaticParam)* '>>')?
		public Group getGroup_3() { return cGroup_3; }
		
		//'<<'
		public Keyword getLessThanSignLessThanSignKeyword_3_0() { return cLessThanSignLessThanSignKeyword_3_0; }
		
		//staticParams+=StaticParam
		public Assignment getStaticParamsAssignment_3_1() { return cStaticParamsAssignment_3_1; }
		
		//StaticParam
		public RuleCall getStaticParamsStaticParamParserRuleCall_3_1_0() { return cStaticParamsStaticParamParserRuleCall_3_1_0; }
		
		//(';' staticParams+=StaticParam)*
		public Group getGroup_3_2() { return cGroup_3_2; }
		
		//';'
		public Keyword getSemicolonKeyword_3_2_0() { return cSemicolonKeyword_3_2_0; }
		
		//staticParams+=StaticParam
		public Assignment getStaticParamsAssignment_3_2_1() { return cStaticParamsAssignment_3_2_1; }
		
		//StaticParam
		public RuleCall getStaticParamsStaticParamParserRuleCall_3_2_1_0() { return cStaticParamsStaticParamParserRuleCall_3_2_1_0; }
		
		//'>>'
		public Keyword getGreaterThanSignGreaterThanSignKeyword_3_3() { return cGreaterThanSignGreaterThanSignKeyword_3_3; }
		
		//input=Params 'returns' output=Params ('=' effectiveNode=IdentRef ('<<' staticArgs+=StaticArg (';'
		//staticArgs+=StaticArg)* '>>')? | ';'? (constants+=ConstantsDeclaration | 'var' variables+=LustreClockedIdDeclaration
		//(';' variables+=LustreClockedIdDeclaration)* ';')* // Body 
		//'let' (equations+=Equation | assertions+=Assertion | automatons+=Automaton)* 'tel' ('.' | ';'?)) | // --- Effective Node (without interface)
		//'=' effectiveNode=IdentRef ('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//input=Params 'returns' output=Params ('=' effectiveNode=IdentRef ('<<' staticArgs+=StaticArg (';'
		//staticArgs+=StaticArg)* '>>')? | ';'? (constants+=ConstantsDeclaration | 'var' variables+=LustreClockedIdDeclaration
		//(';' variables+=LustreClockedIdDeclaration)* ';')* // Body 
		//'let' (equations+=Equation | assertions+=Assertion | automatons+=Automaton)* 'tel' ('.' | ';'?))
		public Group getGroup_4_0() { return cGroup_4_0; }
		
		//input=Params
		public Assignment getInputAssignment_4_0_0() { return cInputAssignment_4_0_0; }
		
		//Params
		public RuleCall getInputParamsParserRuleCall_4_0_0_0() { return cInputParamsParserRuleCall_4_0_0_0; }
		
		//'returns'
		public Keyword getReturnsKeyword_4_0_1() { return cReturnsKeyword_4_0_1; }
		
		//output=Params
		public Assignment getOutputAssignment_4_0_2() { return cOutputAssignment_4_0_2; }
		
		//Params
		public RuleCall getOutputParamsParserRuleCall_4_0_2_0() { return cOutputParamsParserRuleCall_4_0_2_0; }
		
		//'=' effectiveNode=IdentRef ('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')? | ';'?
		//(constants+=ConstantsDeclaration | 'var' variables+=LustreClockedIdDeclaration (';'
		//variables+=LustreClockedIdDeclaration)* ';')* // Body 
		//'let' (equations+=Equation | assertions+=Assertion | automatons+=Automaton)* 'tel' ('.' | ';'?)
		public Alternatives getAlternatives_4_0_3() { return cAlternatives_4_0_3; }
		
		//// --- Effective Node (with interface)
		//'=' effectiveNode=IdentRef ('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?
		public Group getGroup_4_0_3_0() { return cGroup_4_0_3_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_4_0_3_0_0() { return cEqualsSignKeyword_4_0_3_0_0; }
		
		//effectiveNode=IdentRef
		public Assignment getEffectiveNodeAssignment_4_0_3_0_1() { return cEffectiveNodeAssignment_4_0_3_0_1; }
		
		//IdentRef
		public RuleCall getEffectiveNodeIdentRefParserRuleCall_4_0_3_0_1_0() { return cEffectiveNodeIdentRefParserRuleCall_4_0_3_0_1_0; }
		
		//('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?
		public Group getGroup_4_0_3_0_2() { return cGroup_4_0_3_0_2; }
		
		//'<<'
		public Keyword getLessThanSignLessThanSignKeyword_4_0_3_0_2_0() { return cLessThanSignLessThanSignKeyword_4_0_3_0_2_0; }
		
		//staticArgs+=StaticArg
		public Assignment getStaticArgsAssignment_4_0_3_0_2_1() { return cStaticArgsAssignment_4_0_3_0_2_1; }
		
		//StaticArg
		public RuleCall getStaticArgsStaticArgParserRuleCall_4_0_3_0_2_1_0() { return cStaticArgsStaticArgParserRuleCall_4_0_3_0_2_1_0; }
		
		//(';' staticArgs+=StaticArg)*
		public Group getGroup_4_0_3_0_2_2() { return cGroup_4_0_3_0_2_2; }
		
		//';'
		public Keyword getSemicolonKeyword_4_0_3_0_2_2_0() { return cSemicolonKeyword_4_0_3_0_2_2_0; }
		
		//staticArgs+=StaticArg
		public Assignment getStaticArgsAssignment_4_0_3_0_2_2_1() { return cStaticArgsAssignment_4_0_3_0_2_2_1; }
		
		//StaticArg
		public RuleCall getStaticArgsStaticArgParserRuleCall_4_0_3_0_2_2_1_0() { return cStaticArgsStaticArgParserRuleCall_4_0_3_0_2_2_1_0; }
		
		//'>>'
		public Keyword getGreaterThanSignGreaterThanSignKeyword_4_0_3_0_2_3() { return cGreaterThanSignGreaterThanSignKeyword_4_0_3_0_2_3; }
		
		//// Regular Body
		//';'? (constants+=ConstantsDeclaration | 'var' variables+=LustreClockedIdDeclaration (';'
		//variables+=LustreClockedIdDeclaration)* ';')* // Body 
		//'let' (equations+=Equation | assertions+=Assertion | automatons+=Automaton)* 'tel' ('.' | ';'?)
		public Group getGroup_4_0_3_1() { return cGroup_4_0_3_1; }
		
		//';'?
		public Keyword getSemicolonKeyword_4_0_3_1_0() { return cSemicolonKeyword_4_0_3_1_0; }
		
		//(constants+=ConstantsDeclaration | 'var' variables+=LustreClockedIdDeclaration (';'
		//variables+=LustreClockedIdDeclaration)* ';')*
		public Alternatives getAlternatives_4_0_3_1_1() { return cAlternatives_4_0_3_1_1; }
		
		//constants+=ConstantsDeclaration
		public Assignment getConstantsAssignment_4_0_3_1_1_0() { return cConstantsAssignment_4_0_3_1_1_0; }
		
		//ConstantsDeclaration
		public RuleCall getConstantsConstantsDeclarationParserRuleCall_4_0_3_1_1_0_0() { return cConstantsConstantsDeclarationParserRuleCall_4_0_3_1_1_0_0; }
		
		//'var' variables+=LustreClockedIdDeclaration (';' variables+=LustreClockedIdDeclaration)* ';'
		public Group getGroup_4_0_3_1_1_1() { return cGroup_4_0_3_1_1_1; }
		
		//'var'
		public Keyword getVarKeyword_4_0_3_1_1_1_0() { return cVarKeyword_4_0_3_1_1_1_0; }
		
		//variables+=LustreClockedIdDeclaration
		public Assignment getVariablesAssignment_4_0_3_1_1_1_1() { return cVariablesAssignment_4_0_3_1_1_1_1; }
		
		//LustreClockedIdDeclaration
		public RuleCall getVariablesLustreClockedIdDeclarationParserRuleCall_4_0_3_1_1_1_1_0() { return cVariablesLustreClockedIdDeclarationParserRuleCall_4_0_3_1_1_1_1_0; }
		
		//(';' variables+=LustreClockedIdDeclaration)*
		public Group getGroup_4_0_3_1_1_1_2() { return cGroup_4_0_3_1_1_1_2; }
		
		//';'
		public Keyword getSemicolonKeyword_4_0_3_1_1_1_2_0() { return cSemicolonKeyword_4_0_3_1_1_1_2_0; }
		
		//variables+=LustreClockedIdDeclaration
		public Assignment getVariablesAssignment_4_0_3_1_1_1_2_1() { return cVariablesAssignment_4_0_3_1_1_1_2_1; }
		
		//LustreClockedIdDeclaration
		public RuleCall getVariablesLustreClockedIdDeclarationParserRuleCall_4_0_3_1_1_1_2_1_0() { return cVariablesLustreClockedIdDeclarationParserRuleCall_4_0_3_1_1_1_2_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_4_0_3_1_1_1_3() { return cSemicolonKeyword_4_0_3_1_1_1_3; }
		
		//// Body 
		//'let'
		public Keyword getLetKeyword_4_0_3_1_2() { return cLetKeyword_4_0_3_1_2; }
		
		//(equations+=Equation | assertions+=Assertion | automatons+=Automaton)*
		public Alternatives getAlternatives_4_0_3_1_3() { return cAlternatives_4_0_3_1_3; }
		
		//equations+=Equation
		public Assignment getEquationsAssignment_4_0_3_1_3_0() { return cEquationsAssignment_4_0_3_1_3_0; }
		
		//Equation
		public RuleCall getEquationsEquationParserRuleCall_4_0_3_1_3_0_0() { return cEquationsEquationParserRuleCall_4_0_3_1_3_0_0; }
		
		//assertions+=Assertion
		public Assignment getAssertionsAssignment_4_0_3_1_3_1() { return cAssertionsAssignment_4_0_3_1_3_1; }
		
		//Assertion
		public RuleCall getAssertionsAssertionParserRuleCall_4_0_3_1_3_1_0() { return cAssertionsAssertionParserRuleCall_4_0_3_1_3_1_0; }
		
		//automatons+=Automaton
		public Assignment getAutomatonsAssignment_4_0_3_1_3_2() { return cAutomatonsAssignment_4_0_3_1_3_2; }
		
		//Automaton
		public RuleCall getAutomatonsAutomatonParserRuleCall_4_0_3_1_3_2_0() { return cAutomatonsAutomatonParserRuleCall_4_0_3_1_3_2_0; }
		
		//'tel'
		public Keyword getTelKeyword_4_0_3_1_4() { return cTelKeyword_4_0_3_1_4; }
		
		//'.' | ';'?
		public Alternatives getAlternatives_4_0_3_1_5() { return cAlternatives_4_0_3_1_5; }
		
		//'.'
		public Keyword getFullStopKeyword_4_0_3_1_5_0() { return cFullStopKeyword_4_0_3_1_5_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_4_0_3_1_5_1() { return cSemicolonKeyword_4_0_3_1_5_1; }
		
		//'=' effectiveNode=IdentRef ('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?
		public Group getGroup_4_1() { return cGroup_4_1; }
		
		//// --- Effective Node (without interface)
		//'='
		public Keyword getEqualsSignKeyword_4_1_0() { return cEqualsSignKeyword_4_1_0; }
		
		//effectiveNode=IdentRef
		public Assignment getEffectiveNodeAssignment_4_1_1() { return cEffectiveNodeAssignment_4_1_1; }
		
		//IdentRef
		public RuleCall getEffectiveNodeIdentRefParserRuleCall_4_1_1_0() { return cEffectiveNodeIdentRefParserRuleCall_4_1_1_0; }
		
		//('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?
		public Group getGroup_4_1_2() { return cGroup_4_1_2; }
		
		//'<<'
		public Keyword getLessThanSignLessThanSignKeyword_4_1_2_0() { return cLessThanSignLessThanSignKeyword_4_1_2_0; }
		
		//staticArgs+=StaticArg
		public Assignment getStaticArgsAssignment_4_1_2_1() { return cStaticArgsAssignment_4_1_2_1; }
		
		//StaticArg
		public RuleCall getStaticArgsStaticArgParserRuleCall_4_1_2_1_0() { return cStaticArgsStaticArgParserRuleCall_4_1_2_1_0; }
		
		//(';' staticArgs+=StaticArg)*
		public Group getGroup_4_1_2_2() { return cGroup_4_1_2_2; }
		
		//';'
		public Keyword getSemicolonKeyword_4_1_2_2_0() { return cSemicolonKeyword_4_1_2_2_0; }
		
		//staticArgs+=StaticArg
		public Assignment getStaticArgsAssignment_4_1_2_2_1() { return cStaticArgsAssignment_4_1_2_2_1; }
		
		//StaticArg
		public RuleCall getStaticArgsStaticArgParserRuleCall_4_1_2_2_1_0() { return cStaticArgsStaticArgParserRuleCall_4_1_2_2_1_0; }
		
		//'>>'
		public Keyword getGreaterThanSignGreaterThanSignKeyword_4_1_2_3() { return cGreaterThanSignGreaterThanSignKeyword_4_1_2_3; }
	}
	public class ParamsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Params");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParamsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameterAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameterLustreClockedIdDeclarationParserRuleCall_2_0_0 = (RuleCall)cParameterAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cSemicolonKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameterAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameterLustreClockedIdDeclarationParserRuleCall_2_1_1_0 = (RuleCall)cParameterAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Params:
		//	{Params}
		//	'(' (parameter+=LustreClockedIdDeclaration (';' parameter+=LustreClockedIdDeclaration)*)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{Params} '(' (parameter+=LustreClockedIdDeclaration (';' parameter+=LustreClockedIdDeclaration)*)? ')'
		public Group getGroup() { return cGroup; }
		
		//{Params}
		public Action getParamsAction_0() { return cParamsAction_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(parameter+=LustreClockedIdDeclaration (';' parameter+=LustreClockedIdDeclaration)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//parameter+=LustreClockedIdDeclaration
		public Assignment getParameterAssignment_2_0() { return cParameterAssignment_2_0; }
		
		//LustreClockedIdDeclaration
		public RuleCall getParameterLustreClockedIdDeclarationParserRuleCall_2_0_0() { return cParameterLustreClockedIdDeclarationParserRuleCall_2_0_0; }
		
		//(';' parameter+=LustreClockedIdDeclaration)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2_1_0() { return cSemicolonKeyword_2_1_0; }
		
		//parameter+=LustreClockedIdDeclaration
		public Assignment getParameterAssignment_2_1_1() { return cParameterAssignment_2_1_1; }
		
		//LustreClockedIdDeclaration
		public RuleCall getParameterLustreClockedIdDeclarationParserRuleCall_2_1_1_0() { return cParameterLustreClockedIdDeclarationParserRuleCall_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class StaticParamElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.StaticParam");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTypeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cConstKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cTypeAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_1_3_0 = (RuleCall)cTypeAssignment_1_3.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cUnsafeKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Keyword cNodeKeyword_2_1_0 = (Keyword)cAlternatives_2_1.eContents().get(0);
		private final Keyword cFunctionKeyword_2_1_1 = (Keyword)cAlternatives_2_1.eContents().get(1);
		private final Assignment cNameAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cNameIDENTTerminalRuleCall_2_2_0 = (RuleCall)cNameAssignment_2_2.eContents().get(0);
		private final Assignment cNodeInputAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cNodeInputParamsParserRuleCall_2_3_0 = (RuleCall)cNodeInputAssignment_2_3.eContents().get(0);
		private final Keyword cReturnsKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Assignment cNodeOutputAssignment_2_5 = (Assignment)cGroup_2.eContents().get(5);
		private final RuleCall cNodeOutputParamsParserRuleCall_2_5_0 = (RuleCall)cNodeOutputAssignment_2_5.eContents().get(0);
		
		//StaticParam:
		//	'type' name=IDENT
		//	| 'const' name=IDENT ':' type=Type
		//	| 'unsafe'? ('node' | 'function') name=IDENT nodeInput=Params 'returns' nodeOutput=Params;
		@Override public ParserRule getRule() { return rule; }
		
		//'type' name=IDENT | 'const' name=IDENT ':' type=Type | 'unsafe'? ('node' | 'function') name=IDENT nodeInput=Params
		//'returns' nodeOutput=Params
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'type' name=IDENT
		public Group getGroup_0() { return cGroup_0; }
		
		//'type'
		public Keyword getTypeKeyword_0_0() { return cTypeKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//'const' name=IDENT ':' type=Type
		public Group getGroup_1() { return cGroup_1; }
		
		//'const'
		public Keyword getConstKeyword_1_0() { return cConstKeyword_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_1_0() { return cNameIDENTTerminalRuleCall_1_1_0; }
		
		//':'
		public Keyword getColonKeyword_1_2() { return cColonKeyword_1_2; }
		
		//type=Type
		public Assignment getTypeAssignment_1_3() { return cTypeAssignment_1_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_1_3_0() { return cTypeTypeParserRuleCall_1_3_0; }
		
		//'unsafe'? ('node' | 'function') name=IDENT nodeInput=Params 'returns' nodeOutput=Params
		public Group getGroup_2() { return cGroup_2; }
		
		//'unsafe'?
		public Keyword getUnsafeKeyword_2_0() { return cUnsafeKeyword_2_0; }
		
		//'node' | 'function'
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }
		
		//'node'
		public Keyword getNodeKeyword_2_1_0() { return cNodeKeyword_2_1_0; }
		
		//'function'
		public Keyword getFunctionKeyword_2_1_1() { return cFunctionKeyword_2_1_1; }
		
		//name=IDENT
		public Assignment getNameAssignment_2_2() { return cNameAssignment_2_2; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_2_2_0() { return cNameIDENTTerminalRuleCall_2_2_0; }
		
		//nodeInput=Params
		public Assignment getNodeInputAssignment_2_3() { return cNodeInputAssignment_2_3; }
		
		//Params
		public RuleCall getNodeInputParamsParserRuleCall_2_3_0() { return cNodeInputParamsParserRuleCall_2_3_0; }
		
		//'returns'
		public Keyword getReturnsKeyword_2_4() { return cReturnsKeyword_2_4; }
		
		//nodeOutput=Params
		public Assignment getNodeOutputAssignment_2_5() { return cNodeOutputAssignment_2_5; }
		
		//Params
		public RuleCall getNodeOutputParamsParserRuleCall_2_5_0() { return cNodeOutputParamsParserRuleCall_2_5_0; }
	}
	public class StaticArgElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.StaticArg");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTypeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_0_1_0 = (RuleCall)cTypeAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cConstKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExprAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExprLustreExpressionParserRuleCall_1_1_0 = (RuleCall)cExprAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Keyword cNodeKeyword_2_0_0 = (Keyword)cAlternatives_2_0.eContents().get(0);
		private final Keyword cFunctionKeyword_2_0_1 = (Keyword)cAlternatives_2_0.eContents().get(1);
		private final Assignment cNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNameIdentRefParserRuleCall_2_1_0 = (RuleCall)cNameAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cLessThanSignLessThanSignKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cStaticArgsAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cStaticArgsStaticArgParserRuleCall_2_2_1_0 = (RuleCall)cStaticArgsAssignment_2_2_1.eContents().get(0);
		private final Group cGroup_2_2_2 = (Group)cGroup_2_2.eContents().get(2);
		private final Alternatives cAlternatives_2_2_2_0 = (Alternatives)cGroup_2_2_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_2_2_0_0 = (Keyword)cAlternatives_2_2_2_0.eContents().get(0);
		private final Keyword cCommaKeyword_2_2_2_0_1 = (Keyword)cAlternatives_2_2_2_0.eContents().get(1);
		private final Assignment cStaticArgsAssignment_2_2_2_1 = (Assignment)cGroup_2_2_2.eContents().get(1);
		private final RuleCall cStaticArgsStaticArgParserRuleCall_2_2_2_1_0 = (RuleCall)cStaticArgsAssignment_2_2_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_2_2_3 = (Keyword)cGroup_2_2.eContents().get(3);
		
		//StaticArg:
		//	'type' type=Type
		//	| 'const' expr=LustreExpression
		//	| ('node' | 'function') name=IdentRef ('<<' staticArgs+=StaticArg ((';' | ',') staticArgs+=StaticArg)* '>>')?
		//	//    | PredefOp
		//	//    | SimpleExpr
		//	//    | SurelyType
		//	//    | SurelyNode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'type' type=Type | 'const' expr=LustreExpression | ('node' | 'function') name=IdentRef ('<<' staticArgs+=StaticArg ((';'
		//| ',') staticArgs+=StaticArg)* '>>')?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'type' type=Type
		public Group getGroup_0() { return cGroup_0; }
		
		//'type'
		public Keyword getTypeKeyword_0_0() { return cTypeKeyword_0_0; }
		
		//type=Type
		public Assignment getTypeAssignment_0_1() { return cTypeAssignment_0_1; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_0_1_0() { return cTypeTypeParserRuleCall_0_1_0; }
		
		//'const' expr=LustreExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//'const'
		public Keyword getConstKeyword_1_0() { return cConstKeyword_1_0; }
		
		//expr=LustreExpression
		public Assignment getExprAssignment_1_1() { return cExprAssignment_1_1; }
		
		//LustreExpression
		public RuleCall getExprLustreExpressionParserRuleCall_1_1_0() { return cExprLustreExpressionParserRuleCall_1_1_0; }
		
		//('node' | 'function') name=IdentRef ('<<' staticArgs+=StaticArg ((';' | ',') staticArgs+=StaticArg)* '>>')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'node' | 'function'
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }
		
		//'node'
		public Keyword getNodeKeyword_2_0_0() { return cNodeKeyword_2_0_0; }
		
		//'function'
		public Keyword getFunctionKeyword_2_0_1() { return cFunctionKeyword_2_0_1; }
		
		//name=IdentRef
		public Assignment getNameAssignment_2_1() { return cNameAssignment_2_1; }
		
		//IdentRef
		public RuleCall getNameIdentRefParserRuleCall_2_1_0() { return cNameIdentRefParserRuleCall_2_1_0; }
		
		//('<<' staticArgs+=StaticArg ((';' | ',') staticArgs+=StaticArg)* '>>')?
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//'<<'
		public Keyword getLessThanSignLessThanSignKeyword_2_2_0() { return cLessThanSignLessThanSignKeyword_2_2_0; }
		
		//staticArgs+=StaticArg
		public Assignment getStaticArgsAssignment_2_2_1() { return cStaticArgsAssignment_2_2_1; }
		
		//StaticArg
		public RuleCall getStaticArgsStaticArgParserRuleCall_2_2_1_0() { return cStaticArgsStaticArgParserRuleCall_2_2_1_0; }
		
		//((';' | ',') staticArgs+=StaticArg)*
		public Group getGroup_2_2_2() { return cGroup_2_2_2; }
		
		//';' | ','
		public Alternatives getAlternatives_2_2_2_0() { return cAlternatives_2_2_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_2_2_0_0() { return cSemicolonKeyword_2_2_2_0_0; }
		
		//','
		public Keyword getCommaKeyword_2_2_2_0_1() { return cCommaKeyword_2_2_2_0_1; }
		
		//staticArgs+=StaticArg
		public Assignment getStaticArgsAssignment_2_2_2_1() { return cStaticArgsAssignment_2_2_2_1; }
		
		//StaticArg
		public RuleCall getStaticArgsStaticArgParserRuleCall_2_2_2_1_0() { return cStaticArgsStaticArgParserRuleCall_2_2_2_1_0; }
		
		//'>>'
		public Keyword getGreaterThanSignGreaterThanSignKeyword_2_2_3() { return cGreaterThanSignGreaterThanSignKeyword_2_2_3; }
	}
	public class ByNameStaticArgElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ByNameStaticArg");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTypeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cTypeAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_0_3_0 = (RuleCall)cTypeAssignment_0_3.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cConstKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cExprAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cExprLustreExpressionParserRuleCall_1_3_0 = (RuleCall)cExprAssignment_1_3.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Keyword cFunctionKeyword_2_0_0 = (Keyword)cAlternatives_2_0.eContents().get(0);
		private final Keyword cNodeKeyword_2_0_1 = (Keyword)cAlternatives_2_0.eContents().get(1);
		private final Assignment cNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_2_1_0 = (RuleCall)cNameAssignment_2_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cNodeRefAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cNodeRefIdentRefParserRuleCall_2_3_0 = (RuleCall)cNodeRefAssignment_2_3.eContents().get(0);
		private final Group cGroup_2_4 = (Group)cGroup_2.eContents().get(4);
		private final Keyword cLessThanSignLessThanSignKeyword_2_4_0 = (Keyword)cGroup_2_4.eContents().get(0);
		private final Assignment cStaticArgsAssignment_2_4_1 = (Assignment)cGroup_2_4.eContents().get(1);
		private final RuleCall cStaticArgsStaticArgParserRuleCall_2_4_1_0 = (RuleCall)cStaticArgsAssignment_2_4_1.eContents().get(0);
		private final Group cGroup_2_4_2 = (Group)cGroup_2_4.eContents().get(2);
		private final Alternatives cAlternatives_2_4_2_0 = (Alternatives)cGroup_2_4_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_4_2_0_0 = (Keyword)cAlternatives_2_4_2_0.eContents().get(0);
		private final Keyword cCommaKeyword_2_4_2_0_1 = (Keyword)cAlternatives_2_4_2_0.eContents().get(1);
		private final Assignment cStaticArgsAssignment_2_4_2_1 = (Assignment)cGroup_2_4_2.eContents().get(1);
		private final RuleCall cStaticArgsStaticArgParserRuleCall_2_4_2_1_0 = (RuleCall)cStaticArgsAssignment_2_4_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_2_4_3 = (Keyword)cGroup_2_4.eContents().get(3);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cNameAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_3_0_0 = (RuleCall)cNameAssignment_3_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//ByNameStaticArg:
		//	'type' name=IDENT '=' type=Type | 'const' name=IDENT '=' expr=LustreExpression | ('function' | 'node') name=IDENT '='
		//	nodeRef=IdentRef ('<<' staticArgs+=StaticArg ((';' | ',') staticArgs+=StaticArg)* '>>')? | name=IDENT '=';
		@Override public ParserRule getRule() { return rule; }
		
		//'type' name=IDENT '=' type=Type | 'const' name=IDENT '=' expr=LustreExpression | ('function' | 'node') name=IDENT '='
		//nodeRef=IdentRef ('<<' staticArgs+=StaticArg ((';' | ',') staticArgs+=StaticArg)* '>>')? | name=IDENT '='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'type' name=IDENT '=' type=Type
		public Group getGroup_0() { return cGroup_0; }
		
		//'type'
		public Keyword getTypeKeyword_0_0() { return cTypeKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_2() { return cEqualsSignKeyword_0_2; }
		
		//type=Type
		public Assignment getTypeAssignment_0_3() { return cTypeAssignment_0_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_0_3_0() { return cTypeTypeParserRuleCall_0_3_0; }
		
		//'const' name=IDENT '=' expr=LustreExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//'const'
		public Keyword getConstKeyword_1_0() { return cConstKeyword_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_1_0() { return cNameIDENTTerminalRuleCall_1_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_2() { return cEqualsSignKeyword_1_2; }
		
		//expr=LustreExpression
		public Assignment getExprAssignment_1_3() { return cExprAssignment_1_3; }
		
		//LustreExpression
		public RuleCall getExprLustreExpressionParserRuleCall_1_3_0() { return cExprLustreExpressionParserRuleCall_1_3_0; }
		
		//('function' | 'node') name=IDENT '=' nodeRef=IdentRef ('<<' staticArgs+=StaticArg ((';' | ',') staticArgs+=StaticArg)*
		//'>>')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'function' | 'node'
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }
		
		//'function'
		public Keyword getFunctionKeyword_2_0_0() { return cFunctionKeyword_2_0_0; }
		
		//'node'
		public Keyword getNodeKeyword_2_0_1() { return cNodeKeyword_2_0_1; }
		
		//name=IDENT
		public Assignment getNameAssignment_2_1() { return cNameAssignment_2_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_2_1_0() { return cNameIDENTTerminalRuleCall_2_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_2() { return cEqualsSignKeyword_2_2; }
		
		//nodeRef=IdentRef
		public Assignment getNodeRefAssignment_2_3() { return cNodeRefAssignment_2_3; }
		
		//IdentRef
		public RuleCall getNodeRefIdentRefParserRuleCall_2_3_0() { return cNodeRefIdentRefParserRuleCall_2_3_0; }
		
		//('<<' staticArgs+=StaticArg ((';' | ',') staticArgs+=StaticArg)* '>>')?
		public Group getGroup_2_4() { return cGroup_2_4; }
		
		//'<<'
		public Keyword getLessThanSignLessThanSignKeyword_2_4_0() { return cLessThanSignLessThanSignKeyword_2_4_0; }
		
		//staticArgs+=StaticArg
		public Assignment getStaticArgsAssignment_2_4_1() { return cStaticArgsAssignment_2_4_1; }
		
		//StaticArg
		public RuleCall getStaticArgsStaticArgParserRuleCall_2_4_1_0() { return cStaticArgsStaticArgParserRuleCall_2_4_1_0; }
		
		//((';' | ',') staticArgs+=StaticArg)*
		public Group getGroup_2_4_2() { return cGroup_2_4_2; }
		
		//';' | ','
		public Alternatives getAlternatives_2_4_2_0() { return cAlternatives_2_4_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_4_2_0_0() { return cSemicolonKeyword_2_4_2_0_0; }
		
		//','
		public Keyword getCommaKeyword_2_4_2_0_1() { return cCommaKeyword_2_4_2_0_1; }
		
		//staticArgs+=StaticArg
		public Assignment getStaticArgsAssignment_2_4_2_1() { return cStaticArgsAssignment_2_4_2_1; }
		
		//StaticArg
		public RuleCall getStaticArgsStaticArgParserRuleCall_2_4_2_1_0() { return cStaticArgsStaticArgParserRuleCall_2_4_2_1_0; }
		
		//'>>'
		public Keyword getGreaterThanSignGreaterThanSignKeyword_2_4_3() { return cGreaterThanSignGreaterThanSignKeyword_2_4_3; }
		
		//name=IDENT '='
		public Group getGroup_3() { return cGroup_3; }
		
		//name=IDENT
		public Assignment getNameAssignment_3_0() { return cNameAssignment_3_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_3_0_0() { return cNameIDENTTerminalRuleCall_3_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_3_1() { return cEqualsSignKeyword_3_1; }
	}
	public class LustreTypedIdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LustreTypedId");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableNamesIDENTTerminalRuleCall_0_0 = (RuleCall)cVariableNamesAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVariableNamesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVariableNamesIDENTTerminalRuleCall_1_1_0 = (RuleCall)cVariableNamesAssignment_1_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//// --------------------------
		//LustreTypedId:
		//	variableNames+=IDENT (',' variableNames+=IDENT)* ':' type=Type;
		@Override public ParserRule getRule() { return rule; }
		
		//variableNames+=IDENT (',' variableNames+=IDENT)* ':' type=Type
		public Group getGroup() { return cGroup; }
		
		//variableNames+=IDENT
		public Assignment getVariableNamesAssignment_0() { return cVariableNamesAssignment_0; }
		
		//IDENT
		public RuleCall getVariableNamesIDENTTerminalRuleCall_0_0() { return cVariableNamesIDENTTerminalRuleCall_0_0; }
		
		//(',' variableNames+=IDENT)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//variableNames+=IDENT
		public Assignment getVariableNamesAssignment_1_1() { return cVariableNamesAssignment_1_1; }
		
		//IDENT
		public RuleCall getVariableNamesIDENTTerminalRuleCall_1_1_0() { return cVariableNamesIDENTTerminalRuleCall_1_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//type=Type
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_3_0() { return cTypeTypeParserRuleCall_3_0; }
	}
	public class LustreTypedValuedIdsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LustreTypedValuedIds");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableNamesAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableNamesIDENTTerminalRuleCall_0_0 = (RuleCall)cVariableNamesAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cGroup_1_0.eContents().get(0);
		private final Keyword cCommaKeyword_1_0_0_0 = (Keyword)cGroup_1_0_0.eContents().get(0);
		private final Assignment cVariableNamesAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cVariableNamesIDENTTerminalRuleCall_1_0_0_1_0 = (RuleCall)cVariableNamesAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cColonKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cTypeAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_1_0_2_0 = (RuleCall)cTypeAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_0_3 = (Group)cGroup_1_0.eContents().get(3);
		private final Keyword cEqualsSignKeyword_1_0_3_0 = (Keyword)cGroup_1_0_3.eContents().get(0);
		private final Assignment cValueAssignment_1_0_3_1 = (Assignment)cGroup_1_0_3.eContents().get(1);
		private final RuleCall cValueLustreExpressionParserRuleCall_1_0_3_1_0 = (RuleCall)cValueAssignment_1_0_3_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cValueLustreExpressionParserRuleCall_1_1_1_0 = (RuleCall)cValueAssignment_1_1_1.eContents().get(0);
		
		//LustreTypedValuedIds:
		//	variableNames+=IDENT ((',' variableNames+=IDENT)* ':' type=Type? ('=' value=LustreExpression)? | '='
		//	value=LustreExpression);
		@Override public ParserRule getRule() { return rule; }
		
		//variableNames+=IDENT ((',' variableNames+=IDENT)* ':' type=Type? ('=' value=LustreExpression)? | '='
		//value=LustreExpression)
		public Group getGroup() { return cGroup; }
		
		//variableNames+=IDENT
		public Assignment getVariableNamesAssignment_0() { return cVariableNamesAssignment_0; }
		
		//IDENT
		public RuleCall getVariableNamesIDENTTerminalRuleCall_0_0() { return cVariableNamesIDENTTerminalRuleCall_0_0; }
		
		//(',' variableNames+=IDENT)* ':' type=Type? ('=' value=LustreExpression)? | '=' value=LustreExpression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//(',' variableNames+=IDENT)* ':' type=Type? ('=' value=LustreExpression)?
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//(',' variableNames+=IDENT)*
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//','
		public Keyword getCommaKeyword_1_0_0_0() { return cCommaKeyword_1_0_0_0; }
		
		//variableNames+=IDENT
		public Assignment getVariableNamesAssignment_1_0_0_1() { return cVariableNamesAssignment_1_0_0_1; }
		
		//IDENT
		public RuleCall getVariableNamesIDENTTerminalRuleCall_1_0_0_1_0() { return cVariableNamesIDENTTerminalRuleCall_1_0_0_1_0; }
		
		//':'
		public Keyword getColonKeyword_1_0_1() { return cColonKeyword_1_0_1; }
		
		//type=Type?
		public Assignment getTypeAssignment_1_0_2() { return cTypeAssignment_1_0_2; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_1_0_2_0() { return cTypeTypeParserRuleCall_1_0_2_0; }
		
		//('=' value=LustreExpression)?
		public Group getGroup_1_0_3() { return cGroup_1_0_3; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_0_3_0() { return cEqualsSignKeyword_1_0_3_0; }
		
		//value=LustreExpression
		public Assignment getValueAssignment_1_0_3_1() { return cValueAssignment_1_0_3_1; }
		
		//LustreExpression
		public RuleCall getValueLustreExpressionParserRuleCall_1_0_3_1_0() { return cValueLustreExpressionParserRuleCall_1_0_3_1_0; }
		
		//'=' value=LustreExpression
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_1_0() { return cEqualsSignKeyword_1_1_0; }
		
		//value=LustreExpression
		public Assignment getValueAssignment_1_1_1() { return cValueAssignment_1_1_1; }
		
		//LustreExpression
		public RuleCall getValueLustreExpressionParserRuleCall_1_1_1_0() { return cValueLustreExpressionParserRuleCall_1_1_1_0; }
	}
	public class LustreClockedIdDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LustreClockedIdDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cTypedIdsAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cTypedIdsLustreTypedIdParserRuleCall_0_0_0 = (RuleCall)cTypedIdsAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Keyword cWhenKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Assignment cClockExprAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cClockExprClockExpressionParserRuleCall_0_1_1_0 = (RuleCall)cClockExprAssignment_0_1_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypedIdsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypedIdsLustreTypedIdParserRuleCall_1_1_0 = (RuleCall)cTypedIdsAssignment_1_1.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword cSemicolonKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Assignment cTypedIdsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cTypedIdsLustreTypedIdParserRuleCall_1_2_1_0 = (RuleCall)cTypedIdsAssignment_1_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Keyword cWhenKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Assignment cClockExprAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cClockExprClockExpressionParserRuleCall_1_5_0 = (RuleCall)cClockExprAssignment_1_5.eContents().get(0);
		
		//LustreClockedIdDeclaration:
		//	typedIds+=LustreTypedId ('when' clockExpr=ClockExpression)? | '(' typedIds+=LustreTypedId (';'
		//	typedIds+=LustreTypedId)* ')' 'when' clockExpr=ClockExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//typedIds+=LustreTypedId ('when' clockExpr=ClockExpression)? | '(' typedIds+=LustreTypedId (';' typedIds+=LustreTypedId)*
		//')' 'when' clockExpr=ClockExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//typedIds+=LustreTypedId ('when' clockExpr=ClockExpression)?
		public Group getGroup_0() { return cGroup_0; }
		
		//typedIds+=LustreTypedId
		public Assignment getTypedIdsAssignment_0_0() { return cTypedIdsAssignment_0_0; }
		
		//LustreTypedId
		public RuleCall getTypedIdsLustreTypedIdParserRuleCall_0_0_0() { return cTypedIdsLustreTypedIdParserRuleCall_0_0_0; }
		
		//('when' clockExpr=ClockExpression)?
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//'when'
		public Keyword getWhenKeyword_0_1_0() { return cWhenKeyword_0_1_0; }
		
		//clockExpr=ClockExpression
		public Assignment getClockExprAssignment_0_1_1() { return cClockExprAssignment_0_1_1; }
		
		//ClockExpression
		public RuleCall getClockExprClockExpressionParserRuleCall_0_1_1_0() { return cClockExprClockExpressionParserRuleCall_0_1_1_0; }
		
		//'(' typedIds+=LustreTypedId (';' typedIds+=LustreTypedId)* ')' 'when' clockExpr=ClockExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//typedIds+=LustreTypedId
		public Assignment getTypedIdsAssignment_1_1() { return cTypedIdsAssignment_1_1; }
		
		//LustreTypedId
		public RuleCall getTypedIdsLustreTypedIdParserRuleCall_1_1_0() { return cTypedIdsLustreTypedIdParserRuleCall_1_1_0; }
		
		//(';' typedIds+=LustreTypedId)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//';'
		public Keyword getSemicolonKeyword_1_2_0() { return cSemicolonKeyword_1_2_0; }
		
		//typedIds+=LustreTypedId
		public Assignment getTypedIdsAssignment_1_2_1() { return cTypedIdsAssignment_1_2_1; }
		
		//LustreTypedId
		public RuleCall getTypedIdsLustreTypedIdParserRuleCall_1_2_1_0() { return cTypedIdsLustreTypedIdParserRuleCall_1_2_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
		
		//'when'
		public Keyword getWhenKeyword_1_4() { return cWhenKeyword_1_4; }
		
		//clockExpr=ClockExpression
		public Assignment getClockExprAssignment_1_5() { return cClockExprAssignment_1_5; }
		
		//ClockExpression
		public RuleCall getClockExprClockExpressionParserRuleCall_1_5_0() { return cClockExprClockExpressionParserRuleCall_1_5_0; }
	}
	public class LustreExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LustreExpression");
		private final RuleCall cExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LustreExpression:
		//	Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall() { return cExpressionParserRuleCall; }
	}
	public class ClockExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ClockExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cIdentRefParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final RuleCall cIDENTTerminalRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final RuleCall cIDENTTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cNotKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cIDENTTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Keyword cNotKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final RuleCall cIDENTTerminalRuleCall_3_3 = (RuleCall)cGroup_3.eContents().get(3);
		
		//ClockExpression:
		//	IdentRef '(' IDENT ')' | IDENT
		//	| 'not' IDENT
		//	| '(' 'not' ')' IDENT;
		@Override public ParserRule getRule() { return rule; }
		
		//IdentRef '(' IDENT ')' | IDENT | 'not' IDENT | '(' 'not' ')' IDENT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IdentRef '(' IDENT ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//IdentRef
		public RuleCall getIdentRefParserRuleCall_0_0() { return cIdentRefParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1() { return cLeftParenthesisKeyword_0_1; }
		
		//IDENT
		public RuleCall getIDENTTerminalRuleCall_0_2() { return cIDENTTerminalRuleCall_0_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_3() { return cRightParenthesisKeyword_0_3; }
		
		//IDENT
		public RuleCall getIDENTTerminalRuleCall_1() { return cIDENTTerminalRuleCall_1; }
		
		//'not' IDENT
		public Group getGroup_2() { return cGroup_2; }
		
		//'not'
		public Keyword getNotKeyword_2_0() { return cNotKeyword_2_0; }
		
		//IDENT
		public RuleCall getIDENTTerminalRuleCall_2_1() { return cIDENTTerminalRuleCall_2_1; }
		
		//'(' 'not' ')' IDENT
		public Group getGroup_3() { return cGroup_3; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }
		
		//'not'
		public Keyword getNotKeyword_3_1() { return cNotKeyword_3_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }
		
		//IDENT
		public RuleCall getIDENTTerminalRuleCall_3_3() { return cIDENTTerminalRuleCall_3_3; }
	}
	public class PackListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.PackList");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cModelDeclarationsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cModelDeclarationsModelDeclarationParserRuleCall_0_0 = (RuleCall)cModelDeclarationsAssignment_0.eContents().get(0);
		private final Assignment cPackageDeclarationsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cPackageDeclarationsPackageDeclarationParserRuleCall_1_0 = (RuleCall)cPackageDeclarationsAssignment_1.eContents().get(0);
		private final Assignment cPackageEquationsAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cPackageEquationsPackageEquationParserRuleCall_2_0 = (RuleCall)cPackageEquationsAssignment_2.eContents().get(0);
		
		///*
		// * ---------- PackList
		// */ PackList:
		//	(modelDeclarations+=ModelDeclaration
		//	| packageDeclarations+=PackageDeclaration
		//	| packageEquations+=PackageEquation)+;
		@Override public ParserRule getRule() { return rule; }
		
		//(modelDeclarations+=ModelDeclaration | packageDeclarations+=PackageDeclaration | packageEquations+=PackageEquation)+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//modelDeclarations+=ModelDeclaration
		public Assignment getModelDeclarationsAssignment_0() { return cModelDeclarationsAssignment_0; }
		
		//ModelDeclaration
		public RuleCall getModelDeclarationsModelDeclarationParserRuleCall_0_0() { return cModelDeclarationsModelDeclarationParserRuleCall_0_0; }
		
		//packageDeclarations+=PackageDeclaration
		public Assignment getPackageDeclarationsAssignment_1() { return cPackageDeclarationsAssignment_1; }
		
		//PackageDeclaration
		public RuleCall getPackageDeclarationsPackageDeclarationParserRuleCall_1_0() { return cPackageDeclarationsPackageDeclarationParserRuleCall_1_0; }
		
		//packageEquations+=PackageEquation
		public Assignment getPackageEquationsAssignment_2() { return cPackageEquationsAssignment_2; }
		
		//PackageEquation
		public RuleCall getPackageEquationsPackageEquationParserRuleCall_2_0() { return cPackageEquationsPackageEquationParserRuleCall_2_0; }
	}
	public class ModelDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ModelDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cUsesKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cUsesIdsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cUsesIdsIDENTTerminalRuleCall_2_1_0 = (RuleCall)cUsesIdsAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cUsesIdsAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cUsesIdsIDENTTerminalRuleCall_2_2_1_0 = (RuleCall)cUsesIdsAssignment_2_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Keyword cNeedsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNeedsParamsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNeedsParamsStaticParamParserRuleCall_4_0 = (RuleCall)cNeedsParamsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cSemicolonKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cNeedsParamsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cNeedsParamsStaticParamParserRuleCall_5_1_0 = (RuleCall)cNeedsParamsAssignment_5_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cProvidesKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cProvisionsAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cProvisionsProvideParserRuleCall_7_1_0 = (RuleCall)cProvisionsAssignment_7_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_7_2 = (Keyword)cGroup_7.eContents().get(2);
		private final Group cGroup_7_3 = (Group)cGroup_7.eContents().get(3);
		private final Assignment cProvisionsAssignment_7_3_0 = (Assignment)cGroup_7_3.eContents().get(0);
		private final RuleCall cProvisionsProvideParserRuleCall_7_3_0_0 = (RuleCall)cProvisionsAssignment_7_3_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_7_3_1 = (Keyword)cGroup_7_3.eContents().get(1);
		private final Keyword cBodyKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cBodyAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cBodyPackBodyParserRuleCall_9_0 = (RuleCall)cBodyAssignment_9.eContents().get(0);
		private final Keyword cEndKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//ModelDeclaration:
		//	'model' name=IDENT ('uses' usesIds+=IDENT (',' usesIds+=IDENT)* ';')?
		//	'needs' needsParams+=StaticParam (';' needsParams+=StaticParam)* ';' ('provides' provisions+=Provide ';'
		//	(provisions+=Provide ';')*)?
		//	'body'
		//	body=PackBody
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'model' name=IDENT ('uses' usesIds+=IDENT (',' usesIds+=IDENT)* ';')? 'needs' needsParams+=StaticParam (';'
		//needsParams+=StaticParam)* ';' ('provides' provisions+=Provide ';' (provisions+=Provide ';')*)? 'body' body=PackBody
		//'end'
		public Group getGroup() { return cGroup; }
		
		//'model'
		public Keyword getModelKeyword_0() { return cModelKeyword_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_0() { return cNameIDENTTerminalRuleCall_1_0; }
		
		//('uses' usesIds+=IDENT (',' usesIds+=IDENT)* ';')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'uses'
		public Keyword getUsesKeyword_2_0() { return cUsesKeyword_2_0; }
		
		//usesIds+=IDENT
		public Assignment getUsesIdsAssignment_2_1() { return cUsesIdsAssignment_2_1; }
		
		//IDENT
		public RuleCall getUsesIdsIDENTTerminalRuleCall_2_1_0() { return cUsesIdsIDENTTerminalRuleCall_2_1_0; }
		
		//(',' usesIds+=IDENT)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//','
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//usesIds+=IDENT
		public Assignment getUsesIdsAssignment_2_2_1() { return cUsesIdsAssignment_2_2_1; }
		
		//IDENT
		public RuleCall getUsesIdsIDENTTerminalRuleCall_2_2_1_0() { return cUsesIdsIDENTTerminalRuleCall_2_2_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_3() { return cSemicolonKeyword_2_3; }
		
		//'needs'
		public Keyword getNeedsKeyword_3() { return cNeedsKeyword_3; }
		
		//needsParams+=StaticParam
		public Assignment getNeedsParamsAssignment_4() { return cNeedsParamsAssignment_4; }
		
		//StaticParam
		public RuleCall getNeedsParamsStaticParamParserRuleCall_4_0() { return cNeedsParamsStaticParamParserRuleCall_4_0; }
		
		//(';' needsParams+=StaticParam)*
		public Group getGroup_5() { return cGroup_5; }
		
		//';'
		public Keyword getSemicolonKeyword_5_0() { return cSemicolonKeyword_5_0; }
		
		//needsParams+=StaticParam
		public Assignment getNeedsParamsAssignment_5_1() { return cNeedsParamsAssignment_5_1; }
		
		//StaticParam
		public RuleCall getNeedsParamsStaticParamParserRuleCall_5_1_0() { return cNeedsParamsStaticParamParserRuleCall_5_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_6() { return cSemicolonKeyword_6; }
		
		//('provides' provisions+=Provide ';' (provisions+=Provide ';')*)?
		public Group getGroup_7() { return cGroup_7; }
		
		//'provides'
		public Keyword getProvidesKeyword_7_0() { return cProvidesKeyword_7_0; }
		
		//provisions+=Provide
		public Assignment getProvisionsAssignment_7_1() { return cProvisionsAssignment_7_1; }
		
		//Provide
		public RuleCall getProvisionsProvideParserRuleCall_7_1_0() { return cProvisionsProvideParserRuleCall_7_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_7_2() { return cSemicolonKeyword_7_2; }
		
		//(provisions+=Provide ';')*
		public Group getGroup_7_3() { return cGroup_7_3; }
		
		//provisions+=Provide
		public Assignment getProvisionsAssignment_7_3_0() { return cProvisionsAssignment_7_3_0; }
		
		//Provide
		public RuleCall getProvisionsProvideParserRuleCall_7_3_0_0() { return cProvisionsProvideParserRuleCall_7_3_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_7_3_1() { return cSemicolonKeyword_7_3_1; }
		
		//'body'
		public Keyword getBodyKeyword_8() { return cBodyKeyword_8; }
		
		//body=PackBody
		public Assignment getBodyAssignment_9() { return cBodyAssignment_9; }
		
		//PackBody
		public RuleCall getBodyPackBodyParserRuleCall_9_0() { return cBodyPackBodyParserRuleCall_9_0; }
		
		//'end'
		public Keyword getEndKeyword_10() { return cEndKeyword_10; }
	}
	public class ProvideElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Provide");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cConstKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Keyword cColonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cTypeAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_0_3_0 = (RuleCall)cTypeAssignment_0_3.eContents().get(0);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cEqualsSignKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cValueAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cValueLustreExpressionParserRuleCall_0_4_1_0 = (RuleCall)cValueAssignment_0_4_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTypeKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTypesAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypesTypeDeclarationParserRuleCall_1_1_0 = (RuleCall)cTypesAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cUnsafeKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Keyword cNodeKeyword_2_1_0 = (Keyword)cAlternatives_2_1.eContents().get(0);
		private final Keyword cFunctionKeyword_2_1_1 = (Keyword)cAlternatives_2_1.eContents().get(1);
		private final Assignment cNameAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cNameIDENTTerminalRuleCall_2_2_0 = (RuleCall)cNameAssignment_2_2.eContents().get(0);
		private final Group cGroup_2_3 = (Group)cGroup_2.eContents().get(3);
		private final Keyword cLessThanSignLessThanSignKeyword_2_3_0 = (Keyword)cGroup_2_3.eContents().get(0);
		private final Assignment cStaticParamsAssignment_2_3_1 = (Assignment)cGroup_2_3.eContents().get(1);
		private final RuleCall cStaticParamsStaticParamParserRuleCall_2_3_1_0 = (RuleCall)cStaticParamsAssignment_2_3_1.eContents().get(0);
		private final Group cGroup_2_3_2 = (Group)cGroup_2_3.eContents().get(2);
		private final Keyword cSemicolonKeyword_2_3_2_0 = (Keyword)cGroup_2_3_2.eContents().get(0);
		private final Assignment cStaticParamsAssignment_2_3_2_1 = (Assignment)cGroup_2_3_2.eContents().get(1);
		private final RuleCall cStaticParamsStaticParamParserRuleCall_2_3_2_1_0 = (RuleCall)cStaticParamsAssignment_2_3_2_1.eContents().get(0);
		private final Keyword cGreaterThanSignGreaterThanSignKeyword_2_3_3 = (Keyword)cGroup_2_3.eContents().get(3);
		private final Assignment cInputAssignment_2_4 = (Assignment)cGroup_2.eContents().get(4);
		private final RuleCall cInputParamsParserRuleCall_2_4_0 = (RuleCall)cInputAssignment_2_4.eContents().get(0);
		private final Keyword cReturnsKeyword_2_5 = (Keyword)cGroup_2.eContents().get(5);
		private final Assignment cOutputAssignment_2_6 = (Assignment)cGroup_2.eContents().get(6);
		private final RuleCall cOutputParamsParserRuleCall_2_6_0 = (RuleCall)cOutputAssignment_2_6.eContents().get(0);
		
		//Provide:
		//	'const' name=IDENT ':' type=Type ('=' value=LustreExpression)?
		//	| 'type' types=TypeDeclaration
		//	| 'unsafe'? ('node' | 'function') name=IDENT ('<<' staticParams+=StaticParam (';' staticParams+=StaticParam)* '>>')?
		//	input=Params 'returns' output=Params;
		@Override public ParserRule getRule() { return rule; }
		
		//'const' name=IDENT ':' type=Type ('=' value=LustreExpression)? | 'type' types=TypeDeclaration | 'unsafe'? ('node' |
		//'function') name=IDENT ('<<' staticParams+=StaticParam (';' staticParams+=StaticParam)* '>>')? input=Params 'returns'
		//output=Params
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'const' name=IDENT ':' type=Type ('=' value=LustreExpression)?
		public Group getGroup_0() { return cGroup_0; }
		
		//'const'
		public Keyword getConstKeyword_0_0() { return cConstKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//':'
		public Keyword getColonKeyword_0_2() { return cColonKeyword_0_2; }
		
		//type=Type
		public Assignment getTypeAssignment_0_3() { return cTypeAssignment_0_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_0_3_0() { return cTypeTypeParserRuleCall_0_3_0; }
		
		//('=' value=LustreExpression)?
		public Group getGroup_0_4() { return cGroup_0_4; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_4_0() { return cEqualsSignKeyword_0_4_0; }
		
		//value=LustreExpression
		public Assignment getValueAssignment_0_4_1() { return cValueAssignment_0_4_1; }
		
		//LustreExpression
		public RuleCall getValueLustreExpressionParserRuleCall_0_4_1_0() { return cValueLustreExpressionParserRuleCall_0_4_1_0; }
		
		//'type' types=TypeDeclaration
		public Group getGroup_1() { return cGroup_1; }
		
		//'type'
		public Keyword getTypeKeyword_1_0() { return cTypeKeyword_1_0; }
		
		//types=TypeDeclaration
		public Assignment getTypesAssignment_1_1() { return cTypesAssignment_1_1; }
		
		//TypeDeclaration
		public RuleCall getTypesTypeDeclarationParserRuleCall_1_1_0() { return cTypesTypeDeclarationParserRuleCall_1_1_0; }
		
		//'unsafe'? ('node' | 'function') name=IDENT ('<<' staticParams+=StaticParam (';' staticParams+=StaticParam)* '>>')?
		//input=Params 'returns' output=Params
		public Group getGroup_2() { return cGroup_2; }
		
		//'unsafe'?
		public Keyword getUnsafeKeyword_2_0() { return cUnsafeKeyword_2_0; }
		
		//'node' | 'function'
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }
		
		//'node'
		public Keyword getNodeKeyword_2_1_0() { return cNodeKeyword_2_1_0; }
		
		//'function'
		public Keyword getFunctionKeyword_2_1_1() { return cFunctionKeyword_2_1_1; }
		
		//name=IDENT
		public Assignment getNameAssignment_2_2() { return cNameAssignment_2_2; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_2_2_0() { return cNameIDENTTerminalRuleCall_2_2_0; }
		
		//('<<' staticParams+=StaticParam (';' staticParams+=StaticParam)* '>>')?
		public Group getGroup_2_3() { return cGroup_2_3; }
		
		//'<<'
		public Keyword getLessThanSignLessThanSignKeyword_2_3_0() { return cLessThanSignLessThanSignKeyword_2_3_0; }
		
		//staticParams+=StaticParam
		public Assignment getStaticParamsAssignment_2_3_1() { return cStaticParamsAssignment_2_3_1; }
		
		//StaticParam
		public RuleCall getStaticParamsStaticParamParserRuleCall_2_3_1_0() { return cStaticParamsStaticParamParserRuleCall_2_3_1_0; }
		
		//(';' staticParams+=StaticParam)*
		public Group getGroup_2_3_2() { return cGroup_2_3_2; }
		
		//';'
		public Keyword getSemicolonKeyword_2_3_2_0() { return cSemicolonKeyword_2_3_2_0; }
		
		//staticParams+=StaticParam
		public Assignment getStaticParamsAssignment_2_3_2_1() { return cStaticParamsAssignment_2_3_2_1; }
		
		//StaticParam
		public RuleCall getStaticParamsStaticParamParserRuleCall_2_3_2_1_0() { return cStaticParamsStaticParamParserRuleCall_2_3_2_1_0; }
		
		//'>>'
		public Keyword getGreaterThanSignGreaterThanSignKeyword_2_3_3() { return cGreaterThanSignGreaterThanSignKeyword_2_3_3; }
		
		//input=Params
		public Assignment getInputAssignment_2_4() { return cInputAssignment_2_4; }
		
		//Params
		public RuleCall getInputParamsParserRuleCall_2_4_0() { return cInputParamsParserRuleCall_2_4_0; }
		
		//'returns'
		public Keyword getReturnsKeyword_2_5() { return cReturnsKeyword_2_5; }
		
		//output=Params
		public Assignment getOutputAssignment_2_6() { return cOutputAssignment_2_6; }
		
		//Params
		public RuleCall getOutputParamsParserRuleCall_2_6_0() { return cOutputParamsParserRuleCall_2_6_0; }
	}
	public class PackageDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.PackageDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cUsesKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cUsesIdsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cUsesIdsIDENTTerminalRuleCall_2_1_0 = (RuleCall)cUsesIdsAssignment_2_1.eContents().get(0);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cUsesIdsAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final RuleCall cUsesIdsIDENTTerminalRuleCall_2_2_1_0 = (RuleCall)cUsesIdsAssignment_2_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cProvidesKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cProvisionsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cProvisionsProvideParserRuleCall_3_1_0 = (RuleCall)cProvisionsAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Group cGroup_3_3 = (Group)cGroup_3.eContents().get(3);
		private final Assignment cProvisionsAssignment_3_3_0 = (Assignment)cGroup_3_3.eContents().get(0);
		private final RuleCall cProvisionsProvideParserRuleCall_3_3_0_0 = (RuleCall)cProvisionsAssignment_3_3_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_3_1 = (Keyword)cGroup_3_3.eContents().get(1);
		private final Keyword cBodyKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyPackBodyParserRuleCall_5_0 = (RuleCall)cBodyAssignment_5.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//PackageDeclaration:
		//	'package' name=IDENT ('uses' usesIds+=IDENT (',' usesIds+=IDENT)* ';')? ('provides' provisions+=Provide ';'
		//	(provisions+=Provide ';')*)?
		//	'body'
		//	body=PackBody
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//'package' name=IDENT ('uses' usesIds+=IDENT (',' usesIds+=IDENT)* ';')? ('provides' provisions+=Provide ';'
		//(provisions+=Provide ';')*)? 'body' body=PackBody 'end'
		public Group getGroup() { return cGroup; }
		
		//'package'
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_0() { return cNameIDENTTerminalRuleCall_1_0; }
		
		//('uses' usesIds+=IDENT (',' usesIds+=IDENT)* ';')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'uses'
		public Keyword getUsesKeyword_2_0() { return cUsesKeyword_2_0; }
		
		//usesIds+=IDENT
		public Assignment getUsesIdsAssignment_2_1() { return cUsesIdsAssignment_2_1; }
		
		//IDENT
		public RuleCall getUsesIdsIDENTTerminalRuleCall_2_1_0() { return cUsesIdsIDENTTerminalRuleCall_2_1_0; }
		
		//(',' usesIds+=IDENT)*
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//','
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }
		
		//usesIds+=IDENT
		public Assignment getUsesIdsAssignment_2_2_1() { return cUsesIdsAssignment_2_2_1; }
		
		//IDENT
		public RuleCall getUsesIdsIDENTTerminalRuleCall_2_2_1_0() { return cUsesIdsIDENTTerminalRuleCall_2_2_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_3() { return cSemicolonKeyword_2_3; }
		
		//('provides' provisions+=Provide ';' (provisions+=Provide ';')*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'provides'
		public Keyword getProvidesKeyword_3_0() { return cProvidesKeyword_3_0; }
		
		//provisions+=Provide
		public Assignment getProvisionsAssignment_3_1() { return cProvisionsAssignment_3_1; }
		
		//Provide
		public RuleCall getProvisionsProvideParserRuleCall_3_1_0() { return cProvisionsProvideParserRuleCall_3_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3_2() { return cSemicolonKeyword_3_2; }
		
		//(provisions+=Provide ';')*
		public Group getGroup_3_3() { return cGroup_3_3; }
		
		//provisions+=Provide
		public Assignment getProvisionsAssignment_3_3_0() { return cProvisionsAssignment_3_3_0; }
		
		//Provide
		public RuleCall getProvisionsProvideParserRuleCall_3_3_0_0() { return cProvisionsProvideParserRuleCall_3_3_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3_3_1() { return cSemicolonKeyword_3_3_1; }
		
		//'body'
		public Keyword getBodyKeyword_4() { return cBodyKeyword_4; }
		
		//body=PackBody
		public Assignment getBodyAssignment_5() { return cBodyAssignment_5; }
		
		//PackBody
		public RuleCall getBodyPackBodyParserRuleCall_5_0() { return cBodyPackBodyParserRuleCall_5_0; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class PackageEquationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.PackageEquation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cEqOrIsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEqOrIsIDENTTerminalRuleCall_2_0 = (RuleCall)cEqOrIsAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cByNameStaticArgsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cByNameStaticArgsByNameStaticArgParserRuleCall_4_0 = (RuleCall)cByNameStaticArgsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Alternatives cAlternatives_5_0 = (Alternatives)cGroup_5.eContents().get(0);
		private final Keyword cCommaKeyword_5_0_0 = (Keyword)cAlternatives_5_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_5_0_1 = (Keyword)cAlternatives_5_0.eContents().get(1);
		private final Assignment cByNameStaticArgsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cByNameStaticArgsByNameStaticArgParserRuleCall_5_1_0 = (RuleCall)cByNameStaticArgsAssignment_5_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//PackageEquation:
		//	'package' name=IDENT
		//	// Eq_or_Is
		//	eqOrIs=IDENT
		//	'(' byNameStaticArgs+=ByNameStaticArg ((',' | ';') byNameStaticArgs+=ByNameStaticArg)* ')' ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'package' name=IDENT // Eq_or_Is
		//eqOrIs=IDENT '(' byNameStaticArgs+=ByNameStaticArg ((',' | ';') byNameStaticArgs+=ByNameStaticArg)* ')' ';'
		public Group getGroup() { return cGroup; }
		
		//'package'
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_0() { return cNameIDENTTerminalRuleCall_1_0; }
		
		//// Eq_or_Is
		//eqOrIs=IDENT
		public Assignment getEqOrIsAssignment_2() { return cEqOrIsAssignment_2; }
		
		//IDENT
		public RuleCall getEqOrIsIDENTTerminalRuleCall_2_0() { return cEqOrIsIDENTTerminalRuleCall_2_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }
		
		//byNameStaticArgs+=ByNameStaticArg
		public Assignment getByNameStaticArgsAssignment_4() { return cByNameStaticArgsAssignment_4; }
		
		//ByNameStaticArg
		public RuleCall getByNameStaticArgsByNameStaticArgParserRuleCall_4_0() { return cByNameStaticArgsByNameStaticArgParserRuleCall_4_0; }
		
		//((',' | ';') byNameStaticArgs+=ByNameStaticArg)*
		public Group getGroup_5() { return cGroup_5; }
		
		//',' | ';'
		public Alternatives getAlternatives_5_0() { return cAlternatives_5_0; }
		
		//','
		public Keyword getCommaKeyword_5_0_0() { return cCommaKeyword_5_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_5_0_1() { return cSemicolonKeyword_5_0_1; }
		
		//byNameStaticArgs+=ByNameStaticArg
		public Assignment getByNameStaticArgsAssignment_5_1() { return cByNameStaticArgsAssignment_5_1; }
		
		//ByNameStaticArg
		public RuleCall getByNameStaticArgsByNameStaticArgParserRuleCall_5_1_0() { return cByNameStaticArgsByNameStaticArgParserRuleCall_5_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
		
		//';'
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}
	public class Package_ProvidedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Package_Provided");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNodeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cNameNodeDeclarationCrossReference_1_0 = (CrossReference)cNameAssignment_1.eContents().get(0);
		private final RuleCall cNameNodeDeclarationIDENTTerminalRuleCall_1_0_1 = (RuleCall)cNameNodeDeclarationCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParametersPackage_Provided_IOParserRuleCall_3_0_0 = (RuleCall)cParametersAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParametersAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParametersPackage_Provided_IOParserRuleCall_3_1_1_0 = (RuleCall)cParametersAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cReturnsKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cReturnedAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cReturnedPackage_Provided_IOParserRuleCall_7_0 = (RuleCall)cReturnedAssignment_7.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cCommaKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cReturnedAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cReturnedPackage_Provided_IOParserRuleCall_8_1_0 = (RuleCall)cReturnedAssignment_8_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cSemicolonKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		//// --------------------------------------------------------- Old stuff
		///**
		// * @author cpa
		// */ //LustreProgram hidden(WS, LUSTRE_COMMENT):
		////    nodes += Node_Declaration+    
		//////    packages+=Package_Declaration+   
		////;
		///*
		// * Packages
		// */ //Package_Declaration:
		////    'package' name=IDENT 
		////        ('uses' uses+=IDENT (',' uses+=IDENT)*)? 
		////        'provides' provides+=Package_Provided+
		////    'body'
		////    (
		////        nodes+=Node_Declaration |
		////        types+=Type_Declaration |
		////        constants+=Constant_Declaration
		////    )*
		////    'end'
		////;
		//Package_Provided:
		//	'node' name=[NodeDeclaration|IDENT]
		//	'(' (parameters+=Package_Provided_IO (',' parameters+=Package_Provided_IO)*)? ')'
		//	'returns' '(' returned+=Package_Provided_IO (',' returned+=Package_Provided_IO)* ')'
		//	';';
		@Override public ParserRule getRule() { return rule; }
		
		//'node' name=[NodeDeclaration|IDENT] '(' (parameters+=Package_Provided_IO (',' parameters+=Package_Provided_IO)*)? ')'
		//'returns' '(' returned+=Package_Provided_IO (',' returned+=Package_Provided_IO)* ')' ';'
		public Group getGroup() { return cGroup; }
		
		//'node'
		public Keyword getNodeKeyword_0() { return cNodeKeyword_0; }
		
		//name=[NodeDeclaration|IDENT]
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//[NodeDeclaration|IDENT]
		public CrossReference getNameNodeDeclarationCrossReference_1_0() { return cNameNodeDeclarationCrossReference_1_0; }
		
		//IDENT
		public RuleCall getNameNodeDeclarationIDENTTerminalRuleCall_1_0_1() { return cNameNodeDeclarationIDENTTerminalRuleCall_1_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(parameters+=Package_Provided_IO (',' parameters+=Package_Provided_IO)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//parameters+=Package_Provided_IO
		public Assignment getParametersAssignment_3_0() { return cParametersAssignment_3_0; }
		
		//Package_Provided_IO
		public RuleCall getParametersPackage_Provided_IOParserRuleCall_3_0_0() { return cParametersPackage_Provided_IOParserRuleCall_3_0_0; }
		
		//(',' parameters+=Package_Provided_IO)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//','
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//parameters+=Package_Provided_IO
		public Assignment getParametersAssignment_3_1_1() { return cParametersAssignment_3_1_1; }
		
		//Package_Provided_IO
		public RuleCall getParametersPackage_Provided_IOParserRuleCall_3_1_1_0() { return cParametersPackage_Provided_IOParserRuleCall_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'returns'
		public Keyword getReturnsKeyword_5() { return cReturnsKeyword_5; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6() { return cLeftParenthesisKeyword_6; }
		
		//returned+=Package_Provided_IO
		public Assignment getReturnedAssignment_7() { return cReturnedAssignment_7; }
		
		//Package_Provided_IO
		public RuleCall getReturnedPackage_Provided_IOParserRuleCall_7_0() { return cReturnedPackage_Provided_IOParserRuleCall_7_0; }
		
		//(',' returned+=Package_Provided_IO)*
		public Group getGroup_8() { return cGroup_8; }
		
		//','
		public Keyword getCommaKeyword_8_0() { return cCommaKeyword_8_0; }
		
		//returned+=Package_Provided_IO
		public Assignment getReturnedAssignment_8_1() { return cReturnedAssignment_8_1; }
		
		//Package_Provided_IO
		public RuleCall getReturnedPackage_Provided_IOParserRuleCall_8_1_0() { return cReturnedPackage_Provided_IOParserRuleCall_8_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_9() { return cRightParenthesisKeyword_9; }
		
		//';'
		public Keyword getSemicolonKeyword_10() { return cSemicolonKeyword_10; }
	}
	public class Package_Provided_IOElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Package_Provided_IO");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNameVariable_DeclarationCrossReference_0_0 = (CrossReference)cNameAssignment_0.eContents().get(0);
		private final RuleCall cNameVariable_DeclarationIDENTTerminalRuleCall_0_0_1 = (RuleCall)cNameVariable_DeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeIDENTTerminalRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//Package_Provided_IO:
		//	name=[Variable_Declaration|IDENT] ':' type=IDENT;
		@Override public ParserRule getRule() { return rule; }
		
		//name=[Variable_Declaration|IDENT] ':' type=IDENT
		public Group getGroup() { return cGroup; }
		
		//name=[Variable_Declaration|IDENT]
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//[Variable_Declaration|IDENT]
		public CrossReference getNameVariable_DeclarationCrossReference_0_0() { return cNameVariable_DeclarationCrossReference_0_0; }
		
		//IDENT
		public RuleCall getNameVariable_DeclarationIDENTTerminalRuleCall_0_0_1() { return cNameVariable_DeclarationIDENTTerminalRuleCall_0_0_1; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=IDENT
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//IDENT
		public RuleCall getTypeIDENTTerminalRuleCall_2_0() { return cTypeIDENTTerminalRuleCall_2_0; }
	}
	public class Entity_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Entity_Declaration");
		private final RuleCall cConstant_DeclarationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Entity_Declaration:
		//	Constant_Declaration;
		@Override public ParserRule getRule() { return rule; }
		
		////    Node_Declaration
		////    /*|*/ Type_Declaration
		///*| */ Constant_Declaration
		public RuleCall getConstant_DeclarationParserRuleCall() { return cConstant_DeclarationParserRuleCall; }
	}
	public class Array_TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Array_Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeTypeDeclarationCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeTypeDeclarationIDENTTerminalRuleCall_0_0_1 = (RuleCall)cTypeTypeDeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cCircumflexAccentKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLengthAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLengthINTTerminalRuleCall_2_0 = (RuleCall)cLengthAssignment_2.eContents().get(0);
		
		///*
		// * Identifiers
		// */ //Identifier:
		////    (package=[Package | IDENT] '::')? name=[Variable_Declaration | IDENT] | name=[Node_Declaration | IDENT];
		///* 
		// * Types
		// */ //Type_Declaration:
		////    'type' name=IDENT ';'
		////    | 'type' name=IDENT '=' type=Type  ';'
		////;
		////Type:
		////    name=IDENT
		//////    | Array_Type
		//////    | Record_Type
		//////    | Enum_Type
		////;
		//Array_Type:
		//	type=[TypeDeclaration|IDENT] '^' length=INT
		//	// XXX Original Lustre allows Type^Expression  
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[TypeDeclaration|IDENT] '^' length=INT
		public Group getGroup() { return cGroup; }
		
		//type=[TypeDeclaration|IDENT]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[TypeDeclaration|IDENT]
		public CrossReference getTypeTypeDeclarationCrossReference_0_0() { return cTypeTypeDeclarationCrossReference_0_0; }
		
		//IDENT
		public RuleCall getTypeTypeDeclarationIDENTTerminalRuleCall_0_0_1() { return cTypeTypeDeclarationIDENTTerminalRuleCall_0_0_1; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1() { return cCircumflexAccentKeyword_1; }
		
		//length=INT
		public Assignment getLengthAssignment_2() { return cLengthAssignment_2; }
		
		//INT
		public RuleCall getLengthINTTerminalRuleCall_2_0() { return cLengthINTTerminalRuleCall_2_0; }
	}
	public class Record_TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Record_Type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStructKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFieldsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFieldsFieldParserRuleCall_2_0 = (RuleCall)cFieldsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFieldsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFieldsFieldParserRuleCall_3_1_0 = (RuleCall)cFieldsAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Record_Type:
		//	'struct' '{' fields+=Field (',' fields+=Field)* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'struct' '{' fields+=Field (',' fields+=Field)* '}'
		public Group getGroup() { return cGroup; }
		
		//'struct'
		public Keyword getStructKeyword_0() { return cStructKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//fields+=Field
		public Assignment getFieldsAssignment_2() { return cFieldsAssignment_2; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_2_0() { return cFieldsFieldParserRuleCall_2_0; }
		
		//(',' fields+=Field)*
		public Group getGroup_3() { return cGroup_3; }
		
		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }
		
		//fields+=Field
		public Assignment getFieldsAssignment_3_1() { return cFieldsAssignment_3_1; }
		
		//Field
		public RuleCall getFieldsFieldParserRuleCall_3_1_0() { return cFieldsFieldParserRuleCall_3_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeTypeCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeTypeIDENTTerminalRuleCall_2_0_1 = (RuleCall)cTypeTypeCrossReference_2_0.eContents().get(1);
		
		//Field:
		//	name=IDENT ':' type=[Type|IDENT];
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT ':' type=[Type|IDENT]
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=[Type|IDENT]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//[Type|IDENT]
		public CrossReference getTypeTypeCrossReference_2_0() { return cTypeTypeCrossReference_2_0; }
		
		//IDENT
		public RuleCall getTypeTypeIDENTTerminalRuleCall_2_0_1() { return cTypeTypeIDENTTerminalRuleCall_2_0_1; }
	}
	public class Constant_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Constant_Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cConstKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Keyword cColonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cTypeAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_0_3_0 = (RuleCall)cTypeAssignment_0_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cConstKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cExprAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cExprConstantExpressionParserRuleCall_1_3_0 = (RuleCall)cExprAssignment_1_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cConstKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cNameAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_2_1_0 = (RuleCall)cNameAssignment_2_1.eContents().get(0);
		private final Keyword cColonKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cTypeAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_2_3_0 = (RuleCall)cTypeAssignment_2_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Assignment cExprAssignment_2_5 = (Assignment)cGroup_2.eContents().get(5);
		private final RuleCall cExprConstantExpressionParserRuleCall_2_5_0 = (RuleCall)cExprAssignment_2_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_6 = (Keyword)cGroup_2.eContents().get(6);
		
		////Enum_Type:
		////    'enum' '{' nameList=Ident_List '}'
		////;
		///*
		// * Constants and variables
		// */ Constant_Declaration:
		//	'const' name=IDENT ':' type=Type ';'
		//	| 'const' name=IDENT '=' expr=ConstantExpression ';'
		//	| 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
		//	// XXX Original Lustre allows Expressions
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'const' name=IDENT ':' type=Type ';' | 'const' name=IDENT '=' expr=ConstantExpression ';' | 'const' name=IDENT ':'
		//type=Type '=' expr=ConstantExpression ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'const' name=IDENT ':' type=Type ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//'const'
		public Keyword getConstKeyword_0_0() { return cConstKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//':'
		public Keyword getColonKeyword_0_2() { return cColonKeyword_0_2; }
		
		//type=Type
		public Assignment getTypeAssignment_0_3() { return cTypeAssignment_0_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_0_3_0() { return cTypeTypeParserRuleCall_0_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_4() { return cSemicolonKeyword_0_4; }
		
		//'const' name=IDENT '=' expr=ConstantExpression ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//'const'
		public Keyword getConstKeyword_1_0() { return cConstKeyword_1_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_1_0() { return cNameIDENTTerminalRuleCall_1_1_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_2() { return cEqualsSignKeyword_1_2; }
		
		//expr=ConstantExpression
		public Assignment getExprAssignment_1_3() { return cExprAssignment_1_3; }
		
		//ConstantExpression
		public RuleCall getExprConstantExpressionParserRuleCall_1_3_0() { return cExprConstantExpressionParserRuleCall_1_3_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_4() { return cSemicolonKeyword_1_4; }
		
		//'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
		public Group getGroup_2() { return cGroup_2; }
		
		//'const'
		public Keyword getConstKeyword_2_0() { return cConstKeyword_2_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_2_1() { return cNameAssignment_2_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_2_1_0() { return cNameIDENTTerminalRuleCall_2_1_0; }
		
		//':'
		public Keyword getColonKeyword_2_2() { return cColonKeyword_2_2; }
		
		//type=Type
		public Assignment getTypeAssignment_2_3() { return cTypeAssignment_2_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_3_0() { return cTypeTypeParserRuleCall_2_3_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_4() { return cEqualsSignKeyword_2_4; }
		
		//expr=ConstantExpression
		public Assignment getExprAssignment_2_5() { return cExprAssignment_2_5; }
		
		//ConstantExpression
		public RuleCall getExprConstantExpressionParserRuleCall_2_5_0() { return cExprConstantExpressionParserRuleCall_2_5_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_6() { return cSemicolonKeyword_2_6; }
	}
	public class Variable_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Variable_Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cWhenKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cClockAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cClockIDENTTerminalRuleCall_3_1_0 = (RuleCall)cClockAssignment_3_1.eContents().get(0);
		
		//Variable_Declaration:
		//	name=IDENT ':' type=Type ('when' clock=IDENT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT ':' type=Type ('when' clock=IDENT)?
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }
		
		//('when' clock=IDENT)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'when'
		public Keyword getWhenKeyword_3_0() { return cWhenKeyword_3_0; }
		
		//clock=IDENT
		public Assignment getClockAssignment_3_1() { return cClockAssignment_3_1; }
		
		//IDENT
		public RuleCall getClockIDENTTerminalRuleCall_3_1_0() { return cClockIDENTTerminalRuleCall_3_1_0; }
	}
	public class Local_Variable_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Local_Variable_Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVarKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cVariable_DeclarationParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Local_Variable_Declaration Variable_Declaration:
		//	'var' Variable_Declaration ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'var' Variable_Declaration ';'
		public Group getGroup() { return cGroup; }
		
		//'var'
		public Keyword getVarKeyword_0() { return cVarKeyword_0; }
		
		//Variable_Declaration
		public RuleCall getVariable_DeclarationParserRuleCall_1() { return cVariable_DeclarationParserRuleCall_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class Local_Constant_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Local_Constant_Declaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cConstant_DeclarationAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cConstKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cNameAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cNameIDENTTerminalRuleCall_0_2_0 = (RuleCall)cNameAssignment_0_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cExprAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cExprConstantExpressionParserRuleCall_0_4_0 = (RuleCall)cExprAssignment_0_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cConstant_DeclarationAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cConstKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNameAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cNameIDENTTerminalRuleCall_1_2_0 = (RuleCall)cNameAssignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cTypeAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cTypeTypeParserRuleCall_1_4_0 = (RuleCall)cTypeAssignment_1_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Assignment cExprAssignment_1_6 = (Assignment)cGroup_1.eContents().get(6);
		private final RuleCall cExprConstantExpressionParserRuleCall_1_6_0 = (RuleCall)cExprAssignment_1_6.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		
		//Local_Constant_Declaration Constant_Declaration:
		//	{Constant_Declaration} 'const' name=IDENT '=' expr=ConstantExpression ';'
		//	| {Constant_Declaration} 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
		//	// XXX Original Lustre allows Expressions
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{Constant_Declaration} 'const' name=IDENT '=' expr=ConstantExpression ';' | {Constant_Declaration} 'const' name=IDENT
		//':' type=Type '=' expr=ConstantExpression ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{Constant_Declaration} 'const' name=IDENT '=' expr=ConstantExpression ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//{Constant_Declaration}
		public Action getConstant_DeclarationAction_0_0() { return cConstant_DeclarationAction_0_0; }
		
		//'const'
		public Keyword getConstKeyword_0_1() { return cConstKeyword_0_1; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_2() { return cNameAssignment_0_2; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_2_0() { return cNameIDENTTerminalRuleCall_0_2_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_3() { return cEqualsSignKeyword_0_3; }
		
		//expr=ConstantExpression
		public Assignment getExprAssignment_0_4() { return cExprAssignment_0_4; }
		
		//ConstantExpression
		public RuleCall getExprConstantExpressionParserRuleCall_0_4_0() { return cExprConstantExpressionParserRuleCall_0_4_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_5() { return cSemicolonKeyword_0_5; }
		
		//{Constant_Declaration} 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//{Constant_Declaration}
		public Action getConstant_DeclarationAction_1_0() { return cConstant_DeclarationAction_1_0; }
		
		//'const'
		public Keyword getConstKeyword_1_1() { return cConstKeyword_1_1; }
		
		//name=IDENT
		public Assignment getNameAssignment_1_2() { return cNameAssignment_1_2; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_1_2_0() { return cNameIDENTTerminalRuleCall_1_2_0; }
		
		//':'
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }
		
		//type=Type
		public Assignment getTypeAssignment_1_4() { return cTypeAssignment_1_4; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_1_4_0() { return cTypeTypeParserRuleCall_1_4_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_5() { return cEqualsSignKeyword_1_5; }
		
		//expr=ConstantExpression
		public Assignment getExprAssignment_1_6() { return cExprAssignment_1_6; }
		
		//ConstantExpression
		public RuleCall getExprConstantExpressionParserRuleCall_1_6_0() { return cExprConstantExpressionParserRuleCall_1_6_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_7() { return cSemicolonKeyword_1_7; }
	}
	public class EquationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Equation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cLeftAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final CrossReference cLeftLustreTypedIdCrossReference_0_0_0 = (CrossReference)cLeftAssignment_0_0.eContents().get(0);
		private final RuleCall cLeftLustreTypedIdIDENTTerminalRuleCall_0_0_0_1 = (RuleCall)cLeftLustreTypedIdCrossReference_0_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cRightAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cRightRight_PartParserRuleCall_0_2_0 = (RuleCall)cRightAssignment_0_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cLeftAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final CrossReference cLeftLustreTypedValuedIdsCrossReference_1_0_0 = (CrossReference)cLeftAssignment_1_0.eContents().get(0);
		private final RuleCall cLeftLustreTypedValuedIdsIDENTTerminalRuleCall_1_0_0_1 = (RuleCall)cLeftLustreTypedValuedIdsCrossReference_1_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRight_PartParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cLeftAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final CrossReference cLeftLustreClockedIdDeclarationCrossReference_2_0_0 = (CrossReference)cLeftAssignment_2_0.eContents().get(0);
		private final RuleCall cLeftLustreClockedIdDeclarationIDENTTerminalRuleCall_2_0_0_1 = (RuleCall)cLeftLustreClockedIdDeclarationCrossReference_2_0_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cRightAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cRightRight_PartParserRuleCall_2_2_0 = (RuleCall)cRightAssignment_2_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		
		///*
		// * Nodes
		// */ //Node_Declaration:
		////    'node'  
		////        name=IDENT 
		////        '(' (parameters+=Variable_Declaration (',' parameters+=Variable_Declaration)*)? ')' 
		////        'returns' '(' returned+=Variable_Declaration (',' returned+=Variable_Declaration)* ')' 
		////    ';'
		////    (
		////        constants+=Local_Constant_Declaration |
		////        variables+=Local_Variable_Declaration
		////    )* 
		////    'let' 
		////    (
		////        equations+=Equation | 
		////        assertions+=Assertion |
		////        automatons+=Automaton
		////    )*
		////    'tel' ';'?
		////;
		//Equation:
		//	left=[LustreTypedId|IDENT] '=' right=Right_Part ';'
		//	| left=[LustreTypedValuedIds|IDENT] '=' right=Right_Part ';'
		//	| left=[LustreClockedIdDeclaration|IDENT] '=' right=Right_Part ';';
		@Override public ParserRule getRule() { return rule; }
		
		//left=[LustreTypedId|IDENT] '=' right=Right_Part ';' | left=[LustreTypedValuedIds|IDENT] '=' right=Right_Part ';' |
		//left=[LustreClockedIdDeclaration|IDENT] '=' right=Right_Part ';'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//left=[LustreTypedId|IDENT] '=' right=Right_Part ';'
		public Group getGroup_0() { return cGroup_0; }
		
		//left=[LustreTypedId|IDENT]
		public Assignment getLeftAssignment_0_0() { return cLeftAssignment_0_0; }
		
		//[LustreTypedId|IDENT]
		public CrossReference getLeftLustreTypedIdCrossReference_0_0_0() { return cLeftLustreTypedIdCrossReference_0_0_0; }
		
		//IDENT
		public RuleCall getLeftLustreTypedIdIDENTTerminalRuleCall_0_0_0_1() { return cLeftLustreTypedIdIDENTTerminalRuleCall_0_0_0_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_0_1() { return cEqualsSignKeyword_0_1; }
		
		//right=Right_Part
		public Assignment getRightAssignment_0_2() { return cRightAssignment_0_2; }
		
		//Right_Part
		public RuleCall getRightRight_PartParserRuleCall_0_2_0() { return cRightRight_PartParserRuleCall_0_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_3() { return cSemicolonKeyword_0_3; }
		
		//left=[LustreTypedValuedIds|IDENT] '=' right=Right_Part ';'
		public Group getGroup_1() { return cGroup_1; }
		
		//left=[LustreTypedValuedIds|IDENT]
		public Assignment getLeftAssignment_1_0() { return cLeftAssignment_1_0; }
		
		//[LustreTypedValuedIds|IDENT]
		public CrossReference getLeftLustreTypedValuedIdsCrossReference_1_0_0() { return cLeftLustreTypedValuedIdsCrossReference_1_0_0; }
		
		//IDENT
		public RuleCall getLeftLustreTypedValuedIdsIDENTTerminalRuleCall_1_0_0_1() { return cLeftLustreTypedValuedIdsIDENTTerminalRuleCall_1_0_0_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//right=Right_Part
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Right_Part
		public RuleCall getRightRight_PartParserRuleCall_1_2_0() { return cRightRight_PartParserRuleCall_1_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_1_3() { return cSemicolonKeyword_1_3; }
		
		//left=[LustreClockedIdDeclaration|IDENT] '=' right=Right_Part ';'
		public Group getGroup_2() { return cGroup_2; }
		
		//left=[LustreClockedIdDeclaration|IDENT]
		public Assignment getLeftAssignment_2_0() { return cLeftAssignment_2_0; }
		
		//[LustreClockedIdDeclaration|IDENT]
		public CrossReference getLeftLustreClockedIdDeclarationCrossReference_2_0_0() { return cLeftLustreClockedIdDeclarationCrossReference_2_0_0; }
		
		//IDENT
		public RuleCall getLeftLustreClockedIdDeclarationIDENTTerminalRuleCall_2_0_0_1() { return cLeftLustreClockedIdDeclarationIDENTTerminalRuleCall_2_0_0_1; }
		
		//'='
		public Keyword getEqualsSignKeyword_2_1() { return cEqualsSignKeyword_2_1; }
		
		//right=Right_Part
		public Assignment getRightAssignment_2_2() { return cRightAssignment_2_2; }
		
		//Right_Part
		public RuleCall getRightRight_PartParserRuleCall_2_2_0() { return cRightRight_PartParserRuleCall_2_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_3() { return cSemicolonKeyword_2_3; }
	}
	public class AssertionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Assertion");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAssertKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Assertion:
		//	'assert' Expression ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'assert' Expression ';'
		public Group getGroup() { return cGroup; }
		
		//'assert'
		public Keyword getAssertKeyword_0() { return cAssertKeyword_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class AutomatonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Automaton");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAutomatonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatesAStateParserRuleCall_1_0 = (RuleCall)cStatesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cVerticalLineKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cStatesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cStatesAStateParserRuleCall_2_1_0 = (RuleCall)cStatesAssignment_2_1.eContents().get(0);
		private final Keyword cEndKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Automaton:
		//	'automaton' states+=AState ('|' states+=AState)* 'end' ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'automaton' states+=AState ('|' states+=AState)* 'end' ';'
		public Group getGroup() { return cGroup; }
		
		//'automaton'
		public Keyword getAutomatonKeyword_0() { return cAutomatonKeyword_0; }
		
		//states+=AState
		public Assignment getStatesAssignment_1() { return cStatesAssignment_1; }
		
		//AState
		public RuleCall getStatesAStateParserRuleCall_1_0() { return cStatesAStateParserRuleCall_1_0; }
		
		//('|' states+=AState)*
		public Group getGroup_2() { return cGroup_2; }
		
		//'|'
		public Keyword getVerticalLineKeyword_2_0() { return cVerticalLineKeyword_2_0; }
		
		//states+=AState
		public Assignment getStatesAssignment_2_1() { return cStatesAssignment_2_1; }
		
		//AState
		public RuleCall getStatesAStateParserRuleCall_2_1_0() { return cStatesAStateParserRuleCall_2_1_0; }
		
		//'end'
		public Keyword getEndKeyword_3() { return cEndKeyword_3; }
		
		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}
	public class AStateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.AState");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cEquationsAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cEquationsEquationParserRuleCall_2_0_0 = (RuleCall)cEquationsAssignment_2_0.eContents().get(0);
		private final Assignment cAssertionsAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cAssertionsAssertionParserRuleCall_2_1_0 = (RuleCall)cAssertionsAssignment_2_1.eContents().get(0);
		private final Assignment cAutomatonsAssignment_2_2 = (Assignment)cAlternatives_2.eContents().get(2);
		private final RuleCall cAutomatonsAutomatonParserRuleCall_2_2_0 = (RuleCall)cAutomatonsAssignment_2_2.eContents().get(0);
		private final Assignment cTransitionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTransitionsATransitionParserRuleCall_3_0 = (RuleCall)cTransitionsAssignment_3.eContents().get(0);
		
		//AState:
		//	name=IDENT '->' (equations+=Equation | assertions+=Assertion | automatons+=Automaton)*
		//	transitions+=ATransition+;
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT '->' (equations+=Equation | assertions+=Assertion | automatons+=Automaton)* transitions+=ATransition+
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//(equations+=Equation | assertions+=Assertion | automatons+=Automaton)*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//equations+=Equation
		public Assignment getEquationsAssignment_2_0() { return cEquationsAssignment_2_0; }
		
		//Equation
		public RuleCall getEquationsEquationParserRuleCall_2_0_0() { return cEquationsEquationParserRuleCall_2_0_0; }
		
		//assertions+=Assertion
		public Assignment getAssertionsAssignment_2_1() { return cAssertionsAssignment_2_1; }
		
		//Assertion
		public RuleCall getAssertionsAssertionParserRuleCall_2_1_0() { return cAssertionsAssertionParserRuleCall_2_1_0; }
		
		//automatons+=Automaton
		public Assignment getAutomatonsAssignment_2_2() { return cAutomatonsAssignment_2_2; }
		
		//Automaton
		public RuleCall getAutomatonsAutomatonParserRuleCall_2_2_0() { return cAutomatonsAutomatonParserRuleCall_2_2_0; }
		
		//transitions+=ATransition+
		public Assignment getTransitionsAssignment_3() { return cTransitionsAssignment_3; }
		
		//ATransition
		public RuleCall getTransitionsATransitionParserRuleCall_3_0() { return cTransitionsATransitionParserRuleCall_3_0; }
	}
	public class ATransitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ATransition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cUntilKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Assignment cStrongAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cStrongUnlessKeyword_0_1_0 = (Keyword)cStrongAssignment_0_1.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cThenKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Assignment cHistoryAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final Keyword cHistoryContinueKeyword_2_1_0 = (Keyword)cHistoryAssignment_2_1.eContents().get(0);
		private final Assignment cNextStateAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cNextStateAStateCrossReference_3_0 = (CrossReference)cNextStateAssignment_3.eContents().get(0);
		private final RuleCall cNextStateAStateIDENTTerminalRuleCall_3_0_1 = (RuleCall)cNextStateAStateCrossReference_3_0.eContents().get(1);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ATransition:
		//	('until' | strong?='unless') condition=Expression ('then' | history?='continue') nextState=[AState|IDENT] ';';
		@Override public ParserRule getRule() { return rule; }
		
		//('until' | strong?='unless') condition=Expression ('then' | history?='continue') nextState=[AState|IDENT] ';'
		public Group getGroup() { return cGroup; }
		
		//'until' | strong?='unless'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'until'
		public Keyword getUntilKeyword_0_0() { return cUntilKeyword_0_0; }
		
		//strong?='unless'
		public Assignment getStrongAssignment_0_1() { return cStrongAssignment_0_1; }
		
		//'unless'
		public Keyword getStrongUnlessKeyword_0_1_0() { return cStrongUnlessKeyword_0_1_0; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0() { return cConditionExpressionParserRuleCall_1_0; }
		
		//'then' | history?='continue'
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'then'
		public Keyword getThenKeyword_2_0() { return cThenKeyword_2_0; }
		
		//history?='continue'
		public Assignment getHistoryAssignment_2_1() { return cHistoryAssignment_2_1; }
		
		//'continue'
		public Keyword getHistoryContinueKeyword_2_1_0() { return cHistoryContinueKeyword_2_1_0; }
		
		//nextState=[AState|IDENT]
		public Assignment getNextStateAssignment_3() { return cNextStateAssignment_3; }
		
		//[AState|IDENT]
		public CrossReference getNextStateAStateCrossReference_3_0() { return cNextStateAStateCrossReference_3_0; }
		
		//IDENT
		public RuleCall getNextStateAStateIDENTTerminalRuleCall_3_0_1() { return cNextStateAStateIDENTTerminalRuleCall_3_0_1; }
		
		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}
	public class Left_PartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Left_Part");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cLeft_ListParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cLeft_ListParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Left_Part:
		//	'(' Left_List ')'
		//	| Left_List;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Left_List ')' | Left_List
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Left_List ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Left_List
		public RuleCall getLeft_ListParserRuleCall_0_1() { return cLeft_ListParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//Left_List
		public RuleCall getLeft_ListParserRuleCall_1() { return cLeft_ListParserRuleCall_1; }
	}
	public class Left_ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Left_List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdLeftParserRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIdAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIdLeftParserRuleCall_1_1_0 = (RuleCall)cIdAssignment_1_1.eContents().get(0);
		
		//Left_List:
		//	id+=Left (',' id+=Left)*;
		@Override public ParserRule getRule() { return rule; }
		
		//id+=Left (',' id+=Left)*
		public Group getGroup() { return cGroup; }
		
		//id+=Left
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }
		
		//Left
		public RuleCall getIdLeftParserRuleCall_0_0() { return cIdLeftParserRuleCall_0_0; }
		
		//(',' id+=Left)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//id+=Left
		public Assignment getIdAssignment_1_1() { return cIdAssignment_1_1; }
		
		//Left
		public RuleCall getIdLeftParserRuleCall_1_1_0() { return cIdLeftParserRuleCall_1_1_0; }
	}
	public class LeftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Left");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDENTTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cSelectorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSelectorSelectorParserRuleCall_1_0 = (RuleCall)cSelectorAssignment_1.eContents().get(0);
		
		//Left:
		//	name=IDENT selector=Selector?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=IDENT selector=Selector?
		public Group getGroup() { return cGroup; }
		
		//name=IDENT
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_0() { return cNameIDENTTerminalRuleCall_0_0; }
		
		//selector=Selector?
		public Assignment getSelectorAssignment_1() { return cSelectorAssignment_1; }
		
		//Selector
		public RuleCall getSelectorSelectorParserRuleCall_1_0() { return cSelectorSelectorParserRuleCall_1_0; }
	}
	public class SelectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Selector");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDENTTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cBeginAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBeginExpressionParserRuleCall_1_1_0 = (RuleCall)cBeginAssignment_1_1.eContents().get(0);
		private final Assignment cEndAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cEndSelTrancheEndParserRuleCall_1_2_0 = (RuleCall)cEndAssignment_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Selector:
		//	'.' name=IDENT
		//	| '[' begin=Expression end=SelTrancheEnd? ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'.' name=IDENT | '[' begin=Expression end=SelTrancheEnd? ']'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'.' name=IDENT
		public Group getGroup_0() { return cGroup_0; }
		
		//'.'
		public Keyword getFullStopKeyword_0_0() { return cFullStopKeyword_0_0; }
		
		//name=IDENT
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//IDENT
		public RuleCall getNameIDENTTerminalRuleCall_0_1_0() { return cNameIDENTTerminalRuleCall_0_1_0; }
		
		//'[' begin=Expression end=SelTrancheEnd? ']'
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//begin=Expression
		public Assignment getBeginAssignment_1_1() { return cBeginAssignment_1_1; }
		
		//Expression
		public RuleCall getBeginExpressionParserRuleCall_1_1_0() { return cBeginExpressionParserRuleCall_1_1_0; }
		
		//end=SelTrancheEnd?
		public Assignment getEndAssignment_1_2() { return cEndAssignment_1_2; }
		
		//SelTrancheEnd
		public RuleCall getEndSelTrancheEndParserRuleCall_1_2_0() { return cEndSelTrancheEndParserRuleCall_1_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_3() { return cRightSquareBracketKeyword_1_3; }
	}
	public class SelTrancheEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.SelTrancheEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//SelTrancheEnd Expression:
		//	'..' Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//'..' Expression
		public Group getGroup() { return cGroup; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_0() { return cFullStopFullStopKeyword_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}
	public class Right_PartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Right_Part");
		private final RuleCall cExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Right_Part Expression:
		//	Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall() { return cExpressionParserRuleCall; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIfThenElseAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cIfKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cIfexprAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cIfexprExpressionParserRuleCall_0_2_0 = (RuleCall)cIfexprAssignment_0_2.eContents().get(0);
		private final Keyword cThenKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cThenexprAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final RuleCall cThenexprExpressionParserRuleCall_0_4_0 = (RuleCall)cThenexprAssignment_0_4.eContents().get(0);
		private final Keyword cElseKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Assignment cElseexprAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final RuleCall cElseexprExpressionParserRuleCall_0_6_0 = (RuleCall)cElseexprAssignment_0_6.eContents().get(0);
		private final RuleCall cFbyParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///*
		// * Expressions
		// */ Expression:
		//	{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression
		//	| Fby;
		@Override public ParserRule getRule() { return rule; }
		
		//{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression | Fby
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression
		public Group getGroup_0() { return cGroup_0; }
		
		//{IfThenElse}
		public Action getIfThenElseAction_0_0() { return cIfThenElseAction_0_0; }
		
		//'if'
		public Keyword getIfKeyword_0_1() { return cIfKeyword_0_1; }
		
		//ifexpr=Expression
		public Assignment getIfexprAssignment_0_2() { return cIfexprAssignment_0_2; }
		
		//Expression
		public RuleCall getIfexprExpressionParserRuleCall_0_2_0() { return cIfexprExpressionParserRuleCall_0_2_0; }
		
		//'then'
		public Keyword getThenKeyword_0_3() { return cThenKeyword_0_3; }
		
		//thenexpr=Expression
		public Assignment getThenexprAssignment_0_4() { return cThenexprAssignment_0_4; }
		
		//Expression
		public RuleCall getThenexprExpressionParserRuleCall_0_4_0() { return cThenexprExpressionParserRuleCall_0_4_0; }
		
		//'else'
		public Keyword getElseKeyword_0_5() { return cElseKeyword_0_5; }
		
		//elseexpr=Expression
		public Assignment getElseexprAssignment_0_6() { return cElseexprAssignment_0_6; }
		
		//Expression
		public RuleCall getElseexprExpressionParserRuleCall_0_6_0() { return cElseexprExpressionParserRuleCall_0_6_0; }
		
		//Fby
		public RuleCall getFbyParserRuleCall_1() { return cFbyParserRuleCall_1; }
	}
	public class FbyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Fby");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cArrowParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cFbySubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cFbyKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cSubExpressionsArrowParserRuleCall_1_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1_1.eContents().get(0);
		
		//Fby Expression:
		//	Arrow ({Fby.subExpressions+=current} ('fby' subExpressions+=Arrow)+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//Arrow ({Fby.subExpressions+=current} ('fby' subExpressions+=Arrow)+)?
		public Group getGroup() { return cGroup; }
		
		//Arrow
		public RuleCall getArrowParserRuleCall_0() { return cArrowParserRuleCall_0; }
		
		//({Fby.subExpressions+=current} ('fby' subExpressions+=Arrow)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Fby.subExpressions+=current}
		public Action getFbySubExpressionsAction_1_0() { return cFbySubExpressionsAction_1_0; }
		
		//('fby' subExpressions+=Arrow)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'fby'
		public Keyword getFbyKeyword_1_1_0() { return cFbyKeyword_1_1_0; }
		
		//subExpressions+=Arrow
		public Assignment getSubExpressionsAssignment_1_1_1() { return cSubExpressionsAssignment_1_1_1; }
		
		//Arrow
		public RuleCall getSubExpressionsArrowParserRuleCall_1_1_1_0() { return cSubExpressionsArrowParserRuleCall_1_1_1_0; }
	}
	public class ArrowElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Arrow");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArrowSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cSubExpressionsOrParserRuleCall_1_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1_1.eContents().get(0);
		
		//Arrow Expression:
		//	Or ({Arrow.subExpressions+=current} ('->' subExpressions+=Or)+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//Or ({Arrow.subExpressions+=current} ('->' subExpressions+=Or)+)?
		public Group getGroup() { return cGroup; }
		
		//Or
		public RuleCall getOrParserRuleCall_0() { return cOrParserRuleCall_0; }
		
		//({Arrow.subExpressions+=current} ('->' subExpressions+=Or)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Arrow.subExpressions+=current}
		public Action getArrowSubExpressionsAction_1_0() { return cArrowSubExpressionsAction_1_0; }
		
		//('->' subExpressions+=Or)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_1_0() { return cHyphenMinusGreaterThanSignKeyword_1_1_0; }
		
		//subExpressions+=Or
		public Assignment getSubExpressionsAssignment_1_1_1() { return cSubExpressionsAssignment_1_1_1; }
		
		//Or
		public RuleCall getSubExpressionsOrParserRuleCall_1_1_1_0() { return cSubExpressionsOrParserRuleCall_1_1_1_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cOrKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cSubExpressionsAndParserRuleCall_1_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1_1.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.subExpressions+=current} ('or' subExpressions+=And)+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.subExpressions+=current} ('or' subExpressions+=And)+)?
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.subExpressions+=current} ('or' subExpressions+=And)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.subExpressions+=current}
		public Action getOrSubExpressionsAction_1_0() { return cOrSubExpressionsAction_1_0; }
		
		//('or' subExpressions+=And)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'or'
		public Keyword getOrKeyword_1_1_0() { return cOrKeyword_1_1_0; }
		
		//subExpressions+=And
		public Assignment getSubExpressionsAssignment_1_1_1() { return cSubExpressionsAssignment_1_1_1; }
		
		//And
		public RuleCall getSubExpressionsAndParserRuleCall_1_1_1_0() { return cSubExpressionsAndParserRuleCall_1_1_1_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cAndKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cSubExpressionsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cSubExpressionsEqualityParserRuleCall_1_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1_1.eContents().get(0);
		
		//And Expression:
		//	Equality ({And.subExpressions+=current} ('and' subExpressions+=Equality)+)?;
		@Override public ParserRule getRule() { return rule; }
		
		//Equality ({And.subExpressions+=current} ('and' subExpressions+=Equality)+)?
		public Group getGroup() { return cGroup; }
		
		//Equality
		public RuleCall getEqualityParserRuleCall_0() { return cEqualityParserRuleCall_0; }
		
		//({And.subExpressions+=current} ('and' subExpressions+=Equality)+)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.subExpressions+=current}
		public Action getAndSubExpressionsAction_1_0() { return cAndSubExpressionsAction_1_0; }
		
		//('and' subExpressions+=Equality)+
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//'and'
		public Keyword getAndKeyword_1_1_0() { return cAndKeyword_1_1_0; }
		
		//subExpressions+=Equality
		public Assignment getSubExpressionsAssignment_1_1_1() { return cSubExpressionsAssignment_1_1_1; }
		
		//Equality
		public RuleCall getSubExpressionsEqualityParserRuleCall_1_1_1_0() { return cSubExpressionsEqualityParserRuleCall_1_1_1_0; }
	}
	public class EqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Equality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignGreaterThanSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Equality Expression:
		//	Comparison ({Equality.left=current} op=('=' | '<>') right=Comparison)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison ({Equality.left=current} op=('=' | '<>') right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//({Equality.left=current} op=('=' | '<>') right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Equality.left=current}
		public Action getEqualityLeftAction_1_0() { return cEqualityLeftAction_1_0; }
		
		//op=('=' | '<>')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('=' | '<>')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'='
		public Keyword getOpEqualsSignKeyword_1_1_0_0() { return cOpEqualsSignKeyword_1_1_0_0; }
		
		//'<>'
		public Keyword getOpLessThanSignGreaterThanSignKeyword_1_1_0_1() { return cOpLessThanSignGreaterThanSignKeyword_1_1_0_1; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_2_0() { return cRightComparisonParserRuleCall_1_2_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpLessThanSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightModParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Comparison Expression:
		//	Mod ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=Mod)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Mod ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=Mod)*
		public Group getGroup() { return cGroup; }
		
		//Mod
		public RuleCall getModParserRuleCall_0() { return cModParserRuleCall_0; }
		
		//({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=Mod)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Comparison.left=current}
		public Action getComparisonLeftAction_1_0() { return cComparisonLeftAction_1_0; }
		
		//op=('>=' | '<=' | '>' | '<')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//('>=' | '<=' | '>' | '<')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//'>='
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_0() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_0; }
		
		//'<='
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_1() { return cOpLessThanSignEqualsSignKeyword_1_1_0_1; }
		
		//'>'
		public Keyword getOpGreaterThanSignKeyword_1_1_0_2() { return cOpGreaterThanSignKeyword_1_1_0_2; }
		
		//'<'
		public Keyword getOpLessThanSignKeyword_1_1_0_3() { return cOpLessThanSignKeyword_1_1_0_3; }
		
		//right=Mod
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Mod
		public RuleCall getRightModParserRuleCall_1_2_0() { return cRightModParserRuleCall_1_2_0; }
	}
	public class ModElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Mod");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusOrMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cModSubExpressionsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cModKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cSubExpressionsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSubExpressionsPlusOrMinusParserRuleCall_1_2_0 = (RuleCall)cSubExpressionsAssignment_1_2.eContents().get(0);
		
		//Mod Expression:
		//	PlusOrMinus ({Mod.subExpressions+=current} 'mod' subExpressions+=PlusOrMinus)*;
		@Override public ParserRule getRule() { return rule; }
		
		//PlusOrMinus ({Mod.subExpressions+=current} 'mod' subExpressions+=PlusOrMinus)*
		public Group getGroup() { return cGroup; }
		
		//PlusOrMinus
		public RuleCall getPlusOrMinusParserRuleCall_0() { return cPlusOrMinusParserRuleCall_0; }
		
		//({Mod.subExpressions+=current} 'mod' subExpressions+=PlusOrMinus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Mod.subExpressions+=current}
		public Action getModSubExpressionsAction_1_0() { return cModSubExpressionsAction_1_0; }
		
		//'mod'
		public Keyword getModKeyword_1_1() { return cModKeyword_1_1; }
		
		//subExpressions+=PlusOrMinus
		public Assignment getSubExpressionsAssignment_1_2() { return cSubExpressionsAssignment_1_2; }
		
		//PlusOrMinus
		public RuleCall getSubExpressionsPlusOrMinusParserRuleCall_1_2_0() { return cSubExpressionsPlusOrMinusParserRuleCall_1_2_0; }
	}
	public class PlusOrMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.PlusOrMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMulOrDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusSubExpressionsAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusSubExpressionsAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cSubExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSubExpressionsMulOrDivParserRuleCall_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1.eContents().get(0);
		
		//PlusOrMinus Expression:
		//	MulOrDiv (({Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-') subExpressions+=MulOrDiv)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MulOrDiv (({Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-') subExpressions+=MulOrDiv)*
		public Group getGroup() { return cGroup; }
		
		//MulOrDiv
		public RuleCall getMulOrDivParserRuleCall_0() { return cMulOrDivParserRuleCall_0; }
		
		//(({Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-') subExpressions+=MulOrDiv)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{Plus.subExpressions+=current} '+'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Plus.subExpressions+=current}
		public Action getPlusSubExpressionsAction_1_0_0_0() { return cPlusSubExpressionsAction_1_0_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }
		
		//{Minus.subExpressions+=current} '-'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{Minus.subExpressions+=current}
		public Action getMinusSubExpressionsAction_1_0_1_0() { return cMinusSubExpressionsAction_1_0_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }
		
		//subExpressions+=MulOrDiv
		public Assignment getSubExpressionsAssignment_1_1() { return cSubExpressionsAssignment_1_1; }
		
		//MulOrDiv
		public RuleCall getSubExpressionsMulOrDivParserRuleCall_1_1_0() { return cSubExpressionsMulOrDivParserRuleCall_1_1_0; }
	}
	public class MulOrDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.MulOrDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMulSubExpressionsAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivSubExpressionsAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cSubExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSubExpressionsPrimaryParserRuleCall_1_1_0 = (RuleCall)cSubExpressionsAssignment_1_1.eContents().get(0);
		
		//MulOrDiv Expression:
		//	Primary (({Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/') subExpressions+=Primary)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary (({Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/') subExpressions+=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//(({Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/') subExpressions+=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{Mul.subExpressions+=current} '*'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Mul.subExpressions+=current}
		public Action getMulSubExpressionsAction_1_0_0_0() { return cMulSubExpressionsAction_1_0_0_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }
		
		//{Div.subExpressions+=current} '/'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{Div.subExpressions+=current}
		public Action getDivSubExpressionsAction_1_0_1_0() { return cDivSubExpressionsAction_1_0_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }
		
		//subExpressions+=Primary
		public Assignment getSubExpressionsAssignment_1_1() { return cSubExpressionsAssignment_1_1; }
		
		//Primary
		public RuleCall getSubExpressionsPrimaryParserRuleCall_1_1_0() { return cSubExpressionsPrimaryParserRuleCall_1_1_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cNotKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cUMinusAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cExpressionAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_2_2_0 = (RuleCall)cExpressionAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cPreAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cPreKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cExpressionAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_3_2_0 = (RuleCall)cExpressionAssignment_3_2.eContents().get(0);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cCurrentAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Keyword cCurrentKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cExpressionAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_4_2_0 = (RuleCall)cExpressionAssignment_4_2.eContents().get(0);
		private final RuleCall cAtomicExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//Primary Expression:
		//	'(' Expression ')'
		//	| {Not} 'not' expression=Primary
		//	| {UMinus} '-' expression=Primary
		//	| {Pre} 'pre' expression=Primary
		//	| {Current} 'current' expression=Primary
		//	| AtomicExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')' | {Not} 'not' expression=Primary | {UMinus} '-' expression=Primary | {Pre} 'pre' expression=Primary |
		//{Current} 'current' expression=Primary | AtomicExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{Not} 'not' expression=Primary
		public Group getGroup_1() { return cGroup_1; }
		
		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }
		
		//'not'
		public Keyword getNotKeyword_1_1() { return cNotKeyword_1_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_1_2_0() { return cExpressionPrimaryParserRuleCall_1_2_0; }
		
		//{UMinus} '-' expression=Primary
		public Group getGroup_2() { return cGroup_2; }
		
		//{UMinus}
		public Action getUMinusAction_2_0() { return cUMinusAction_2_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_2_1() { return cHyphenMinusKeyword_2_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_2_2() { return cExpressionAssignment_2_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_2_2_0() { return cExpressionPrimaryParserRuleCall_2_2_0; }
		
		//{Pre} 'pre' expression=Primary
		public Group getGroup_3() { return cGroup_3; }
		
		//{Pre}
		public Action getPreAction_3_0() { return cPreAction_3_0; }
		
		//'pre'
		public Keyword getPreKeyword_3_1() { return cPreKeyword_3_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_3_2() { return cExpressionAssignment_3_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_3_2_0() { return cExpressionPrimaryParserRuleCall_3_2_0; }
		
		//{Current} 'current' expression=Primary
		public Group getGroup_4() { return cGroup_4; }
		
		//{Current}
		public Action getCurrentAction_4_0() { return cCurrentAction_4_0; }
		
		//'current'
		public Keyword getCurrentKeyword_4_1() { return cCurrentKeyword_4_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_4_2() { return cExpressionAssignment_4_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_4_2_0() { return cExpressionPrimaryParserRuleCall_4_2_0; }
		
		//AtomicExpression
		public RuleCall getAtomicExpressionParserRuleCall_5() { return cAtomicExpressionParserRuleCall_5; }
	}
	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AtomicExpression Expression:
		//	ConstantExpression | VariableReference;
		@Override public ParserRule getRule() { return rule; }
		
		//ConstantExpression | VariableReference
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ConstantExpression
		public RuleCall getConstantExpressionParserRuleCall_0() { return cConstantExpressionParserRuleCall_0; }
		
		//VariableReference
		public RuleCall getVariableReferenceParserRuleCall_1() { return cVariableReferenceParserRuleCall_1; }
	}
	public class VariableReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.VariableReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableReferenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cValueVariable_DeclarationCrossReference_1_0 = (CrossReference)cValueAssignment_1.eContents().get(0);
		private final RuleCall cValueVariable_DeclarationIDENTTerminalRuleCall_1_0_1 = (RuleCall)cValueVariable_DeclarationCrossReference_1_0.eContents().get(1);
		
		//VariableReference:
		//	{VariableReference} value=[Variable_Declaration|IDENT];
		@Override public ParserRule getRule() { return rule; }
		
		//{VariableReference} value=[Variable_Declaration|IDENT]
		public Group getGroup() { return cGroup; }
		
		//{VariableReference}
		public Action getVariableReferenceAction_0() { return cVariableReferenceAction_0; }
		
		//value=[Variable_Declaration|IDENT]
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//[Variable_Declaration|IDENT]
		public CrossReference getValueVariable_DeclarationCrossReference_1_0() { return cValueVariable_DeclarationCrossReference_1_0; }
		
		//IDENT
		public RuleCall getValueVariable_DeclarationIDENTTerminalRuleCall_1_0_1() { return cValueVariable_DeclarationIDENTTerminalRuleCall_1_0_1; }
	}
	public class ConstantExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ConstantExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBoolConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueBOOLTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cFloatConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueFLOATTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cIntConstantAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		
		//ConstantExpression Expression:
		//	{BoolConstant} value=BOOL
		//	| {FloatConstant} value=FLOAT
		//	| {IntConstant} value=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//{BoolConstant} value=BOOL | {FloatConstant} value=FLOAT | {IntConstant} value=INT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BoolConstant} value=BOOL
		public Group getGroup_0() { return cGroup_0; }
		
		//{BoolConstant}
		public Action getBoolConstantAction_0_0() { return cBoolConstantAction_0_0; }
		
		//value=BOOL
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//BOOL
		public RuleCall getValueBOOLTerminalRuleCall_0_1_0() { return cValueBOOLTerminalRuleCall_0_1_0; }
		
		//{FloatConstant} value=FLOAT
		public Group getGroup_1() { return cGroup_1; }
		
		//{FloatConstant}
		public Action getFloatConstantAction_1_0() { return cFloatConstantAction_1_0; }
		
		//value=FLOAT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//FLOAT
		public RuleCall getValueFLOATTerminalRuleCall_1_1_0() { return cValueFLOATTerminalRuleCall_1_1_0; }
		
		//{IntConstant} value=INT
		public Group getGroup_2() { return cGroup_2; }
		
		//{IntConstant}
		public Action getIntConstantAction_2_0() { return cIntConstantAction_2_0; }
		
		//value=INT
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_2_1_0() { return cValueINTTerminalRuleCall_2_1_0; }
	}
	public class IdentRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.IdentRef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDENTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cIDENTTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cColonColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cIDENTTerminalRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//IdentRef:
		//	IDENT | IDENT '::' IDENT;
		@Override public ParserRule getRule() { return rule; }
		
		//IDENT | IDENT '::' IDENT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IDENT
		public RuleCall getIDENTTerminalRuleCall_0() { return cIDENTTerminalRuleCall_0; }
		
		//IDENT '::' IDENT
		public Group getGroup_1() { return cGroup_1; }
		
		//IDENT
		public RuleCall getIDENTTerminalRuleCall_1_0() { return cIDENTTerminalRuleCall_1_0; }
		
		//'::'
		public Keyword getColonColonKeyword_1_1() { return cColonColonKeyword_1_1; }
		
		//IDENT
		public RuleCall getIDENTTerminalRuleCall_1_2() { return cIDENTTerminalRuleCall_1_2; }
	}
	
	
	private final LustreProgramElements pLustreProgram;
	private final IncludeElements pInclude;
	private final PackBodyElements pPackBody;
	private final ConstantsDeclarationElements pConstantsDeclaration;
	private final TypeDeclarationElements pTypeDeclaration;
	private final TypeElements pType;
	private final EnumTypeElements pEnumType;
	private final StructTypeElements pStructType;
	private final ExternalNodeDeclarationElements pExternalNodeDeclaration;
	private final NodeDeclarationElements pNodeDeclaration;
	private final ParamsElements pParams;
	private final StaticParamElements pStaticParam;
	private final StaticArgElements pStaticArg;
	private final ByNameStaticArgElements pByNameStaticArg;
	private final LustreTypedIdElements pLustreTypedId;
	private final LustreTypedValuedIdsElements pLustreTypedValuedIds;
	private final LustreClockedIdDeclarationElements pLustreClockedIdDeclaration;
	private final LustreExpressionElements pLustreExpression;
	private final ClockExpressionElements pClockExpression;
	private final PackListElements pPackList;
	private final ModelDeclarationElements pModelDeclaration;
	private final ProvideElements pProvide;
	private final PackageDeclarationElements pPackageDeclaration;
	private final PackageEquationElements pPackageEquation;
	private final Package_ProvidedElements pPackage_Provided;
	private final Package_Provided_IOElements pPackage_Provided_IO;
	private final Entity_DeclarationElements pEntity_Declaration;
	private final Array_TypeElements pArray_Type;
	private final Record_TypeElements pRecord_Type;
	private final FieldElements pField;
	private final Constant_DeclarationElements pConstant_Declaration;
	private final Variable_DeclarationElements pVariable_Declaration;
	private final Local_Variable_DeclarationElements pLocal_Variable_Declaration;
	private final Local_Constant_DeclarationElements pLocal_Constant_Declaration;
	private final EquationElements pEquation;
	private final AssertionElements pAssertion;
	private final AutomatonElements pAutomaton;
	private final AStateElements pAState;
	private final ATransitionElements pATransition;
	private final Left_PartElements pLeft_Part;
	private final Left_ListElements pLeft_List;
	private final LeftElements pLeft;
	private final SelectorElements pSelector;
	private final SelTrancheEndElements pSelTrancheEnd;
	private final Right_PartElements pRight_Part;
	private final ExpressionElements pExpression;
	private final FbyElements pFby;
	private final ArrowElements pArrow;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final EqualityElements pEquality;
	private final ComparisonElements pComparison;
	private final ModElements pMod;
	private final PlusOrMinusElements pPlusOrMinus;
	private final MulOrDivElements pMulOrDiv;
	private final PrimaryElements pPrimary;
	private final AtomicExpressionElements pAtomicExpression;
	private final VariableReferenceElements pVariableReference;
	private final ConstantExpressionElements pConstantExpression;
	private final IdentRefElements pIdentRef;
	private final TerminalRule tBOOL;
	private final TerminalRule tIDENT;
	private final TerminalRule tINT;
	private final TerminalRule tFLOAT;
	private final TerminalRule tSTRING_CONSTANT;
	private final TerminalRule tLUSTRE_COMMENT;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	
	private final Grammar grammar;

	@Inject
	public LustreGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pLustreProgram = new LustreProgramElements();
		this.pInclude = new IncludeElements();
		this.pPackBody = new PackBodyElements();
		this.pConstantsDeclaration = new ConstantsDeclarationElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pType = new TypeElements();
		this.pEnumType = new EnumTypeElements();
		this.pStructType = new StructTypeElements();
		this.pExternalNodeDeclaration = new ExternalNodeDeclarationElements();
		this.pNodeDeclaration = new NodeDeclarationElements();
		this.pParams = new ParamsElements();
		this.pStaticParam = new StaticParamElements();
		this.pStaticArg = new StaticArgElements();
		this.pByNameStaticArg = new ByNameStaticArgElements();
		this.pLustreTypedId = new LustreTypedIdElements();
		this.pLustreTypedValuedIds = new LustreTypedValuedIdsElements();
		this.pLustreClockedIdDeclaration = new LustreClockedIdDeclarationElements();
		this.pLustreExpression = new LustreExpressionElements();
		this.pClockExpression = new ClockExpressionElements();
		this.pPackList = new PackListElements();
		this.pModelDeclaration = new ModelDeclarationElements();
		this.pProvide = new ProvideElements();
		this.pPackageDeclaration = new PackageDeclarationElements();
		this.pPackageEquation = new PackageEquationElements();
		this.pPackage_Provided = new Package_ProvidedElements();
		this.pPackage_Provided_IO = new Package_Provided_IOElements();
		this.pEntity_Declaration = new Entity_DeclarationElements();
		this.pArray_Type = new Array_TypeElements();
		this.pRecord_Type = new Record_TypeElements();
		this.pField = new FieldElements();
		this.pConstant_Declaration = new Constant_DeclarationElements();
		this.pVariable_Declaration = new Variable_DeclarationElements();
		this.pLocal_Variable_Declaration = new Local_Variable_DeclarationElements();
		this.pLocal_Constant_Declaration = new Local_Constant_DeclarationElements();
		this.pEquation = new EquationElements();
		this.pAssertion = new AssertionElements();
		this.pAutomaton = new AutomatonElements();
		this.pAState = new AStateElements();
		this.pATransition = new ATransitionElements();
		this.pLeft_Part = new Left_PartElements();
		this.pLeft_List = new Left_ListElements();
		this.pLeft = new LeftElements();
		this.pSelector = new SelectorElements();
		this.pSelTrancheEnd = new SelTrancheEndElements();
		this.pRight_Part = new Right_PartElements();
		this.pExpression = new ExpressionElements();
		this.pFby = new FbyElements();
		this.pArrow = new ArrowElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pEquality = new EqualityElements();
		this.pComparison = new ComparisonElements();
		this.pMod = new ModElements();
		this.pPlusOrMinus = new PlusOrMinusElements();
		this.pMulOrDiv = new MulOrDivElements();
		this.pPrimary = new PrimaryElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.pVariableReference = new VariableReferenceElements();
		this.pConstantExpression = new ConstantExpressionElements();
		this.pIdentRef = new IdentRefElements();
		this.tBOOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.BOOL");
		this.tIDENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.IDENT");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.INT");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.FLOAT");
		this.tSTRING_CONSTANT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.STRING_CONSTANT");
		this.tLUSTRE_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.LUSTRE_COMMENT");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.lustre.Lustre.WS");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.cau.cs.kieler.lustre.Lustre".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//LustreProgram hidden(WS, LUSTRE_COMMENT):
	//	includes+=Include* (packBody=PackBody | packList=PackList);
	public LustreProgramElements getLustreProgramAccess() {
		return pLustreProgram;
	}
	
	public ParserRule getLustreProgramRule() {
		return getLustreProgramAccess().getRule();
	}
	
	///*
	// * ---------- Include
	// */ Include:
	//	'include' STRING_CONSTANT;
	public IncludeElements getIncludeAccess() {
		return pInclude;
	}
	
	public ParserRule getIncludeRule() {
		return getIncludeAccess().getRule();
	}
	
	///*
	// * ---------- PackBody
	// */ PackBody:
	//	(constants+=ConstantsDeclaration
	//	| 'type' types+=TypeDeclaration+ | externals+=ExternalNodeDeclaration
	//	| nodes+=NodeDeclaration)+;
	public PackBodyElements getPackBodyAccess() {
		return pPackBody;
	}
	
	public ParserRule getPackBodyRule() {
		return getPackBodyAccess().getRule();
	}
	
	//ConstantsDeclaration:
	//	'const'
	//	constants+=LustreTypedValuedIds ';' (constants+=LustreTypedValuedIds ';')*;
	public ConstantsDeclarationElements getConstantsDeclarationAccess() {
		return pConstantsDeclaration;
	}
	
	public ParserRule getConstantsDeclarationRule() {
		return getConstantsDeclarationAccess().getRule();
	}
	
	//TypeDeclaration:
	//	name=IDENT ('=' (types=Type
	//	| enums=EnumType
	//	| struct=StructType))?
	//	';';
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}
	
	//Type:
	//	(name='bool'
	//	| name='int'
	//	| name='real'
	//	| name=IDENT) ('^' arraySize+=LustreExpression)*;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//EnumType:
	//	'enum' '{' values+=IDENT (',' values+=IDENT)* '}';
	public EnumTypeElements getEnumTypeAccess() {
		return pEnumType;
	}
	
	public ParserRule getEnumTypeRule() {
		return getEnumTypeAccess().getRule();
	}
	
	//StructType:
	//	'struct'? '{' elements+=LustreTypedValuedIds (';' elements+=LustreTypedValuedIds)* ';'? '}';
	public StructTypeElements getStructTypeAccess() {
		return pStructType;
	}
	
	public ParserRule getStructTypeRule() {
		return getStructTypeAccess().getRule();
	}
	
	//// External Node Declaration
	//ExternalNodeDeclaration:
	//	isUnsafe?='unsafe'? 'extern' ('function' | hasState?='node') name=IDENT
	//	input=Params
	//	'returns'
	//	output=Params
	//	';'?;
	public ExternalNodeDeclarationElements getExternalNodeDeclarationAccess() {
		return pExternalNodeDeclaration;
	}
	
	public ParserRule getExternalNodeDeclarationRule() {
		return getExternalNodeDeclarationAccess().getRule();
	}
	
	//// Node Declaration
	//NodeDeclaration:
	//	isUnsafe?='unsafe'? ('function' | hasState?='node') name=IDENT ('<<' staticParams+=StaticParam (';'
	//	staticParams+=StaticParam)* '>>')? (input=Params 'returns' output=Params ('=' effectiveNode=IdentRef ('<<'
	//	staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')? | ';'? (constants+=ConstantsDeclaration | 'var'
	//	variables+=LustreClockedIdDeclaration (';' variables+=LustreClockedIdDeclaration)* ';')*
	//	// Body 
	//	'let' (equations+=Equation
	//	| assertions+=Assertion
	//	| automatons+=Automaton)*
	//	'tel' ('.' | ';'?)) | // --- Effective Node (without interface)
	//	'=' effectiveNode=IdentRef ('<<' staticArgs+=StaticArg (';' staticArgs+=StaticArg)* '>>')?);
	public NodeDeclarationElements getNodeDeclarationAccess() {
		return pNodeDeclaration;
	}
	
	public ParserRule getNodeDeclarationRule() {
		return getNodeDeclarationAccess().getRule();
	}
	
	//Params:
	//	{Params}
	//	'(' (parameter+=LustreClockedIdDeclaration (';' parameter+=LustreClockedIdDeclaration)*)? ')';
	public ParamsElements getParamsAccess() {
		return pParams;
	}
	
	public ParserRule getParamsRule() {
		return getParamsAccess().getRule();
	}
	
	//StaticParam:
	//	'type' name=IDENT
	//	| 'const' name=IDENT ':' type=Type
	//	| 'unsafe'? ('node' | 'function') name=IDENT nodeInput=Params 'returns' nodeOutput=Params;
	public StaticParamElements getStaticParamAccess() {
		return pStaticParam;
	}
	
	public ParserRule getStaticParamRule() {
		return getStaticParamAccess().getRule();
	}
	
	//StaticArg:
	//	'type' type=Type
	//	| 'const' expr=LustreExpression
	//	| ('node' | 'function') name=IdentRef ('<<' staticArgs+=StaticArg ((';' | ',') staticArgs+=StaticArg)* '>>')?
	//	//    | PredefOp
	//	//    | SimpleExpr
	//	//    | SurelyType
	//	//    | SurelyNode
	//;
	public StaticArgElements getStaticArgAccess() {
		return pStaticArg;
	}
	
	public ParserRule getStaticArgRule() {
		return getStaticArgAccess().getRule();
	}
	
	//ByNameStaticArg:
	//	'type' name=IDENT '=' type=Type | 'const' name=IDENT '=' expr=LustreExpression | ('function' | 'node') name=IDENT '='
	//	nodeRef=IdentRef ('<<' staticArgs+=StaticArg ((';' | ',') staticArgs+=StaticArg)* '>>')? | name=IDENT '=';
	public ByNameStaticArgElements getByNameStaticArgAccess() {
		return pByNameStaticArg;
	}
	
	public ParserRule getByNameStaticArgRule() {
		return getByNameStaticArgAccess().getRule();
	}
	
	//// --------------------------
	//LustreTypedId:
	//	variableNames+=IDENT (',' variableNames+=IDENT)* ':' type=Type;
	public LustreTypedIdElements getLustreTypedIdAccess() {
		return pLustreTypedId;
	}
	
	public ParserRule getLustreTypedIdRule() {
		return getLustreTypedIdAccess().getRule();
	}
	
	//LustreTypedValuedIds:
	//	variableNames+=IDENT ((',' variableNames+=IDENT)* ':' type=Type? ('=' value=LustreExpression)? | '='
	//	value=LustreExpression);
	public LustreTypedValuedIdsElements getLustreTypedValuedIdsAccess() {
		return pLustreTypedValuedIds;
	}
	
	public ParserRule getLustreTypedValuedIdsRule() {
		return getLustreTypedValuedIdsAccess().getRule();
	}
	
	//LustreClockedIdDeclaration:
	//	typedIds+=LustreTypedId ('when' clockExpr=ClockExpression)? | '(' typedIds+=LustreTypedId (';'
	//	typedIds+=LustreTypedId)* ')' 'when' clockExpr=ClockExpression;
	public LustreClockedIdDeclarationElements getLustreClockedIdDeclarationAccess() {
		return pLustreClockedIdDeclaration;
	}
	
	public ParserRule getLustreClockedIdDeclarationRule() {
		return getLustreClockedIdDeclarationAccess().getRule();
	}
	
	//LustreExpression:
	//	Expression;
	public LustreExpressionElements getLustreExpressionAccess() {
		return pLustreExpression;
	}
	
	public ParserRule getLustreExpressionRule() {
		return getLustreExpressionAccess().getRule();
	}
	
	//ClockExpression:
	//	IdentRef '(' IDENT ')' | IDENT
	//	| 'not' IDENT
	//	| '(' 'not' ')' IDENT;
	public ClockExpressionElements getClockExpressionAccess() {
		return pClockExpression;
	}
	
	public ParserRule getClockExpressionRule() {
		return getClockExpressionAccess().getRule();
	}
	
	///*
	// * ---------- PackList
	// */ PackList:
	//	(modelDeclarations+=ModelDeclaration
	//	| packageDeclarations+=PackageDeclaration
	//	| packageEquations+=PackageEquation)+;
	public PackListElements getPackListAccess() {
		return pPackList;
	}
	
	public ParserRule getPackListRule() {
		return getPackListAccess().getRule();
	}
	
	//ModelDeclaration:
	//	'model' name=IDENT ('uses' usesIds+=IDENT (',' usesIds+=IDENT)* ';')?
	//	'needs' needsParams+=StaticParam (';' needsParams+=StaticParam)* ';' ('provides' provisions+=Provide ';'
	//	(provisions+=Provide ';')*)?
	//	'body'
	//	body=PackBody
	//	'end';
	public ModelDeclarationElements getModelDeclarationAccess() {
		return pModelDeclaration;
	}
	
	public ParserRule getModelDeclarationRule() {
		return getModelDeclarationAccess().getRule();
	}
	
	//Provide:
	//	'const' name=IDENT ':' type=Type ('=' value=LustreExpression)?
	//	| 'type' types=TypeDeclaration
	//	| 'unsafe'? ('node' | 'function') name=IDENT ('<<' staticParams+=StaticParam (';' staticParams+=StaticParam)* '>>')?
	//	input=Params 'returns' output=Params;
	public ProvideElements getProvideAccess() {
		return pProvide;
	}
	
	public ParserRule getProvideRule() {
		return getProvideAccess().getRule();
	}
	
	//PackageDeclaration:
	//	'package' name=IDENT ('uses' usesIds+=IDENT (',' usesIds+=IDENT)* ';')? ('provides' provisions+=Provide ';'
	//	(provisions+=Provide ';')*)?
	//	'body'
	//	body=PackBody
	//	'end';
	public PackageDeclarationElements getPackageDeclarationAccess() {
		return pPackageDeclaration;
	}
	
	public ParserRule getPackageDeclarationRule() {
		return getPackageDeclarationAccess().getRule();
	}
	
	//PackageEquation:
	//	'package' name=IDENT
	//	// Eq_or_Is
	//	eqOrIs=IDENT
	//	'(' byNameStaticArgs+=ByNameStaticArg ((',' | ';') byNameStaticArgs+=ByNameStaticArg)* ')' ';';
	public PackageEquationElements getPackageEquationAccess() {
		return pPackageEquation;
	}
	
	public ParserRule getPackageEquationRule() {
		return getPackageEquationAccess().getRule();
	}
	
	//// --------------------------------------------------------- Old stuff
	///**
	// * @author cpa
	// */ //LustreProgram hidden(WS, LUSTRE_COMMENT):
	////    nodes += Node_Declaration+    
	//////    packages+=Package_Declaration+   
	////;
	///*
	// * Packages
	// */ //Package_Declaration:
	////    'package' name=IDENT 
	////        ('uses' uses+=IDENT (',' uses+=IDENT)*)? 
	////        'provides' provides+=Package_Provided+
	////    'body'
	////    (
	////        nodes+=Node_Declaration |
	////        types+=Type_Declaration |
	////        constants+=Constant_Declaration
	////    )*
	////    'end'
	////;
	//Package_Provided:
	//	'node' name=[NodeDeclaration|IDENT]
	//	'(' (parameters+=Package_Provided_IO (',' parameters+=Package_Provided_IO)*)? ')'
	//	'returns' '(' returned+=Package_Provided_IO (',' returned+=Package_Provided_IO)* ')'
	//	';';
	public Package_ProvidedElements getPackage_ProvidedAccess() {
		return pPackage_Provided;
	}
	
	public ParserRule getPackage_ProvidedRule() {
		return getPackage_ProvidedAccess().getRule();
	}
	
	//Package_Provided_IO:
	//	name=[Variable_Declaration|IDENT] ':' type=IDENT;
	public Package_Provided_IOElements getPackage_Provided_IOAccess() {
		return pPackage_Provided_IO;
	}
	
	public ParserRule getPackage_Provided_IORule() {
		return getPackage_Provided_IOAccess().getRule();
	}
	
	//Entity_Declaration:
	//	Constant_Declaration;
	public Entity_DeclarationElements getEntity_DeclarationAccess() {
		return pEntity_Declaration;
	}
	
	public ParserRule getEntity_DeclarationRule() {
		return getEntity_DeclarationAccess().getRule();
	}
	
	///*
	// * Identifiers
	// */ //Identifier:
	////    (package=[Package | IDENT] '::')? name=[Variable_Declaration | IDENT] | name=[Node_Declaration | IDENT];
	///* 
	// * Types
	// */ //Type_Declaration:
	////    'type' name=IDENT ';'
	////    | 'type' name=IDENT '=' type=Type  ';'
	////;
	////Type:
	////    name=IDENT
	//////    | Array_Type
	//////    | Record_Type
	//////    | Enum_Type
	////;
	//Array_Type:
	//	type=[TypeDeclaration|IDENT] '^' length=INT
	//	// XXX Original Lustre allows Type^Expression  
	//;
	public Array_TypeElements getArray_TypeAccess() {
		return pArray_Type;
	}
	
	public ParserRule getArray_TypeRule() {
		return getArray_TypeAccess().getRule();
	}
	
	//Record_Type:
	//	'struct' '{' fields+=Field (',' fields+=Field)* '}';
	public Record_TypeElements getRecord_TypeAccess() {
		return pRecord_Type;
	}
	
	public ParserRule getRecord_TypeRule() {
		return getRecord_TypeAccess().getRule();
	}
	
	//Field:
	//	name=IDENT ':' type=[Type|IDENT];
	public FieldElements getFieldAccess() {
		return pField;
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}
	
	////Enum_Type:
	////    'enum' '{' nameList=Ident_List '}'
	////;
	///*
	// * Constants and variables
	// */ Constant_Declaration:
	//	'const' name=IDENT ':' type=Type ';'
	//	| 'const' name=IDENT '=' expr=ConstantExpression ';'
	//	| 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
	//	// XXX Original Lustre allows Expressions
	//;
	public Constant_DeclarationElements getConstant_DeclarationAccess() {
		return pConstant_Declaration;
	}
	
	public ParserRule getConstant_DeclarationRule() {
		return getConstant_DeclarationAccess().getRule();
	}
	
	//Variable_Declaration:
	//	name=IDENT ':' type=Type ('when' clock=IDENT)?;
	public Variable_DeclarationElements getVariable_DeclarationAccess() {
		return pVariable_Declaration;
	}
	
	public ParserRule getVariable_DeclarationRule() {
		return getVariable_DeclarationAccess().getRule();
	}
	
	//Local_Variable_Declaration Variable_Declaration:
	//	'var' Variable_Declaration ';';
	public Local_Variable_DeclarationElements getLocal_Variable_DeclarationAccess() {
		return pLocal_Variable_Declaration;
	}
	
	public ParserRule getLocal_Variable_DeclarationRule() {
		return getLocal_Variable_DeclarationAccess().getRule();
	}
	
	//Local_Constant_Declaration Constant_Declaration:
	//	{Constant_Declaration} 'const' name=IDENT '=' expr=ConstantExpression ';'
	//	| {Constant_Declaration} 'const' name=IDENT ':' type=Type '=' expr=ConstantExpression ';'
	//	// XXX Original Lustre allows Expressions
	//;
	public Local_Constant_DeclarationElements getLocal_Constant_DeclarationAccess() {
		return pLocal_Constant_Declaration;
	}
	
	public ParserRule getLocal_Constant_DeclarationRule() {
		return getLocal_Constant_DeclarationAccess().getRule();
	}
	
	///*
	// * Nodes
	// */ //Node_Declaration:
	////    'node'  
	////        name=IDENT 
	////        '(' (parameters+=Variable_Declaration (',' parameters+=Variable_Declaration)*)? ')' 
	////        'returns' '(' returned+=Variable_Declaration (',' returned+=Variable_Declaration)* ')' 
	////    ';'
	////    (
	////        constants+=Local_Constant_Declaration |
	////        variables+=Local_Variable_Declaration
	////    )* 
	////    'let' 
	////    (
	////        equations+=Equation | 
	////        assertions+=Assertion |
	////        automatons+=Automaton
	////    )*
	////    'tel' ';'?
	////;
	//Equation:
	//	left=[LustreTypedId|IDENT] '=' right=Right_Part ';'
	//	| left=[LustreTypedValuedIds|IDENT] '=' right=Right_Part ';'
	//	| left=[LustreClockedIdDeclaration|IDENT] '=' right=Right_Part ';';
	public EquationElements getEquationAccess() {
		return pEquation;
	}
	
	public ParserRule getEquationRule() {
		return getEquationAccess().getRule();
	}
	
	//Assertion:
	//	'assert' Expression ';';
	public AssertionElements getAssertionAccess() {
		return pAssertion;
	}
	
	public ParserRule getAssertionRule() {
		return getAssertionAccess().getRule();
	}
	
	//Automaton:
	//	'automaton' states+=AState ('|' states+=AState)* 'end' ';';
	public AutomatonElements getAutomatonAccess() {
		return pAutomaton;
	}
	
	public ParserRule getAutomatonRule() {
		return getAutomatonAccess().getRule();
	}
	
	//AState:
	//	name=IDENT '->' (equations+=Equation | assertions+=Assertion | automatons+=Automaton)*
	//	transitions+=ATransition+;
	public AStateElements getAStateAccess() {
		return pAState;
	}
	
	public ParserRule getAStateRule() {
		return getAStateAccess().getRule();
	}
	
	//ATransition:
	//	('until' | strong?='unless') condition=Expression ('then' | history?='continue') nextState=[AState|IDENT] ';';
	public ATransitionElements getATransitionAccess() {
		return pATransition;
	}
	
	public ParserRule getATransitionRule() {
		return getATransitionAccess().getRule();
	}
	
	//Left_Part:
	//	'(' Left_List ')'
	//	| Left_List;
	public Left_PartElements getLeft_PartAccess() {
		return pLeft_Part;
	}
	
	public ParserRule getLeft_PartRule() {
		return getLeft_PartAccess().getRule();
	}
	
	//Left_List:
	//	id+=Left (',' id+=Left)*;
	public Left_ListElements getLeft_ListAccess() {
		return pLeft_List;
	}
	
	public ParserRule getLeft_ListRule() {
		return getLeft_ListAccess().getRule();
	}
	
	//Left:
	//	name=IDENT selector=Selector?;
	public LeftElements getLeftAccess() {
		return pLeft;
	}
	
	public ParserRule getLeftRule() {
		return getLeftAccess().getRule();
	}
	
	//Selector:
	//	'.' name=IDENT
	//	| '[' begin=Expression end=SelTrancheEnd? ']';
	public SelectorElements getSelectorAccess() {
		return pSelector;
	}
	
	public ParserRule getSelectorRule() {
		return getSelectorAccess().getRule();
	}
	
	//SelTrancheEnd Expression:
	//	'..' Expression;
	public SelTrancheEndElements getSelTrancheEndAccess() {
		return pSelTrancheEnd;
	}
	
	public ParserRule getSelTrancheEndRule() {
		return getSelTrancheEndAccess().getRule();
	}
	
	//Right_Part Expression:
	//	Expression;
	public Right_PartElements getRight_PartAccess() {
		return pRight_Part;
	}
	
	public ParserRule getRight_PartRule() {
		return getRight_PartAccess().getRule();
	}
	
	///*
	// * Expressions
	// */ Expression:
	//	{IfThenElse} 'if' ifexpr=Expression 'then' thenexpr=Expression 'else' elseexpr=Expression
	//	| Fby;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//Fby Expression:
	//	Arrow ({Fby.subExpressions+=current} ('fby' subExpressions+=Arrow)+)?;
	public FbyElements getFbyAccess() {
		return pFby;
	}
	
	public ParserRule getFbyRule() {
		return getFbyAccess().getRule();
	}
	
	//Arrow Expression:
	//	Or ({Arrow.subExpressions+=current} ('->' subExpressions+=Or)+)?;
	public ArrowElements getArrowAccess() {
		return pArrow;
	}
	
	public ParserRule getArrowRule() {
		return getArrowAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.subExpressions+=current} ('or' subExpressions+=And)+)?;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Equality ({And.subExpressions+=current} ('and' subExpressions+=Equality)+)?;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Equality Expression:
	//	Comparison ({Equality.left=current} op=('=' | '<>') right=Comparison)*;
	public EqualityElements getEqualityAccess() {
		return pEquality;
	}
	
	public ParserRule getEqualityRule() {
		return getEqualityAccess().getRule();
	}
	
	//Comparison Expression:
	//	Mod ({Comparison.left=current} op=('>=' | '<=' | '>' | '<') right=Mod)*;
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//Mod Expression:
	//	PlusOrMinus ({Mod.subExpressions+=current} 'mod' subExpressions+=PlusOrMinus)*;
	public ModElements getModAccess() {
		return pMod;
	}
	
	public ParserRule getModRule() {
		return getModAccess().getRule();
	}
	
	//PlusOrMinus Expression:
	//	MulOrDiv (({Plus.subExpressions+=current} '+' | {Minus.subExpressions+=current} '-') subExpressions+=MulOrDiv)*;
	public PlusOrMinusElements getPlusOrMinusAccess() {
		return pPlusOrMinus;
	}
	
	public ParserRule getPlusOrMinusRule() {
		return getPlusOrMinusAccess().getRule();
	}
	
	//MulOrDiv Expression:
	//	Primary (({Mul.subExpressions+=current} '*' | {Div.subExpressions+=current} '/') subExpressions+=Primary)*;
	public MulOrDivElements getMulOrDivAccess() {
		return pMulOrDiv;
	}
	
	public ParserRule getMulOrDivRule() {
		return getMulOrDivAccess().getRule();
	}
	
	//Primary Expression:
	//	'(' Expression ')'
	//	| {Not} 'not' expression=Primary
	//	| {UMinus} '-' expression=Primary
	//	| {Pre} 'pre' expression=Primary
	//	| {Current} 'current' expression=Primary
	//	| AtomicExpression;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//AtomicExpression Expression:
	//	ConstantExpression | VariableReference;
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}
	
	//VariableReference:
	//	{VariableReference} value=[Variable_Declaration|IDENT];
	public VariableReferenceElements getVariableReferenceAccess() {
		return pVariableReference;
	}
	
	public ParserRule getVariableReferenceRule() {
		return getVariableReferenceAccess().getRule();
	}
	
	//ConstantExpression Expression:
	//	{BoolConstant} value=BOOL
	//	| {FloatConstant} value=FLOAT
	//	| {IntConstant} value=INT;
	public ConstantExpressionElements getConstantExpressionAccess() {
		return pConstantExpression;
	}
	
	public ParserRule getConstantExpressionRule() {
		return getConstantExpressionAccess().getRule();
	}
	
	//IdentRef:
	//	IDENT | IDENT '::' IDENT;
	public IdentRefElements getIdentRefAccess() {
		return pIdentRef;
	}
	
	public ParserRule getIdentRefRule() {
		return getIdentRefAccess().getRule();
	}
	
	//terminal BOOL returns ecore::EBoolean:
	//	'true' | 'false';
	public TerminalRule getBOOLRule() {
		return tBOOL;
	}
	
	//terminal IDENT:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDENTRule() {
		return tIDENT;
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal FLOAT returns ecore::EFloat:
	//	'0'..'9'+ '.' '0'..'9'*
	//	| '.' '0'..'9'+;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	}
	
	//terminal STRING_CONSTANT:
	//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"' |
	//	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | "'"))* "'";
	public TerminalRule getSTRING_CONSTANTRule() {
		return tSTRING_CONSTANT;
	}
	
	//terminal LUSTRE_COMMENT:
	//	ML_COMMENT | SL_COMMENT;
	public TerminalRule getLUSTRE_COMMENTRule() {
		return tLUSTRE_COMMENT;
	}
	
	//terminal ML_COMMENT:
	//	'(*'->'*)';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'--' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
}
