grammar de.cau.kieler.scc.model.scctext.SCCExp with org.yakindu.sct.model.stext.SText

generate sccexp "http://cau.kieler.de/scc/SCCExp"
import "http://www.yakindu.org/sct/statechart/SText" as stext
import "http://www.yakindu.org/sct/sgraph/2.0.0" as sgraph
import "http://www.yakindu.org/base/types/2.0.0" as types

/************************************************/
/*			Overriding State grammar 			*/
/************************************************/
StateSpecification:
	(scopes+=StateScope)*;
	
//defines the possible scopes for a state
StateScope returns sgraph::Scope:
	InterfaceScope | ReactionScope;

/*********************************** INTERFACE DECLARATION **************************************** */	
/************************************************/
/*			  INTERFACE DECLARATION				*/
/************************************************/
//overwrite the SText InterfaceScope rule
// The InterfaceScope rule specifies that a InterfaceScope starts with 
// the literal 'interface :', followed by one or more interface declaration variables
InterfaceScope:
	{InterfaceScope} 'interface' ':' declarations+=Declaration (','
	declarations+=Declaration)* ';';

/**
 * Declaration
 */
// Overwrite the rule Declaration
// The InterfaceVariableDeclaration is an abstract rule.
// It specifies that a Declaration may either be a 
// VariableDefinition or an OperationDeclaration
Declaration returns sgraph::Declaration:
	VariableDefinition | OperationDeclaration;
/**
 * Variable Definition
 */	
// Overwrite the SText VariableDefinition rule
// A variable is a Declaration. It has a Direction, a Name, a Type, an InitialValue and a CombineOperator
VariableDefinition:
	direction=VarDirection? isStatic?='static' varName=ID ':' varType=[types::Type|FQN] ('='
	varInitialValue=Expression)? ('with' varCombineOperator=CombineOperator)?;

/************************************************/
/*			 	ReactionScope					*/
/************************************************/
ReactionScope:
	reactionScope+=(EntryAction | InsideAction | ExitAction | Suspend);

ExitAction returns sgraph::Effect:
	{ExitAction} 'Exit' ':' '/' effect=Effect ';';

InsideAction returns sgraph::Effect:
	{InsideAction} 'Inside' ':' '/' effect=Effect ';';

EntryAction returns sgraph::Effect:
	{EntryAction} 'Entry' ':' '/' effect=Effect ';';

/************************************************/
/*			 		SUSPEND 					*/
/************************************************/
// The  SuspendDeclaration is a Trigger
//TODO: only variables already declared in the interface 
Suspend returns sgraph::Trigger:
	{Suspend} 'Suspend' ':' trigger=Trigger ';';

/******************************************** TRANSITION ***************************************** */
Reaction returns sgraph::Reaction:
	 Transition;

// The TransitionReaction is a Reaction and has an optional trigger and an optional effect 
Transition:
	{Transition} (trigger=Trigger)? ('/' effect=Effect)?;
	
// The ReactionTrigger is a Trigger and has an Expression, 
// an optional delay and isImmediate option represented with a '#'
Trigger returns sgraph::Trigger:
	{Trigger} (isImmediate?='#')? (delay=INT)? '('expression=Expression ')';

// The ReactionEffect is an Effect. 
Effect returns sgraph::Effect:
	{Effect} actions+=(Expression | EventRaisingExpression) (=> ';' actions+=(Expression |
	EventRaisingExpression))*; // (';')?;


/***************************************** COMBINE OPERATORS ************************************* */
enum CombineOperator returns CombineOperator:
	NONE="'none'" | ADD="'+'" | MULT="'*'" | MAX="'max'" |
	MIN="'min'" | OR="'or'" | AND="'and'" | HOST="'host'";
	
enum VarDirection:
	INOUT='inout' | IN='in' | OUT='out';