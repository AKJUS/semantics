grammar de.cau.kieler.scc.model.scctext.SCCExp with org.yakindu.sct.model.stext.SText

generate sccexp "http://cau.kieler.de/scc/SCCExp"
import "http://www.yakindu.org/sct/statechart/SText" as stext
import "http://www.yakindu.org/sct/sgraph/2.0.0" as sgraph
import "http://www.yakindu.org/base/types/2.0.0" as types
import "http://www.yakindu.org/base/base/2.0.0" as base

/* ---- root rules ----
These root rules are not relevant for the grammar integration in the statechart. They
just integrate the different start rules consistently
into a single grammar.
*/
Root:
	(roots+=DefRoot)*;

DefRoot:
	StateRoot | TransitionRoot;

StateRoot:
	'@@state@@' def=StateSpecification;

TransitionRoot:
	'@@transition@@' def=TransitionSpecification;

/************************************************/
/*			Overriding State grammar 			*/
/************************************************/
StateScope:
	InterfaceScopeRoot;

InterfaceScopeRoot:
	{InterfaceScopeRoot} (interfaceScope+=InterfaceScope)*;

InterfaceScope:
	InterfaceDeclaration | ActionDeclaration | SuspendDeclaration;

	/**
 *  The Interface Declaration
 */
InterfaceDeclaration:
	{InterfaceDeclaration} 'interface:' declaration+=(SCCVariableDeclaration) (','
	declaration+=(SCCVariableDeclaration))* ';';

SCCVariableDeclaration:
	InputVariableDeclaration | OutputVariableeclaration | InOutVariableDeclaration | LocalVariableDeclaration;

LocalVariableDeclaration:
	{Local} 'local' name=ID ':' type=[types::Type|FQN] ('='
	initialValue=Expression)? ('with' operator=CombineOperator)?;

InOutVariableDeclaration:
	{Input} 'in' name=ID ':' type=[types::Type|FQN] ('='
	initialValue=Expression)? ('with' operator=CombineOperator)?;

OutputVariableeclaration:
	{Output} 'out' name=ID ':' type=[types::Type|FQN] ('with' operator=CombineOperator)?;

InputVariableDeclaration:
	{InOut} 'inout' name=ID ':' type=[types::Type|FQN] ('='
	initialValue=Expression)? ('with' operator=CombineOperator)?;

enum CombineOperator returns CombineOperator:
	NONE="'none'" | ADD="'+'" | MULT="'*'" | MAX="'max'" |
	MIN="'min'" | OR="'or'" | AND="'and'" | HOST="'host'";

	/**
 *  The Action Declaration
 */
ActionDeclaration:
	EntryActionDeclaration | InsideActionDeclaration | ExitActionDeclaration;

ExitActionDeclaration:
	{ExitActionDeclaration} 'OnExitAction:' exitActionDeclaration+=ActionVariableDeclaration (','
	exitActionDeclaration+=ActionVariableDeclaration)* ';';

InsideActionDeclaration:
	{InsideActionDeclaration} 'OnInsideAction:' insideActionDeclaration+=ActionVariableDeclaration (','
	insideActionDeclaration+=ActionVariableDeclaration) ';';

EntryActionDeclaration:
	{EntryActionDeclaration} 'OnEntryAction:' entryActionDeclaration+=ActionVariableDeclaration (','
	entryActionDeclaration+=ActionVariableDeclaration) ';';

ActionVariableDeclaration:
	'/' name=ID;

	/**
 *  The Suspend Declaration
 */
SuspendDeclaration:
	{SuspendDeclaration} 'Suspend:' suspendDeclaration+=SuspendVariableDeclaration (','
	suspendDeclaration+=SuspendVariableDeclaration) ';';

SuspendVariableDeclaration:
	name=ID;

/************************************************/
/*		Overriding transition grammar 			*/
/************************************************/
TransitionReaction:
	{TransitionReaction} (trigger=MyTrigger)? ('/' effect=ReactionEffect)? ('#' properties=ReactionProperties)?;

MyTrigger returns sgraph::Trigger:
	{MyTrigger} 'some trigger expression';