grammar de.cau.cs.kieler.esterel.scest.SCEst with de.cau.cs.kieler.esterel.Esterel

generate scest "http://www.cau.de/cs/kieler/esterel/scest/SCEst"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions
import "http://kieler.cs.cau.de/keffects/0.1.0" as keffects
import "http://kieler.cs.cau.de/kext/0.1.0" as kext
import "http://kieler.cs.cau.de/scl/0.2.0" as scl
import "http://www.cau.de/cs/kieler/esterel/Esterel" as esterel

//  root rule. a SCEst file can contain multiple modules
SCEstProgram hidden(SL_COMMENT, ML_COMMENT, WS):
    (modules+=SCEstModule)*;


/* ###################################################
 * ###                 7.2 Modules                 ###
 * ###################################################
 */
   
 
// ==> module: a module consists of an interface and a body
// -------------------------------------
SCEstModule:
    {SCEstModule}
    (annotations += Annotation)*
    "module" name=ID ":" 
    (
        (     intSignalDecls+=InterfaceSignalDecl
            | intTypeDecls+=TypeDecl
            | intSensorDecls+=SensorDecl
            | intConstantDecls+=ConstantDecls
            | intRelationDecls+=RelationDecl
            | intTaskDecls+=TaskDecl
            | intFunctionDecls+=FunctionDecl
            | intProcedureDecls+=ProcedureDecl
        )* 
        ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )
        ("end" "module" | ".")
    
    | 
    
        (declarations+=Declaration)*
        '{'
        ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )
        '}' 
    );

/* ###################################################
 * ###               7.5 Statements                ###
 * ###################################################
 */
    
StatementContainerInterface returns scl::StatementContainer:
    SCEstModule | Conditional | ElseScope | Thread | ScopeStatement;    
    
// ==> Statement
// -------------------------------------
SCEstStatement returns scl::Statement:
    EsterelParallel | SCEstAtomicStatement;

// ==> Atomic Statements
// -------------------------------------
SCEstAtomicStatement returns scl::Statement:
    Abort | EsterelAssignment | Await | Block | ProcCall | Do | Emit | EveryDo | 
    Exit | Exec | Halt | IfTest | LocalSignalDecl | Loop | Nothing | Pause | Present | 
    Repeat | Run | Suspend | Sustain | Trap | LocalVariable | Goto | UnEmit | Set | 
    Assignment | Parallel | Conditional ;
        
// ==> Parallel: at least two threads
// -------------------------------------
EsterelParallel returns esterel::EsterelParallel:
    threads+=EsterelThread ("||" threads+=EsterelThread)+;

// ==> Thread
// One AtomicStatement or multiple AtomicStatements
// It doesn't include 'Parallel' statements because they would be parallel to 
// the existing thread and therefore included in the previous thread list (Parallel.threads).
// -------------------------------------
EsterelThread returns esterel::EsterelThread:
    {esterel::EsterelThread}
    (statements+=SCEstAtomicStatement ";" | statements+=MetaStatement)* statements+=SCEstAtomicStatement?;

// ==> Block
// -------------------------------------    
Block returns esterel::Block:
    {esterel::Block}
    (annotations += Annotation)*
    "[" ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) "]";

// ==> 7.5.3 The present Signal Test
// -------------------------------------
Present returns esterel::Present:
    (annotations += Annotation)*
    "present" 
    (   (
            (     expression=SignalExpression 
                | "[" expression=SignalExpression "]" 
                | tick=Tick
            ) 
            (
                (thenAnnotations += Annotation)*
                "then" 
                ( (thenStatements+=SCEstStatement ";" | thenStatements+=MetaStatement)* thenStatements+=SCEstStatement? )
            )?
        ) 
        | 
        cases+=PresentCase+ 
    ) 
    (
        (elseAnnotations += Annotation)*
        "else" 
        ( (elseStatements+=SCEstStatement ";" | elseStatements+=MetaStatement)* elseStatements+=SCEstStatement? )
    )? 
    "end" "present"?;

PresentCase returns esterel::PresentCase:
    (annotations += Annotation)*
    "case" 
    (     expression=SignalExpression 
        | "[" expression=SignalExpression "]" 
        | tick=Tick
    )
    (   "do" 
        ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )
    )?;

// ==> 7.5.4 The if Data Test
// -------------------------------------
IfTest returns esterel::IfTest:
    (annotations += Annotation)*
    "if" 
    expr=Expression 
    (
        (thenAnnotations += Annotation)*
        "then" 
        ( (thenStatements+=SCEstStatement ";" | thenStatements+=MetaStatement)* thenStatements+=SCEstStatement? )
    )? 
    (elseif+=ElsIf)* 
    (
            (elseAnnotations += Annotation)*
            "else" 
            ( (elseStatements+=SCEstStatement ";" | elseStatements+=MetaStatement)* elseStatements+=SCEstStatement? )
    )? 
    "end" "if"?;

ElsIf returns esterel::ElsIf:
    (annotations += Annotation)*
    "elsif" 
    expr=Expression 
    (
        (thenAnnotations += Annotation)*
        "then" 
        ( (thenStatements+=SCEstStatement ";" | thenStatements+=MetaStatement)* thenStatements+=SCEstStatement? )
    )?;

// ==> 7.5.5 Looping & 7.5.9 Temporal Loops
// -------------------------------------
Loop returns esterel::Loop:
    {esterel::Loop}
    (annotations += Annotation)*
    "loop" 
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) 
    ("end" "loop"? | "each" delay=DelayExpr);

// ==> 7.5.6 Repeat Looping
// -------------------------------------
Repeat returns esterel::Repeat:
    (annotations += Annotation)*
    (positive?="positive")? 
    "repeat" 
    expression=Expression 
    "times" 
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) 
    "end" "repeat"?;

// ==> 7.5.7 The abort Statements
// -------------------------------------
Abort returns esterel::Abort:
    (annotations += Annotation)*
    ((weak?="weak")? "abort") 
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) 
    "when" 
    (
        delay=DelayExpr
        (   
            "do" 
            ( (doStatements+=SCEstStatement ";" | doStatements+=MetaStatement)* doStatements+=SCEstStatement? )
        )?
        "end" ("weak" "abort" | "abort")?
    |
        delay=DelayExpr 
        ("end" | "end" "weak"? "abort")?   
    |
        cases+=Case+
        "end" ("weak" "abort" | "abort")?
    );

Case returns esterel::Case:
    (annotations += Annotation)*
    "case" 
    delay=DelayExpr 
    ( 
        "do" 
        ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) 
    )?;

// ==> 7.5.8 The await Statement
// -------------------------------------
Await returns esterel::Await:
    (annotations += Annotation)*
    "await" 
    (
        delay=DelayExpr
        (   
            "do" 
            ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )
            "end" "await"?
        )?
    |
        cases+=Case+
        "end" "await"?
    );

// ==> 7.5.9 Temporal Loops
// -------------------------------------

// for 'LoopEach' look at 7.5.5

EveryDo returns esterel::EveryDo:
    (annotations += Annotation)*
    "every" 
    delay=DelayExpr 
    "do" 
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) 
    "end" "every"?;

// ==> 7.5.10 The suspend Statement
// -------------------------------------
Suspend returns esterel::Suspend:
    (annotations += Annotation)*
    ((weak?="weak")? "suspend") 
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) 
    "when" 
    delay=DelayExpr; 
    
// ==> 7.5.11 Traps
// -------------------------------------
Trap returns esterel::Trap:
    (annotations += Annotation)*
    "trap" 
    trapSignals+=TrapSignal ("," trapSignals+=TrapSignal)* 
    "in" 
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )
    (trapHandler+=TrapHandler)* 
    "end" "trap"?;

TrapHandler returns esterel::TrapHandler:
    (annotations += Annotation)*
    "handle" 
    trapExpr=TrapExpr 
    "do" 
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? );

// ==> 7.5.12 The exec Task Execution Statement
// -------------------------------------
Exec returns esterel::Exec:
    (annotations += Annotation)*
        (   "exec" task=[esterel::Task|ID] 
            "(" (vars+=[esterel::IVariable|ID] ("," vars+=[esterel::IVariable|ID])*)? ")" 
            "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")" 
            "return" 
            retSignal=[esterel::ISignal] 
            ("do" ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ))? 
        | 
            "exec" execCaseList+=ExecCase+ 
        ) 
    "end" "exec"?;

ExecCase returns esterel::ExecCase:
    (annotations += Annotation)*
    "case" task=[esterel::Task|ID] 
    "(" (vars+=[esterel::IVariable|ID] ("," vars+=[esterel::IVariable|ID])*)? ")" 
    "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")" 
    "return" 
    retSignal=[esterel::ISignal] 
    ("do" ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ))?;

// ==> 7.5.13 Local Signal Declaration    
// -------------------------------------
LocalSignalDecl returns esterel::LocalSignalDecl:
    (annotations += Annotation)*
    "signal" signals+=ISignal ("," signals+=ISignal)* 
    "in" ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) 
    "end" "signal"?;

// ==> 7.5.14 Local Variable Declaration
// ------------------------------------- 
LocalVariable returns esterel::LocalVariable:
    (annotations += Annotation)*
    "var" 
    (varDecls+=VariableDecl) ("," varDecls+=VariableDecl)* 
    "in" 
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) 
    "end" "var"?;
    
/* ###################################################
 * ###               7.6 Old Syntax                ###
 * ###################################################
 */
 
Do returns esterel::Do:
    (annotations += Annotation)*
    "do" 
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? ) 
    ( 
        (endingAnnotations += Annotation)* 
        "upto" 
        expr=DelayExpr
        | 
        (endingAnnotations += Annotation)* 
        "watching" 
        delay=DelayExpr 
        ( 
            "timeout" 
            ( (watchingStatements+=SCEstStatement ";" | watchingStatements+=MetaStatement)* watchingStatements+=SCEstStatement? ) 
            "end" "timeout"?  
        )?
    );
      
/* ###################################################
 * ###                   SCEst                     ###
 * ###################################################
 */
 
// ==> unemit
// -------------------------------------
UnEmit:
    (annotations += Annotation)*
    "unemit" 
    ((signal=[esterel::ISignal|ID]) | tick=Tick);

// ==> reset: Signal value reset (absolute write)
// -------------------------------------
Set:
    (annotations += Annotation)*
    "set" 
    ((signal=[esterel::ISignal|ID]) | tick=Tick) 
    ("("expr=Expression")");
     
    
/* ###################################################
 * ###                   SCL                       ###
 * ###################################################
 */    

Conditional returns scl::Conditional: 
    (annotations += Annotation)*
    'if' expression = Expression
    (
        'then'? '{'
        (declarations+=Declaration)*
        ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )
        '}'
    )
    (else = ElseScope)?;

ElseScope returns scl::ElseScope:
    {scl::ElseScope}
    (annotations += Annotation)*
    'else' '{'
    (declarations+=Declaration)*
    ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )        
    '}';

MetaStatement returns scl::Statement:
    Label | ScopeStatement;

Thread returns scl::Thread:
    {scl::Thread}
     (   
        (annotations += Annotation)*
        '{'
        (declarations+=Declaration)*
        ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )
        '}'
         
    | 
        ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )  
    );
Parallel returns scl::Parallel:
    (annotations+=Annotation)*
    'fork'
    (    threads += Thread
    ('par'
         threads += Thread)*)
    'join';

ScopeStatement returns scl::ScopeStatement:
    {scl::ScopeStatement}
    (annotations+=Annotation)*
    '{'
        (declarations+=Declaration)*
        ( (statements+=SCEstStatement ";" | statements+=MetaStatement)* statements+=SCEstStatement? )
    '}';

    
    
/* ###################################################
 * ###                   Terminal                  ###
 * ###################################################
 */    
    
terminal ML_COMMENT: 
    ('%' '{') -> ('}' '%')
    |
    ('/*'!'*') -> '*/';
 
terminal SL_COMMENT: 
    ( '//' | '%' ) !('\n'|'\r')* ('\r'? '\n')?;
 
