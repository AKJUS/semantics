grammar de.cau.cs.kieler.esterel.Esterel with de.cau.cs.kieler.scl.SCL

generate esterel "http://www.cau.de/cs/kieler/esterel/Esterel"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://kieler.cs.cau.de/annotations" as annotations
import "http://kieler.cs.cau.de/kexpressions/0.1.2" as kexpressions
import "http://kieler.cs.cau.de/keffects/0.1.0" as keffects
import "http://kieler.cs.cau.de/kext/0.1.0" as kext
import "http://kieler.cs.cau.de/scl/0.2.0" as scl

//  root rule. an esterel file can contain multiple modules
Program hidden(SL_COMMENT, ML_COMMENT, WS):
    (modules+=Module)*;


/* ###################################################
 * ###                 7.2 Modules                 ###
 * ###################################################
 */
 
// ==> module: a module consists of an interface and a body
// -------------------------------------
Module:
    (annotations += Annotation)*
    "module" name=ID ":" 
    (     intSignalDecls+=InterfaceSignalDecl
        | intTypeDecls+=TypeDecl
        | intSensorDecls+=SensorDecl
        | intConstantDecls+=ConstantDecls
        | intRelationDecls+=RelationDecl
        | intTaskDecls+=TaskDecl
        | intFunctionDecls+=FunctionDecl
        | intProcedureDecls+=ProcedureDecl
    )* 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? )
    ("end" "module" | ".");


/* ###################################################
 * ###        7.3 Interface Declaration            ###
 * ###################################################
 */
 
// ==> Interface Declaration
// ----------------------------------------------

// overwrite to allow type definitions in a specific module
TypeIdentifier: 
      type=Esterel_ValueType
    | typeID=ID
    | ("combine" (type=Esterel_ValueType | typeID=ID) "with" operator=Esterel_CombineOperator)
    | {EsterelType} estType=[Type|ID];
    
// ==> 7.3.1 Type Declarations
// -------------------------------------
TypeDecl:
    (annotations += Annotation)*
    "type" 
    types+=Type ("," types+=Type)* 
    ";";

Type:
    name=ID;
    
// ==> 7.3.2 Constant Declarations
// -------------------------------------
ConstantDecls:
    (annotations += Annotation)*
    "constant" 
    constants+=OneTypeConstantDecls ("," constants+=OneTypeConstantDecls)* 
    ";";

OneTypeConstantDecls:
    constants+=Constant ("," constants+=Constant)* ":" type=TypeIdentifier;

Constant returns kexpressions::ValuedObject:
    {Constant} name=ID ("=" value=ConstantValue)?;

ConstantValue:
    INT | FLOAT | BOOLEAN | ID | STRING;
    
// ==> 7.3.3 Function Declaration
// -------------------------------------
FunctionDecl:
    (annotations += Annotation)*
    "function" 
    functions+=Function ("," functions+=Function)* 
    ";";

Function:
    name=ID 
    "(" (idList+=TypeIdentifier ("," idList+=TypeIdentifier)*)? ")" 
    ":" type=TypeIdentifier;

// ==> 7.3.4 Procedure Declaration
// -------------------------------------
ProcedureDecl:
    (annotations += Annotation)*
    "procedure" procedures+=Procedure ("," procedures+=Procedure)* 
    ";";

Procedure:
    name=ID 
    "(" (variables+=TypeIdentifier ("," variables+=TypeIdentifier)*)? ")" 
    "(" (expressions+=TypeIdentifier ("," expressions+=TypeIdentifier)*)? ")";

// ==> 7.3.5 Task Declaration
// -------------------------------------
TaskDecl:
    (annotations += Annotation)*
    "task" tasks+=Task ("," tasks+=Task)* 
    ";";

Task:
    name=ID 
    "(" (variables+=TypeIdentifier ("," variables+=TypeIdentifier)*)? ")" 
    "(" (expressions+=TypeIdentifier ("," expressions+=TypeIdentifier)*)? ")";
    
// ==> 7.3.6 Signal Declaration
// -------------------------------------
InterfaceSignalDecl:
    {Input} (annotations += Annotation)* "input" signals+=ISignal ("," signals+=ISignal)* ";" 
    |
    {Output} (annotations += Annotation)* "output" signals+=ISignal ("," signals+=ISignal)* ";" 
    |
    {InputOutput} (annotations += Annotation)* "inputoutput" signals+=ISignal ("," signals+=ISignal)* ";" 
    |
    {Return} (annotations += Annotation)* "return" signals+=ISignal ("," signals+=ISignal)* ";";
    
// example 1:   A : combine boolean with or
// example 2:   A (combine boolean with or)
// example 3:   A := 0 : combine integer with '+'
ISignal returns ISignal:
    {ISignal}
    name=ID (   
          (":"    type=Esterel_ValueType
                | typeID=ID
                | ("combine" (type=Esterel_ValueType | typeID=ID) "with" (func=[Function|ID] | operator=Esterel_CombineOperator)) 
                )
        | ("(" 
              type=Esterel_ValueType
            | typeID=ID
            | ("combine" (type=Esterel_ValueType | typeID=ID) "with" (func=[Function|ID] | operator=Esterel_CombineOperator))
           ")")
        | (":=" expression=Expression ":" 
                  type=Esterel_ValueType
                | typeID=ID
                | ("combine" (type=Esterel_ValueType | typeID=ID) "with" (func=[Function|ID] | operator=Esterel_CombineOperator))
          ) 
    )?;
    
Tick returns ISignal:
    name="tick";

// ==> 7.3.7 Sensor Declaration
// -------------------------------------
SensorDecl:
    (annotations += Annotation)*
    "sensor" 
    sensors+=SensorWithType ("," sensors+=SensorWithType)* 
    ";";

SensorWithType:
    sensor=Sensor ( 
        (":" type=TypeIdentifier) | ("(" type=TypeIdentifier ")")
    );

Sensor returns ISignal:
    name=ID;

// ==> 7.3.8 Input Relation Declaration
// -------------------------------------
RelationDecl:
    {Relation} 
    (annotations += Annotation)* 
    "relation" 
    relations+=RelationType ("," relations+=RelationType)* 
    ";";

RelationType:
    RelationImplication | RelationIncompatibility;

RelationImplication:
    first=[ISignal|ID] type="=>" second=[ISignal|ID];

RelationIncompatibility:
    incomp+=[ISignal|ID] type="#" incomp+=[ISignal|ID] ("#" incomp+=[ISignal|ID])*;


/* ###################################################
 * ###               7.5 Statements                ###
 * ###################################################
 */

StatementContainerInterface returns scl::StatementContainer:
    Abort | Await |  Block | Case | Do | EveryDo | Exec | 
    ExecCase | LocalSignalDecl | LocalVariable | Loop | 
    PresentCase |  Repeat | Suspend | EsterelThread | 
    Trap | TrapHandler | Module;
    
// ==> Statement
// -------------------------------------
EsterelStatement returns scl::Statement:
    EsterelParallel | AtomicStatement;

// ==> Atomic Statements
// -------------------------------------
AtomicStatement returns scl::Statement:
    Abort | EsterelAssignment | Await | Block | ProcCall | Do | Emit | EveryDo | 
    Exit | Exec | Halt | IfTest | LocalSignalDecl | Loop | Nothing | Pause | Present | 
    Repeat | Run | Suspend | Sustain | Trap | LocalVariable ;
        
// ==> Parallel: at least two threads
// -------------------------------------
EsterelParallel:
    threads+=EsterelThread ("||" threads+=EsterelThread)+;

// ==> Thread
// One AtomicStatement or multiple AtomicStatements
// It doesn't include 'Parallel' statements because they would be parallel to 
// the existing thread and therefore included in the previous thread list (Parallel.threads).
// -------------------------------------
EsterelThread:
    {EsterelThread}
    (statements+=AtomicStatement ";")* statements+=AtomicStatement?;
    
// ==> Nothing
// -------------------------------------
Nothing:
    {Nothing} 
    (annotations += Annotation)* 
    "nothing";
    
// ==> Halt
// -------------------------------------
Halt:
    {Halt} 
    (annotations += Annotation)* 
    "halt";

// ==> Block
// -------------------------------------    
Block:
    {Block}
    (annotations += Annotation)*
    "[" ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) "]";

// ==> 7.5.1 Signal Emission
// -------------------------------------
Emit:
    (annotations += Annotation)*
    "emit" 
    (    signal=[ISignal|ID]
       | tick=Tick
    )
    ("("expr=Expression")")?;
    
// emit a signal indefinitely
Sustain:
    (annotations += Annotation)*
    "sustain" 
    ((signal=[ISignal|ID]) | tick=Tick) 
    ("(" expression=Expression ")")?;

// ==> 7.5.2 Assignment and Procedure Call
// -------------------------------------
EsterelAssignment:
    var=[IVariable|ID] ":=" expr=Expression;
    
ProcCall:
    (annotations += Annotation)*
    "call" 
    proc=[Procedure|ID] 
    "(" 
        ( varList+=[IVariable|ID] ("," varList+=[IVariable|ID])* )?
    ")"
    "(" 
        ( kexpressions+=Expression ("," kexpressions+=Expression)* )? 
    ")";

// ==> 7.5.3 The present Signal Test
// -------------------------------------
Present:
    (annotations += Annotation)*
    "present" 
    (   (
            (     expression=SignalExpression 
                | "[" expression=SignalExpression "]" 
                | tick=Tick
            ) 
            (
                (thenAnnotations += Annotation)*
                "then" 
                ( (thenStatements+=EsterelStatement ";")* thenStatements+=EsterelStatement? )
            )?
        ) 
        | 
        cases+=PresentCase+ 
    ) 
    (
        (elseAnnotations += Annotation)*
        "else" 
        ( (elseStatements+=EsterelStatement ";")* elseStatements+=EsterelStatement? )
    )? 
    "end" "present"?;

PresentCase:
    (annotations += Annotation)*
    "case" 
    (     expression=SignalExpression 
        | "[" expression=SignalExpression "]" 
        | tick=Tick
    )
    (   "do" 
        ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? )
    )?;

// ==> 7.5.4 The if Data Test
// -------------------------------------
IfTest:
    (annotations += Annotation)*
    "if" 
    expr=Expression 
    (
        (thenAnnotations += Annotation)*
        "then" 
        ( (thenStatements+=EsterelStatement ";")* thenStatements+=EsterelStatement? )
    )? 
    (elseif+=ElsIf)* 
    (
            (elseAnnotations += Annotation)*
            "else" 
            ( (elseStatements+=EsterelStatement ";")* elseStatements+=EsterelStatement? )
    )? 
    "end" "if"?;

ElsIf:
    (annotations += Annotation)*
    "elsif" 
    expr=Expression 
    (
        (thenAnnotations += Annotation)*
        "then" 
        ( (thenStatements+=EsterelStatement ";")* thenStatements+=EsterelStatement? )
    )?;

// ==> 7.5.5 Looping & 7.5.9 Temporal Loops
// -------------------------------------
Loop:
    {Loop}
    (annotations += Annotation)*
    "loop" 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) 
    ("end" "loop"? | "each" delay=DelayExpr);

// ==> 7.5.6 Repeat Looping
// -------------------------------------
Repeat:
    (annotations += Annotation)*
    (positive?="positive")? 
    "repeat" 
    expression=Expression 
    "times" 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) 
    "end" "repeat"?;

// ==> 7.5.7 The abort Statements
// -------------------------------------
Abort:
    (annotations += Annotation)*
    ((weak?="weak")? "abort") 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) 
    "when" 
    (
        delay=DelayExpr
        (   
            "do" 
            ( (doStatements+=EsterelStatement ";")* doStatements+=EsterelStatement? )
        )?
        "end" ("weak" "abort" | "abort")?
    |
        delay=DelayExpr 
        ("end" | "end" "weak"? "abort")?   
    |
        cases+=Case+
        "end" ("weak" "abort" | "abort")?
    );

Case:
    (annotations += Annotation)*
    "case" 
    delay=DelayExpr 
    ( 
        "do" 
        ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) 
    )?;

// ==> 7.5.8 The await Statement
// -------------------------------------
Await:
    (annotations += Annotation)*
    "await" 
    (
        delay=DelayExpr
        (   
            "do" 
            ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? )
            "end" "await"?
        )?
    |
        cases+=Case+
        "end" "await"?
    );

// ==> 7.5.9 Temporal Loops
// -------------------------------------

// for 'LoopEach' look at 7.5.5

EveryDo:
    (annotations += Annotation)*
    "every" 
    delay=DelayExpr 
    "do" 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) 
    "end" "every"?;

// ==> 7.5.10 The suspend Statement
// -------------------------------------
Suspend:
    (annotations += Annotation)*
    ((weak?="weak")? "suspend") 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) 
    "when" 
    delay=DelayExpr; 
    
// ==> 7.5.11 Traps
// -------------------------------------
Trap:
    (annotations += Annotation)*
    "trap" 
    trapSignals+=TrapSignal ("," trapSignals+=TrapSignal)* 
    "in" 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? )
    (trapHandler+=TrapHandler)* 
    "end" "trap"?;

TrapSignal returns ISignal:
    {TrapSignal} 
    name=ID 
    ( 
          (":"    type=Esterel_ValueType
                | typeID=ID
                | ("combine" (type=Esterel_ValueType | typeID=ID) "with" (func=[Function|ID] | operator=Esterel_CombineOperator)) 
                )
        | ("(" 
              type=Esterel_ValueType
            | typeID=ID
            | ("combine" (type=Esterel_ValueType | typeID=ID) "with" (func=[Function|ID] | operator=Esterel_CombineOperator))
           ")")
        | (":=" expression=Expression ":" 
                  type=Esterel_ValueType
                | typeID=ID
                | ("combine" (type=Esterel_ValueType | typeID=ID) "with" (func=[Function|ID] | operator=Esterel_CombineOperator))
          ) 
     )?;

TrapHandler:
    (annotations += Annotation)*
    "handle" 
    trapExpr=TrapExpr 
    "do" 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? );

Exit:
    (annotations += Annotation)*
    "exit" 
    trap=[TrapSignal|ID] 
    ("(" expression=Expression ")")?;

// ==> 7.5.12 The exec Task Execution Statement
// -------------------------------------
Exec:
    (annotations += Annotation)*
        (   "exec" task=[Task|ID] 
            "(" (vars+=[IVariable|ID] ("," vars+=[IVariable|ID])*)? ")" 
            "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")" 
            "return" 
            retSignal=[ISignal] 
            ("do" ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ))? 
        | 
            "exec" execCaseList+=ExecCase+ 
        ) 
    "end" "exec"?;

ExecCase:
    (annotations += Annotation)*
    "case" task=[Task|ID] 
    "(" (vars+=[IVariable|ID] ("," vars+=[IVariable|ID])*)? ")" 
    "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")" 
    "return" 
    retSignal=[ISignal] 
    ("do" ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ))?;

// ==> 7.5.13 Local Signal Declaration    
// -------------------------------------
LocalSignalDecl:
    (annotations += Annotation)*
    "signal" signals+=ISignal ("," signals+=ISignal)* 
    "in" ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) 
    "end" "signal"?;

// ==> 7.5.14 Local Variable Declaration
// ------------------------------------- 
LocalVariable:
    (annotations += Annotation)*
    "var" 
    (varDecls+=VariableDecl) ("," varDecls+=VariableDecl)* 
    "in" 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) 
    "end" "var"?;
    
VariableDecl:
    (variables+=IVariable) ("," variables+=IVariable)* ":" type=TypeIdentifier;

IVariable:
     name=ID (":=" expression=Expression)?;

// ==> 7.5.15 The run Module Instantiation Statement
// -------------------------------------
Run:
    (annotations += Annotation)*
    (   (   "run" 
            module=ModuleRenaming 
            ("[" list+=Renaming (";" list+=Renaming)* "]")? 
        )
        | 
        (    "copymodule"
            module=ModuleRenaming
            ("[" list+=Renaming (";" list+=Renaming)* "]")?
            
         )
    ); //deprecated

ModuleRenaming:
       module=[Module|ID] 
    | (newName=ID "/" module=[Module|ID])
;
Renaming:
    (annotations += Annotation)*
    ("type" renamings+=TypeRenaming ("," renamings+=TypeRenaming)*
    | "constant" renamings+=ConstantRenaming ("," renamings+=ConstantRenaming)*
    | "function" renamings+=FunctionRenaming ("," renamings+=FunctionRenaming)*
    | "procedure" renamings+=ProcedureRenaming ("," renamings+=ProcedureRenaming)*
    | "task" renamings+=TaskRenaming ("," renamings+=TaskRenaming)*
    | "signal" renamings+=SignalRenaming ("," renamings+=SignalRenaming)* );

TypeRenaming:
    (newName=[Type|ID] | newType=Esterel_ValueType) "/" oldName=[Type|ID];

ConstantRenaming:
    (newName=[kexpressions::ValuedObject|ID] | newValue=ConstantValue) "/" oldName=[kexpressions::ValuedObject|ID];

FunctionRenaming:
    (newName=[Function|ID] | newFunc=BuildInFunction) "/" oldName=[Function|ID];

ProcedureRenaming:
    newName=[Procedure|ID] "/" oldName=[Procedure|ID];

TaskRenaming:
    newName=[Task|ID] "/" oldName=[Task|ID];

SignalRenaming:
    (newName=[ISignal|ID] | "tick") "/" oldName=[ISignal|ID];

// renaming can also rename build in types and functions
BuildInFunction:
    "*" | "/" | "+" | "-" | "mod" | "=" | "<>" | ">" | "<" | "<=" | ">=" | "not" | "and" | "or";


/* ###################################################
 * ###               7.6 Old Syntax                ###
 * ###################################################
 */
 
Do:
    (annotations += Annotation)*
    "do" 
    ( (statements+=EsterelStatement ";")* statements+=EsterelStatement? ) 
    ( 
        (endingAnnotations += Annotation)* 
        "upto" 
        expr=DelayExpr
        | 
        (endingAnnotations += Annotation)* 
        "watching" 
        delay=DelayExpr 
        ( 
            "timeout" 
            ( (watchingStatements+=EsterelStatement ";")* watchingStatements+=EsterelStatement? ) 
            "end" "timeout"?  
        )?
    );

       
/* ###################################################
 * ###                    Enum                     ###
 * ###################################################
 */
   
enum Esterel_CompareOperator returns kexpressions::OperatorType:
    EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="<>";

enum Esterel_PreOperator returns kexpressions::OperatorType:
    PRE="pre";

enum Esterel_OrOperator returns kexpressions::OperatorType:
    LOGICAL_OR="or";

enum Esterel_AndOperator returns kexpressions::OperatorType:
    LOGICAL_AND="and";

enum Esterel_NotOperator returns kexpressions::OperatorType:
    NOT="not";

enum Esterel_AddOperator returns kexpressions::OperatorType:
    ADD="+";
    
enum Esterel_SubOperator returns kexpressions::OperatorType:
    SUB="-";
    
enum Esterel_MultOperator returns kexpressions::OperatorType: 
    MULT="*";

enum Esterel_ModOperator returns kexpressions::OperatorType:  
    MOD="mod";

enum Esterel_DivOperator returns kexpressions::OperatorType:  
    DIV="/";

enum Esterel_ValueTestOperator returns kexpressions::OperatorType:
    VAL="?";    

/*
   the following declarations are re-used in Actions.xtext, Interface.xtext, Kits.xtext 
*/
enum Esterel_ValueType returns kexpressions::ValueType:
    PURE="pure" | BOOL="boolean" | UNSIGNED="unsigned"  | 
    INT="integer" | FLOAT="float" | DOUBLE="double" |
    STRING="string" | HOST="host";


enum Esterel_CombineOperator returns kexpressions::CombineOperator:
    NONE="none" | ADD="+" | MULT="*" | MAX="max" |
    MIN="min" | OR="or" | AND="and" | HOST="host";


/* ###################################################
 * ###                 Terminal                    ###
 * ###################################################
 */

terminal SL_COMMENT:
    '%' !('\n' | '\r')* ('\r'? '\n')?;

terminal ML_COMMENT:
    ('%' '{')->('}' '%');

// allow escaping by double quotes ( "this is a ""quote"", how nice." ) - Esterel style
terminal STRING returns ecore::EString:
    '"' (!('"') | ('"' '"'))* '"';

// custom terminal rule allowing to save transition label string as they are
terminal HOSTCODE returns ecore::EString: 
    "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'";       
       
       
/* ###################################################
 * ###               Expressions                   ###
 * ###################################################
 */
 
// Esterel is a bit richer than what is provided by kexpressions. 
// These rules are introduced here.
// Care about order of the rules! 
AtomicExpression returns kexpressions::Expression:
    FunctionExpression
    | TrapExpression
    | BoolValue
    | ValuedObjectTestExpression
    | TextExpression
    | '(' BooleanExpression ')'
    | ConstantExpression;

TrapExpression returns kexpressions::Expression:
    {TrapExpression} "??" trap=[ISignal|ID];

FunctionExpression returns kexpressions::Expression:
    {FunctionExpression} function=[Function|ID] 
    "(" (kexpressions+=Expression ("," kexpressions+=Expression)*)? ")";

ConstantExpression returns kexpressions::Expression:
    {ConstantExpression} (constant=[Constant|ID] | value=ConstantValue);

// --> B.3.5 Trap Expressions <--
// -------------------------------------
TrapExpr returns kexpressions::Expression:
    SignalExpression;

// --> B.3.3 Signal Expressions <--
// -------------------------------------
// The warning can be ignored since the operator will only override itself in this loop.
SignalExpression returns kexpressions::Expression:
    SignalAndExpression 
    (   {kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=Esterel_OrOperator subExpressions+=SignalAndExpression)+
    )?;

// The warning can be ignored since the operator will only override itself in this loop.
SignalAndExpression returns kexpressions::Expression:
    SignalNotExpression 
    (   {kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=Esterel_AndOperator subExpressions+=SignalNotExpression)+
    )?;

// The warning can be ignored since the operator will only override itself in this loop.
SignalNotExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} 
    (operator=Esterel_NotOperator)+ 
    subExpressions+=SignalAtomicExpression
    |
    SignalAtomicExpression;

SignalAtomicExpression returns kexpressions::Expression:
    SignalReferenceExpr
    | "(" SignalExpression ")"
    | SignalPreExpr
    | TrapReferenceExpr;

SignalReferenceExpr returns ValuedObjectReference:
    valuedObject=[ISignal|ID];

SignalPreExpr returns kexpressions::Expression:
    {kexpressions::OperatorExpression} 
    operator=Esterel_PreOperator 
    '(' subExpressions+=SignalReferenceExpr ')';

TrapReferenceExpr returns kexpressions::ValuedObjectReference:
    {TrapReferenceExpr} valuedObject=[TrapSignal|ID];

// --> B.3.4 Delay Expressions <--
// -------------------------------------
DelayExpr:
    ( expr=Expression | isImmediate?="immediate" )?
    (     tick=Tick 
        | signalExpr=SignalReferenceExpr 
        | "[" signalExpr=SignalExpression "]"
    );   

    
/* #########################################################################
 * 
 * 
 * Before the following was an extra plugin named
 * "KExpressions":  de.cau.cs.kieler.esterel.kexpressions
 * 
 * 
 * #########################################################################
 */    

Expression returns kexpressions::Expression:
//    => BooleanExpression // old
      BooleanExpression
    | ValuedExpression;


// Example: not D and C or ?E = 42 or not (A and (B or C))
BooleanExpression returns kexpressions::Expression:
    OrExpression;


// Example: A or B, A and B and C, C and B or D and not E, A and B and C
// The warning can be ignored since the operator will only override itself in this loop.
OrExpression returns kexpressions::Expression:
    AndExpression 
    (   {kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=Esterel_OrOperator subExpressions+=AndExpression)+
    )?;


// Example: A and B, not C and 42 <= ?D
// The warning can be ignored since the operator will only override itself in this loop.
AndExpression returns kexpressions::Expression:
    CompareOperation 
    (   {kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=Esterel_AndOperator subExpressions+=CompareOperation)+
    )?;


// Example: 42 <= ?A
CompareOperation returns kexpressions::Expression:
    NotOrValuedExpression 
    ({kexpressions::OperatorExpression.subExpressions+=current} 
        operator=Esterel_CompareOperator subExpressions+=NotOrValuedExpression
    )?;
/*   
    // old
    => NotOrValuedExpression 
    ( {kexpressions::OperatorExpression.subExpressions+=current} 
        operator=Esterel_CompareOperator 
        subExpressions+=NotOrValuedExpression
    )
    | 
    NotExpression; 
*/    
    


// order IS IMPORTANT
NotOrValuedExpression returns kexpressions::Expression:
//    => ValuedExpression // old
      ValuedExpression
    | NotExpression;


// Example: not A, not false, not (A or B)
// at the latter we need the parans to indicate the right binding
NotExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} 
    operator=Esterel_NotOperator 
    subExpressions+=(NotExpression)
    | 
    AtomicExpression;
  
    
// everything that evaluates to a primitive number value
ValuedExpression returns kexpressions::Expression:
    AddExpression;


// Example: 1 + 2
// The warning can be ignored since the operator will only override itself in this loop.
AddExpression returns kexpressions::Expression:
    SubExpression 
    (   {kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=Esterel_AddOperator subExpressions+=SubExpression)+
    )?;


// Example: varA - ?B
// The warning can be ignored since the operator will only override itself in this loop.
SubExpression returns kexpressions::Expression:
    MultExpression 
    (   {kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=Esterel_SubOperator subExpressions+=MultExpression)+
    )?;


// Example: 2 * 4
// The warning can be ignored since the operator will only override itself in this loop.
MultExpression returns kexpressions::Expression:
    DivExpression 
    (   {kexpressions::OperatorExpression.subExpressions+=current} 
        (operator=Esterel_MultOperator subExpressions+=DivExpression)+
    )?;


// Example: (2 / 4)
// note: division always has to have parantheses because the '/' sign is also used for trigger/effect delimiter
DivExpression returns kexpressions::Expression:
    ModExpression 
    (   {kexpressions::OperatorExpression.subExpressions+=current} 
        operator=Esterel_DivOperator 
        subExpressions+=ModExpression
    )?;
    

// Example: varA mod ?B
ModExpression returns kexpressions::Expression:
    NegExpression 
    (   {kexpressions::OperatorExpression.subExpressions+=current} 
        operator=Esterel_ModOperator 
        subExpressions+=AtomicValuedExpression
    )?;


// Example: not A, not false, not (A or B)
// at the latter we need the parans to indicate the right binding
NegExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} 
    operator=Esterel_SubOperator 
    subExpressions+=(NegExpression)
    | 
    AtomicValuedExpression;

AtomicValuedExpression returns kexpressions::Expression:
    IntValue
    | FloatValue
//    | '(' DivExpression ')'
//    | => '(' ValuedExpression ')'  // old
    | '(' ValuedExpression ')'
    | AtomicExpression;


// Example: pre(pre(?A)), pre(pre(A)), ?A, A varX
ValuedObjectTestExpression returns kexpressions::Expression:
    {kexpressions::OperatorExpression} operator=Esterel_PreOperator '('subExpressions+=ValuedObjectTestExpression')'
    | {kexpressions::OperatorExpression} operator=Esterel_ValueTestOperator subExpressions+=ValuedObjectReference
    | ValuedObjectReference;


// Example: A, varB
ValuedObjectReference returns kexpressions::ValuedObjectReference:
    {kexpressions::ValuedObjectReference} 
    valuedObject=[kexpressions::ValuedObject|ID];

ValuedObject returns kexpressions::ValuedObject:
    ISignal | Constant | TrapSignal;

//// Example: 'printf(...)'(C)
//TextExpression returns TextExpression:
//    code=HOSTCODE ("(" type=ID ")")?; // in KExpressions there is no 'type'
