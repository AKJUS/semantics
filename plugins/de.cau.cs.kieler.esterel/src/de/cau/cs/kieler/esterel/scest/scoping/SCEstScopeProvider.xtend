/*
 * generated by Xtext
 */
package de.cau.cs.kieler.esterel.scest.scoping;

import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.COLLECT_CONSTANTS;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.COLLECT_FUNCTIONS;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.COLLECT_PROCEDURES;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.COLLECT_SENSORS;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.COLLECT_SIGNALS;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.COLLECT_TASKS;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.COLLECT_TYPES;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.getAllElements;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.getAllSignals;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.getElements;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.getLocalSignals;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.getLocalTraps;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.getLocalVariables;
import static de.cau.cs.kieler.esterel.scest.scoping.SCEstScopeProviderUtil.getModules;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import de.cau.cs.kieler.esterel.esterel.ConstantExpression;
import de.cau.cs.kieler.esterel.esterel.ConstantRenaming;
import de.cau.cs.kieler.esterel.esterel.Emit;
import de.cau.cs.kieler.esterel.esterel.Exit;
import de.cau.cs.kieler.esterel.esterel.FunctionExpression;
import de.cau.cs.kieler.esterel.esterel.FunctionRenaming;
import de.cau.cs.kieler.esterel.esterel.ModuleRenaming;
import de.cau.cs.kieler.esterel.esterel.ProcedureRenaming;
import de.cau.cs.kieler.esterel.esterel.RelationImplication;
import de.cau.cs.kieler.esterel.esterel.RelationIncompatibility;
import de.cau.cs.kieler.esterel.esterel.SignalRenaming;
import de.cau.cs.kieler.esterel.esterel.Sustain;
import de.cau.cs.kieler.esterel.esterel.TaskRenaming;
import de.cau.cs.kieler.esterel.esterel.TrapReferenceExpr;
import de.cau.cs.kieler.esterel.esterel.TypeRenaming;
import de.cau.cs.kieler.esterel.esterel.ValuedObjectReference;
import de.cau.cs.kieler.kexpressions.KExpressionsPackage
import de.cau.cs.kieler.scl.scl.SclPackage
import com.google.common.collect.Iterators
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.resource.EObjectDescription
import de.cau.cs.kieler.scl.scl.Label
import de.cau.cs.kieler.scl.scl.Scope
import java.util.Collections
import org.eclipse.xtext.naming.QualifiedName
import de.cau.cs.kieler.esterel.scest.scest.SCEstProgram

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class SCEstScopeProvider extends AbstractDeclarativeScopeProvider {
    
    /**
     * {@inheritDoc}
     */
    @Override
    override  IScope getScope( EObject context,  EReference reference) {
        switch (reference.EReferenceType) {
            // TODO
//            case KExpressionsPackage.eINSTANCE.valuedObject:
//                return new SimpleScope(voScope(context))
            case SclPackage.eINSTANCE.label:
                return new SimpleScope(context.labelScope)
            default:
                return super.getScope(context, reference)
        }
    }
    
    def voScope(EObject context) {
        var parent = context;
        val vos = newLinkedList()
        while (parent != null) {
            if (parent instanceof Scope) {
                vos.addAll((parent as Scope).declarations.map[valuedObjects])
            }
            parent = parent.eContainer
        }
        return Iterators.concat(vos.map[
            it.iterator.map[
                new EObjectDescription(QualifiedName.create(it.name), it, Collections.<String, String>emptyMap()) as IEObjectDescription
            ]
        ]).toList
    }

    def labelScope(EObject context) {
        var program = context
        while (program != null) {
            if (program instanceof SCEstProgram) {
                return (program as SCEstProgram).eAllContents.filter(Label).map [
                    new EObjectDescription(QualifiedName.create(it.name), it, Collections.<String, String>emptyMap()) as IEObjectDescription
                ].toList
            }
            program = program.eContainer
        }
    }

    /* ************************************************************************
     * Scopes for references in one module
     * ************************************************************************
     */

    def IScope scope_RelationImplication_first( RelationImplication context,
             EReference ref) {
        return new SimpleScope(getElements(context, COLLECT_SIGNALS));
    }

    def IScope scope_RelationImplication_second( RelationImplication context,
             EReference ref) {
        return new SimpleScope(getElements(context, COLLECT_SIGNALS));
    }

    def IScope scope_RelationIncompatibility_incomp( RelationIncompatibility context,
             EReference ref) {
        return new SimpleScope(getElements(context, COLLECT_SIGNALS));
    }

    def IScope scope_Emit_signal( Emit context,  EReference ref) {
        return new SimpleScope(getAllSignals(context));
    }

    def IScope scope_Sustain_signal( Sustain context,  EReference ref) {
        return new SimpleScope(getAllSignals(context));
    }

    def IScope scope_ValuedObjectReference_valuedObject( ValuedObjectReference context,
             EReference ref) {
        var ArrayList<IEObjectDescription> scopeElems = new ArrayList<IEObjectDescription>();
        // there are several elements which are scoped as valued object
        scopeElems.addAll(getLocalSignals(context));
        scopeElems.addAll(getLocalVariables(context));
        scopeElems.addAll(getLocalTraps(context));
        scopeElems.addAll(getAllElements(context,
                COLLECT_CONSTANTS.merge(COLLECT_SENSORS).merge(COLLECT_SIGNALS)));
        return new SimpleScope(scopeElems);
    }

    def IScope scope_TrapReferenceExpr_valuedObject( TrapReferenceExpr context,
             EReference ref) {
        return new SimpleScope(getLocalTraps(context));
    }

    def IScope scope_Exit_trap( Exit context,  EReference ref) {
        return new SimpleScope(getLocalTraps(context));
    }

    def IScope scope_FunctionExpression_function( FunctionExpression context,
             EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_FUNCTIONS));
    }

    def IScope scope_DataConstant_constant( ConstantExpression context,  EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_CONSTANTS));
    }

    /* ************************************************************************
     * ********* Scopes for renaming
     */

    def IScope scope_SignalRenaming_oldName( SignalRenaming context,  EReference ref) {
        var List<IEObjectDescription> scopeElems = getAllSignals(context);
        // sensors are treated as signals
        scopeElems.addAll(getAllElements(context, COLLECT_SENSORS));
        return new SimpleScope(scopeElems);
    }

    def IScope scope_SignalRenaming_newName( SignalRenaming context,  EReference ref) {
        var List<IEObjectDescription> scopeElems = getAllSignals(context);
        // sensors are treated as signals
        scopeElems.addAll(getAllElements(context, COLLECT_SENSORS));
        return new SimpleScope(scopeElems);
    }

    def IScope scope_ConstantRenaming_oldName( ConstantRenaming context,
             EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_CONSTANTS));
    }

    def IScope scope_ConstantRenaming_newName( ConstantRenaming context,
             EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_CONSTANTS));
    }

    def IScope scope_TypeRenaming_oldName( TypeRenaming context,  EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_TYPES));
    }

    def IScope scope_TypeRenaming_newName( TypeRenaming context,  EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_TYPES));
    }

    def IScope scope_FunctionRenaming_oldName( FunctionRenaming context,
             EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_FUNCTIONS));
    }

    def IScope scope_FunctionRenaming_newName( FunctionRenaming context,
             EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_FUNCTIONS));
    }

    def IScope scope_ProcedureRenaming_oldName( ProcedureRenaming context,
             EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_PROCEDURES));
    }

    def IScope scope_ProcedureRenaming_newName( ProcedureRenaming context,
             EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_PROCEDURES));
    }

    def IScope scope_TaskRenaming_oldName( TaskRenaming context,  EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_TASKS));
    }

    def IScope scope_TaskRenaming_newName( TaskRenaming context,  EReference ref) {
        return new SimpleScope(getAllElements(context, COLLECT_TASKS));
    }

    def IScope scope_ModuleRenaming_module( ModuleRenaming context,  EReference ref) {
        return new SimpleScope(getModules(context));
    }

}
