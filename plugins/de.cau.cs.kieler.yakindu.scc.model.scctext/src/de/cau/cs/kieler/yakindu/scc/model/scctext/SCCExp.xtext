grammar de.cau.cs.kieler.yakindu.scc.model.scctext.SCCExp with org.yakindu.sct.model.stext.SText
// reuse and override rules from the SText grammar
generate sccexp "http://cau.kieler.de/scc/SCCExp"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.yakindu.org/sct/statechart/SText" as stext
import "http://www.yakindu.org/sct/sgraph/2.0.0" as sgraph
import "http://www.yakindu.org/base/types/2.0.0" as types

/*********************************** INTERFACE DECLARATION **************************************** */
////defines the possible scopes for a state
StateScope:
	{SimpleScope} declarations+=(VariableDeclaration | SignalDeclaration | LocalReaction)*;

SignalDeclaration returns sgraph::Event:
	SignalDefinition;

SignalDefinition:
	{EventDefinition} 'signal' name=ID ';';

	//StateScope returns sgraph::Scope:
//	InterfaceScope;// | ReactionScope;

/************************************************/
/*			  INTERFACE DECLARATION				*/
/************************************************/
//override the SText InterfaceScope rule
// The InterfaceScope rule specifies that a InterfaceScope starts with 
// the literal 'interface :', followed by one or more interface declaration variables
//InterfaceScope:
//	{InterfaceScope} 'interface' ':' declarations+=VariableDeclaration (','
//	declarations+=VariableDeclaration)* ';';

/************************************************/
/*			 Variable Definition				*/
/************************************************/
// Override the SText VariableDefinition rule
// A variable is a Declaration. It has a Direction, a Name, a Type, an InitialValue and a CombineOperator
/* ---- variable definition ---- */
VariableDefinition:
	{VariableDefinition} direction=VarDirection? (isStatic?='static')? type=[types::Type|FQN] name=ID 
	 ('=' varInitialValue=Expression)? ('with' varCombineOperator=CombineOperator)? ';';

/************************************************/
/*			 	ReactionScope					*/
/************************************************/
LocalReaction:
	(trigger=LocalReactionTrigger) =>('/' effect=LocalReactionEffect);

LocalReactionTrigger returns sgraph::Trigger:
	{ReactionTrigger} ((triggers+=LocalReactionSpec ("," triggers+=LocalReactionSpec)* (=> '[' guardExpression=Expression ']')?)
	| ('[' guardExpression=Expression ']'));
	
LocalReactionEffect returns sgraph::Effect:
	{ReactionEffect} actions+=Expression (=> ';' actions+=Expression)* ; // (';')?;
	

LocalReactionSpec returns stext::EventSpec:
	RegularEventSpec | StateReaction;

StateReaction:
	Entry | Inside | Exit
;

Entry:
	{Entry} 'Entry'
;

Inside:
	{Inside} 'During'
;

Exit:
	{Exit} 'Exit'
;


//ReactionScope:
//	reactionScope+=(EntryAction | InsideAction | ExitAction | Suspend);
//
//ExitAction returns sgraph::Effect:
//	{ExitAction} 'Exit' ':' '/' effect=ReactionEffect ';';
//
//InsideAction returns sgraph::Effect:
//	{InsideAction} 'Inside' ':' '/' effect=ReactionEffect ';';
//
//EntryAction returns sgraph::Effect:
//	{EntryAction} 'Entry' ':' '/' effect=ReactionEffect ';';

/************************************************/
/*			 		SUSPEND 					*/
/************************************************/
// The  SuspendDeclaration is a Trigger
//TODO: only variables already declared in the interface 
//Suspend returns sgraph::Trigger:
//	{Suspend} 'Suspend' ':' trigger=ReactionTrigger ';';

/******************************************** TRANSITION ***************************************** */

// The ReactionTrigger is a Trigger and has an Expression, 
// an optional delay and isImmediate option represented with a '#'
ReactionTrigger returns sgraph::Trigger:
	{ReactionTrigger} (isImmediate?='#')? (delay=INT)? ((triggers+=EventSpec ("," triggers+=EventSpec)* (=> '['
	guardExpression=Expression ']')?)
	| ( '['guardExpression=Expression']'));

// The ReactionEffect is an Effect. 
//ReactionEffect returns sgraph::Effect:
//	{ReactionEffect} actions+=Expression (=> ';' actions+=Expression)*; // (';')?;

/***************************************** Expressions ******************************************* */
// Override the stext::PrimaryExpression
// remove the ActiveStateReferenceExpression and the EventValueReferenceExpression
// and add PreValueExpressionreturns that returns the value of a variable in the previous tick. 
PrimaryExpression returns stext::Expression:
	PrimitiveValueExpression
	| FeatureCall
	| PreValueExpressionreturns | '(' Expression ')';

PreValueExpressionreturns returns stext::Expression:
	{PreValueExpressionreturns} 'pre' '(' value=FeatureCall ')';

/***************************************** COMBINE OPERATORS ************************************* */
enum CombineOperator returns CombineOperator:
	NONE="'none'" | ADD="'+'" | MULT="'*'" | MAX="'max'" |
	MIN="'min'" | OR="'or'" | AND="'and'" | HOST="'host'";

enum VarDirection:
	INOUT='inputoutut' | IN='input' | OUT='output';