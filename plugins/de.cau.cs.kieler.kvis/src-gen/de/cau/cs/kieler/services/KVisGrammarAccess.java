/*
 * generated by Xtext
 */
package de.cau.cs.kieler.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class KVisGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class VisualizationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.Visualization");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cImageAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cImageSTRINGTerminalRuleCall_2_0 = (RuleCall)cImageAssignment_2.eContents().get(0);
		private final Assignment cElementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElementsElementParserRuleCall_3_0 = (RuleCall)cElementsAssignment_3.eContents().get(0);
		
		//Visualization:
		//	'image' ':' image=STRING
		//	elements+=Element*;
		@Override public ParserRule getRule() { return rule; }

		//'image' ':' image=STRING elements+=Element*
		public Group getGroup() { return cGroup; }

		//'image'
		public Keyword getImageKeyword_0() { return cImageKeyword_0; }

		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//image=STRING
		public Assignment getImageAssignment_2() { return cImageAssignment_2; }

		//STRING
		public RuleCall getImageSTRINGTerminalRuleCall_2_0() { return cImageSTRINGTerminalRuleCall_2_0; }

		//elements+=Element*
		public Assignment getElementsAssignment_3() { return cElementsAssignment_3; }

		//Element
		public RuleCall getElementsElementParserRuleCall_3_0() { return cElementsElementParserRuleCall_3_0; }
	}

	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.Element");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAnimateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAnimationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAnimationsAnimationRuleParserRuleCall_3_0 = (RuleCall)cAnimationsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Element:
		//	'animate' name=ID '{'
		//	animations+=AnimationRule+
		//	'}';
		@Override public ParserRule getRule() { return rule; }

		//'animate' name=ID '{' animations+=AnimationRule+ '}'
		public Group getGroup() { return cGroup; }

		//'animate'
		public Keyword getAnimateKeyword_0() { return cAnimateKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//animations+=AnimationRule+
		public Assignment getAnimationsAssignment_3() { return cAnimationsAssignment_3; }

		//AnimationRule
		public RuleCall getAnimationsAnimationRuleParserRuleCall_3_0() { return cAnimationsAnimationRuleParserRuleCall_3_0; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class AnimationRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.AnimationRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cAnimationParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cUsingKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVariableAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVariableVariableReferenceParserRuleCall_2_1_0 = (RuleCall)cVariableAssignment_2_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cMappingsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMappingsAttributeMappingParserRuleCall_4_0 = (RuleCall)cMappingsAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cConditionAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cConditionConditionParserRuleCall_6_0 = (RuleCall)cConditionAssignment_6.eContents().get(0);
		
		//AnimationRule Animation:
		//	'set' Animation ('using' variable=VariableReference)? '{'
		//	mappings+=AttributeMapping*
		//	'}' condition=Condition?
		@Override public ParserRule getRule() { return rule; }

		//'set' Animation ('using' variable=VariableReference)? '{' mappings+=AttributeMapping* '}' condition=Condition?
		public Group getGroup() { return cGroup; }

		//'set'
		public Keyword getSetKeyword_0() { return cSetKeyword_0; }

		//Animation
		public RuleCall getAnimationParserRuleCall_1() { return cAnimationParserRuleCall_1; }

		//('using' variable=VariableReference)?
		public Group getGroup_2() { return cGroup_2; }

		//'using'
		public Keyword getUsingKeyword_2_0() { return cUsingKeyword_2_0; }

		//variable=VariableReference
		public Assignment getVariableAssignment_2_1() { return cVariableAssignment_2_1; }

		//VariableReference
		public RuleCall getVariableVariableReferenceParserRuleCall_2_1_0() { return cVariableVariableReferenceParserRuleCall_2_1_0; }

		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//mappings+=AttributeMapping*
		public Assignment getMappingsAssignment_4() { return cMappingsAssignment_4; }

		//AttributeMapping
		public RuleCall getMappingsAttributeMappingParserRuleCall_4_0() { return cMappingsAttributeMappingParserRuleCall_4_0; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }

		//condition=Condition?
		public Assignment getConditionAssignment_6() { return cConditionAssignment_6; }

		//Condition
		public RuleCall getConditionConditionParserRuleCall_6_0() { return cConditionConditionParserRuleCall_6_0; }
	}

	public class AnimationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.Animation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cColorKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cColorAnimationAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTextKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cTextAnimationAction_1_1 = (Action)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cVisibleKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Action cVisibleAnimationAction_2_1 = (Action)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cRotationKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Action cRotateAnimationAction_3_1 = (Action)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cMovementKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Action cMoveAnimationAction_4_1 = (Action)cGroup_4.eContents().get(1);
		
		//Animation:
		//	'color' {ColorAnimation} | 'text' {TextAnimation} | 'visible' {VisibleAnimation} | 'rotation' {RotateAnimation} |
		//	'movement' {MoveAnimation};
		@Override public ParserRule getRule() { return rule; }

		//'color' {ColorAnimation} | 'text' {TextAnimation} | 'visible' {VisibleAnimation} | 'rotation' {RotateAnimation} |
		//'movement' {MoveAnimation}
		public Alternatives getAlternatives() { return cAlternatives; }

		//'color' {ColorAnimation}
		public Group getGroup_0() { return cGroup_0; }

		//'color'
		public Keyword getColorKeyword_0_0() { return cColorKeyword_0_0; }

		//{ColorAnimation}
		public Action getColorAnimationAction_0_1() { return cColorAnimationAction_0_1; }

		//'text' {TextAnimation}
		public Group getGroup_1() { return cGroup_1; }

		//'text'
		public Keyword getTextKeyword_1_0() { return cTextKeyword_1_0; }

		//{TextAnimation}
		public Action getTextAnimationAction_1_1() { return cTextAnimationAction_1_1; }

		//'visible' {VisibleAnimation}
		public Group getGroup_2() { return cGroup_2; }

		//'visible'
		public Keyword getVisibleKeyword_2_0() { return cVisibleKeyword_2_0; }

		//{VisibleAnimation}
		public Action getVisibleAnimationAction_2_1() { return cVisibleAnimationAction_2_1; }

		//'rotation' {RotateAnimation}
		public Group getGroup_3() { return cGroup_3; }

		//'rotation'
		public Keyword getRotationKeyword_3_0() { return cRotationKeyword_3_0; }

		//{RotateAnimation}
		public Action getRotateAnimationAction_3_1() { return cRotateAnimationAction_3_1; }

		//'movement' {MoveAnimation}
		public Group getGroup_4() { return cGroup_4; }

		//'movement'
		public Keyword getMovementKeyword_4_0() { return cMovementKeyword_4_0; }

		//{MoveAnimation}
		public Action getMoveAnimationAction_4_1() { return cMoveAnimationAction_4_1; }
	}

	public class AttributeMappingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.AttributeMapping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAttributeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAttributeIDTerminalRuleCall_0_0 = (RuleCall)cAttributeAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cLiteralAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cLiteralLiteralParserRuleCall_2_0_0 = (RuleCall)cLiteralAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Assignment cMappingsAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cMappingsMappingParserRuleCall_2_1_0_0 = (RuleCall)cMappingsAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cMappingsAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cMappingsMappingParserRuleCall_2_1_1_1_0 = (RuleCall)cMappingsAssignment_2_1_1_1.eContents().get(0);
		
		//AttributeMapping:
		//	attribute=ID ':' (literal=Literal | mappings+=Mapping (',' mappings+=Mapping)*);
		@Override public ParserRule getRule() { return rule; }

		//attribute=ID ':' (literal=Literal | mappings+=Mapping (',' mappings+=Mapping)*)
		public Group getGroup() { return cGroup; }

		//attribute=ID
		public Assignment getAttributeAssignment_0() { return cAttributeAssignment_0; }

		//ID
		public RuleCall getAttributeIDTerminalRuleCall_0_0() { return cAttributeIDTerminalRuleCall_0_0; }

		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//(literal=Literal | mappings+=Mapping (',' mappings+=Mapping)*)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//literal=Literal
		public Assignment getLiteralAssignment_2_0() { return cLiteralAssignment_2_0; }

		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_2_0_0() { return cLiteralLiteralParserRuleCall_2_0_0; }

		//mappings+=Mapping (',' mappings+=Mapping)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//mappings+=Mapping
		public Assignment getMappingsAssignment_2_1_0() { return cMappingsAssignment_2_1_0; }

		//Mapping
		public RuleCall getMappingsMappingParserRuleCall_2_1_0_0() { return cMappingsMappingParserRuleCall_2_1_0_0; }

		//(',' mappings+=Mapping)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }

		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }

		//mappings+=Mapping
		public Assignment getMappingsAssignment_2_1_1_1() { return cMappingsAssignment_2_1_1_1; }

		//Mapping
		public RuleCall getMappingsMappingParserRuleCall_2_1_1_1_0() { return cMappingsMappingParserRuleCall_2_1_1_1_0; }
	}

	public class MappingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.Mapping");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableDomainAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableDomainVariableDomainParserRuleCall_0_0 = (RuleCall)cVariableDomainAssignment_0.eContents().get(0);
		private final Keyword cIsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributeDomainAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAttributeDomainAttributeDomainParserRuleCall_2_0 = (RuleCall)cAttributeDomainAssignment_2.eContents().get(0);
		
		//Mapping:
		//	variableDomain=VariableDomain 'is' attributeDomain=AttributeDomain;
		@Override public ParserRule getRule() { return rule; }

		//variableDomain=VariableDomain 'is' attributeDomain=AttributeDomain
		public Group getGroup() { return cGroup; }

		//variableDomain=VariableDomain
		public Assignment getVariableDomainAssignment_0() { return cVariableDomainAssignment_0; }

		//VariableDomain
		public RuleCall getVariableDomainVariableDomainParserRuleCall_0_0() { return cVariableDomainVariableDomainParserRuleCall_0_0; }

		//'is'
		public Keyword getIsKeyword_1() { return cIsKeyword_1; }

		//attributeDomain=AttributeDomain
		public Assignment getAttributeDomainAssignment_2() { return cAttributeDomainAssignment_2; }

		//AttributeDomain
		public RuleCall getAttributeDomainAttributeDomainParserRuleCall_2_0() { return cAttributeDomainAttributeDomainParserRuleCall_2_0; }
	}

	public class VariableDomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.VariableDomain");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cValueLiteralParserRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Assignment cRangeAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cRangeIntervalParserRuleCall_1_0 = (RuleCall)cRangeAssignment_1.eContents().get(0);
		
		//VariableDomain Domain:
		//	value=Literal
		//	| range=Interval
		@Override public ParserRule getRule() { return rule; }

		//value=Literal | range=Interval
		public Alternatives getAlternatives() { return cAlternatives; }

		//value=Literal
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }

		//Literal
		public RuleCall getValueLiteralParserRuleCall_0_0() { return cValueLiteralParserRuleCall_0_0; }

		//range=Interval
		public Assignment getRangeAssignment_1() { return cRangeAssignment_1; }

		//Interval
		public RuleCall getRangeIntervalParserRuleCall_1_0() { return cRangeIntervalParserRuleCall_1_0; }
	}

	public class IntervalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.Interval");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFromAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFromINTTerminalRuleCall_0_0 = (RuleCall)cFromAssignment_0.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cToAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cToINTTerminalRuleCall_2_0 = (RuleCall)cToAssignment_2.eContents().get(0);
		
		//Interval:
		//	from=INT '..' to=INT;
		@Override public ParserRule getRule() { return rule; }

		//from=INT '..' to=INT
		public Group getGroup() { return cGroup; }

		//from=INT
		public Assignment getFromAssignment_0() { return cFromAssignment_0; }

		//INT
		public RuleCall getFromINTTerminalRuleCall_0_0() { return cFromINTTerminalRuleCall_0_0; }

		//'..'
		public Keyword getFullStopFullStopKeyword_1() { return cFullStopFullStopKeyword_1; }

		//to=INT
		public Assignment getToAssignment_2() { return cToAssignment_2; }

		//INT
		public RuleCall getToINTTerminalRuleCall_2_0() { return cToINTTerminalRuleCall_2_0; }
	}

	public class AttributeDomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.AttributeDomain");
		private final RuleCall cVariableDomainParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//AttributeDomain Domain:
		//	VariableDomain
		@Override public ParserRule getRule() { return rule; }

		//VariableDomain
		public RuleCall getVariableDomainParserRuleCall() { return cVariableDomainParserRuleCall; }
	}

	public class ConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.Condition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionBooleanExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		//Condition:
		//	'when' expression=BooleanExpression;
		@Override public ParserRule getRule() { return rule; }

		//'when' expression=BooleanExpression
		public Group getGroup() { return cGroup; }

		//'when'
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }

		//expression=BooleanExpression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//BooleanExpression
		public RuleCall getExpressionBooleanExpressionParserRuleCall_1_0() { return cExpressionBooleanExpressionParserRuleCall_1_0; }
	}

	public class VariableReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.VariableReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cModelAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cModelModelReferenceParserRuleCall_0_0 = (RuleCall)cModelAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cIndicesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIndicesINTTerminalRuleCall_2_1_0 = (RuleCall)cIndicesAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//VariableReference:
		//	model=ModelReference?
		//	name=ID ('[' indices+=INT ']')*;
		@Override public ParserRule getRule() { return rule; }

		//model=ModelReference? name=ID ('[' indices+=INT ']')*
		public Group getGroup() { return cGroup; }

		//model=ModelReference?
		public Assignment getModelAssignment_0() { return cModelAssignment_0; }

		//ModelReference
		public RuleCall getModelModelReferenceParserRuleCall_0_0() { return cModelModelReferenceParserRuleCall_0_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//('[' indices+=INT ']')*
		public Group getGroup_2() { return cGroup_2; }

		//'['
		public Keyword getLeftSquareBracketKeyword_2_0() { return cLeftSquareBracketKeyword_2_0; }

		//indices+=INT
		public Assignment getIndicesAssignment_2_1() { return cIndicesAssignment_2_1; }

		//INT
		public RuleCall getIndicesINTTerminalRuleCall_2_1_0() { return cIndicesINTTerminalRuleCall_2_1_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_2_2() { return cRightSquareBracketKeyword_2_2; }
	}

	public class ModelReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.ModelReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ModelReference:
		//	name=ID '.';
		@Override public ParserRule getRule() { return rule; }

		//name=ID '.'
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
	}

	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.BooleanExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cAndOrExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOperatorBooleanOperatorEnumRuleCall_1_0_1_0 = (RuleCall)cOperatorAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightComparisonParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//BooleanExpression:
		//	Comparison (({AndOrExpression.left=current} operator=BooleanOperator) right=Comparison)*;
		@Override public ParserRule getRule() { return rule; }

		//Comparison (({AndOrExpression.left=current} operator=BooleanOperator) right=Comparison)*
		public Group getGroup() { return cGroup; }

		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }

		//(({AndOrExpression.left=current} operator=BooleanOperator) right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }

		//({AndOrExpression.left=current} operator=BooleanOperator)
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{AndOrExpression.left=current}
		public Action getAndOrExpressionLeftAction_1_0_0() { return cAndOrExpressionLeftAction_1_0_0; }

		//operator=BooleanOperator
		public Assignment getOperatorAssignment_1_0_1() { return cOperatorAssignment_1_0_1; }

		//BooleanOperator
		public RuleCall getOperatorBooleanOperatorEnumRuleCall_1_0_1_0() { return cOperatorBooleanOperatorEnumRuleCall_1_0_1_0; }

		//right=Comparison
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_1_0() { return cRightComparisonParserRuleCall_1_1_0; }
	}

	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftSideAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftSideVariableReferenceParserRuleCall_0_0 = (RuleCall)cLeftSideAssignment_0.eContents().get(0);
		private final Assignment cRelationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelationCompareOperatorEnumRuleCall_1_0 = (RuleCall)cRelationAssignment_1.eContents().get(0);
		private final Assignment cRightSideAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightSideOperandParserRuleCall_2_0 = (RuleCall)cRightSideAssignment_2.eContents().get(0);
		
		//Comparison Expression:
		//	leftSide=VariableReference
		//	relation=CompareOperator
		//	rightSide=Operand
		@Override public ParserRule getRule() { return rule; }

		//leftSide=VariableReference relation=CompareOperator rightSide=Operand
		public Group getGroup() { return cGroup; }

		//leftSide=VariableReference
		public Assignment getLeftSideAssignment_0() { return cLeftSideAssignment_0; }

		//VariableReference
		public RuleCall getLeftSideVariableReferenceParserRuleCall_0_0() { return cLeftSideVariableReferenceParserRuleCall_0_0; }

		//relation=CompareOperator
		public Assignment getRelationAssignment_1() { return cRelationAssignment_1; }

		//CompareOperator
		public RuleCall getRelationCompareOperatorEnumRuleCall_1_0() { return cRelationCompareOperatorEnumRuleCall_1_0; }

		//rightSide=Operand
		public Assignment getRightSideAssignment_2() { return cRightSideAssignment_2; }

		//Operand
		public RuleCall getRightSideOperandParserRuleCall_2_0() { return cRightSideOperandParserRuleCall_2_0; }
	}

	public class OperandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.Operand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cVariableVariableReferenceParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Assignment cLiteralAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cLiteralLiteralParserRuleCall_1_0 = (RuleCall)cLiteralAssignment_1.eContents().get(0);
		
		//Operand:
		//	variable=VariableReference
		//	| literal=Literal;
		@Override public ParserRule getRule() { return rule; }

		//variable=VariableReference | literal=Literal
		public Alternatives getAlternatives() { return cAlternatives; }

		//variable=VariableReference
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }

		//VariableReference
		public RuleCall getVariableVariableReferenceParserRuleCall_0_0() { return cVariableVariableReferenceParserRuleCall_0_0; }

		//literal=Literal
		public Assignment getLiteralAssignment_1() { return cLiteralAssignment_1; }

		//Literal
		public RuleCall getLiteralLiteralParserRuleCall_1_0() { return cLiteralLiteralParserRuleCall_1_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFLOATTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Literal:
		//	INT | FLOAT | STRING;
		@Override public ParserRule getRule() { return rule; }

		//INT | FLOAT | STRING
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//FLOAT
		public RuleCall getFLOATTerminalRuleCall_1() { return cFLOATTerminalRuleCall_1; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_2() { return cSTRINGTerminalRuleCall_2; }
	}
	
	
	public class CompareOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.CompareOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLTLessThanSignKeyword_1_0 = (Keyword)cLTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLEQEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLEQLessThanSignEqualsSignKeyword_2_0 = (Keyword)cLEQEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGTGreaterThanSignKeyword_3_0 = (Keyword)cGTEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGEQEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGEQGreaterThanSignEqualsSignKeyword_4_0 = (Keyword)cGEQEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cNEEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cNEExclamationMarkEqualsSignKeyword_5_0 = (Keyword)cNEEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum CompareOperator returns OperatorType:
		//	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="!=";
		public EnumRule getRule() { return rule; }

		//EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQ="="
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }

		//"="
		public Keyword getEQEqualsSignKeyword_0_0() { return cEQEqualsSignKeyword_0_0; }

		//LT="<"
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_1() { return cLTEnumLiteralDeclaration_1; }

		//"<"
		public Keyword getLTLessThanSignKeyword_1_0() { return cLTLessThanSignKeyword_1_0; }

		//LEQ="<="
		public EnumLiteralDeclaration getLEQEnumLiteralDeclaration_2() { return cLEQEnumLiteralDeclaration_2; }

		//"<="
		public Keyword getLEQLessThanSignEqualsSignKeyword_2_0() { return cLEQLessThanSignEqualsSignKeyword_2_0; }

		//GT=">"
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_3() { return cGTEnumLiteralDeclaration_3; }

		//">"
		public Keyword getGTGreaterThanSignKeyword_3_0() { return cGTGreaterThanSignKeyword_3_0; }

		//GEQ=">="
		public EnumLiteralDeclaration getGEQEnumLiteralDeclaration_4() { return cGEQEnumLiteralDeclaration_4; }

		//">="
		public Keyword getGEQGreaterThanSignEqualsSignKeyword_4_0() { return cGEQGreaterThanSignEqualsSignKeyword_4_0; }

		//NE="!="
		public EnumLiteralDeclaration getNEEnumLiteralDeclaration_5() { return cNEEnumLiteralDeclaration_5; }

		//"!="
		public Keyword getNEExclamationMarkEqualsSignKeyword_5_0() { return cNEExclamationMarkEqualsSignKeyword_5_0; }
	}

	public class BooleanOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.BooleanOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cANDAndKeyword_0_0 = (Keyword)cANDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOROrKeyword_1_0 = (Keyword)cOREnumLiteralDeclaration_1.eContents().get(0);
		
		//enum BooleanOperator returns BooleanOperatorType:
		//	AND="and" | OR="or";
		public EnumRule getRule() { return rule; }

		//AND="and" | OR="or"
		public Alternatives getAlternatives() { return cAlternatives; }

		//AND="and"
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_0() { return cANDEnumLiteralDeclaration_0; }

		//"and"
		public Keyword getANDAndKeyword_0_0() { return cANDAndKeyword_0_0; }

		//OR="or"
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_1() { return cOREnumLiteralDeclaration_1; }

		//"or"
		public Keyword getOROrKeyword_1_0() { return cOROrKeyword_1_0; }
	}
	
	private final VisualizationElements pVisualization;
	private final ElementElements pElement;
	private final AnimationRuleElements pAnimationRule;
	private final AnimationElements pAnimation;
	private final AttributeMappingElements pAttributeMapping;
	private final MappingElements pMapping;
	private final VariableDomainElements pVariableDomain;
	private final IntervalElements pInterval;
	private final AttributeDomainElements pAttributeDomain;
	private final ConditionElements pCondition;
	private final VariableReferenceElements pVariableReference;
	private final ModelReferenceElements pModelReference;
	private final BooleanExpressionElements pBooleanExpression;
	private final ComparisonElements pComparison;
	private final OperandElements pOperand;
	private final LiteralElements pLiteral;
	private final CompareOperatorElements eCompareOperator;
	private final BooleanOperatorElements eBooleanOperator;
	private final TerminalRule tDIGIT;
	private final TerminalRule tINT;
	private final TerminalRule tFLOAT;
	private final TerminalRule tBOOLEAN;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public KVisGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pVisualization = new VisualizationElements();
		this.pElement = new ElementElements();
		this.pAnimationRule = new AnimationRuleElements();
		this.pAnimation = new AnimationElements();
		this.pAttributeMapping = new AttributeMappingElements();
		this.pMapping = new MappingElements();
		this.pVariableDomain = new VariableDomainElements();
		this.pInterval = new IntervalElements();
		this.pAttributeDomain = new AttributeDomainElements();
		this.pCondition = new ConditionElements();
		this.pVariableReference = new VariableReferenceElements();
		this.pModelReference = new ModelReferenceElements();
		this.pBooleanExpression = new BooleanExpressionElements();
		this.pComparison = new ComparisonElements();
		this.pOperand = new OperandElements();
		this.pLiteral = new LiteralElements();
		this.eCompareOperator = new CompareOperatorElements();
		this.eBooleanOperator = new BooleanOperatorElements();
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.DIGIT");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.INT");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.FLOAT");
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "de.cau.cs.kieler.KVis.BOOLEAN");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("de.cau.cs.kieler.KVis".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Visualization:
	//	'image' ':' image=STRING
	//	elements+=Element*;
	public VisualizationElements getVisualizationAccess() {
		return pVisualization;
	}
	
	public ParserRule getVisualizationRule() {
		return getVisualizationAccess().getRule();
	}

	//Element:
	//	'animate' name=ID '{'
	//	animations+=AnimationRule+
	//	'}';
	public ElementElements getElementAccess() {
		return pElement;
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}

	//AnimationRule Animation:
	//	'set' Animation ('using' variable=VariableReference)? '{'
	//	mappings+=AttributeMapping*
	//	'}' condition=Condition?
	public AnimationRuleElements getAnimationRuleAccess() {
		return pAnimationRule;
	}
	
	public ParserRule getAnimationRuleRule() {
		return getAnimationRuleAccess().getRule();
	}

	//Animation:
	//	'color' {ColorAnimation} | 'text' {TextAnimation} | 'visible' {VisibleAnimation} | 'rotation' {RotateAnimation} |
	//	'movement' {MoveAnimation};
	public AnimationElements getAnimationAccess() {
		return pAnimation;
	}
	
	public ParserRule getAnimationRule() {
		return getAnimationAccess().getRule();
	}

	//AttributeMapping:
	//	attribute=ID ':' (literal=Literal | mappings+=Mapping (',' mappings+=Mapping)*);
	public AttributeMappingElements getAttributeMappingAccess() {
		return pAttributeMapping;
	}
	
	public ParserRule getAttributeMappingRule() {
		return getAttributeMappingAccess().getRule();
	}

	//Mapping:
	//	variableDomain=VariableDomain 'is' attributeDomain=AttributeDomain;
	public MappingElements getMappingAccess() {
		return pMapping;
	}
	
	public ParserRule getMappingRule() {
		return getMappingAccess().getRule();
	}

	//VariableDomain Domain:
	//	value=Literal
	//	| range=Interval
	public VariableDomainElements getVariableDomainAccess() {
		return pVariableDomain;
	}
	
	public ParserRule getVariableDomainRule() {
		return getVariableDomainAccess().getRule();
	}

	//Interval:
	//	from=INT '..' to=INT;
	public IntervalElements getIntervalAccess() {
		return pInterval;
	}
	
	public ParserRule getIntervalRule() {
		return getIntervalAccess().getRule();
	}

	//AttributeDomain Domain:
	//	VariableDomain
	public AttributeDomainElements getAttributeDomainAccess() {
		return pAttributeDomain;
	}
	
	public ParserRule getAttributeDomainRule() {
		return getAttributeDomainAccess().getRule();
	}

	//Condition:
	//	'when' expression=BooleanExpression;
	public ConditionElements getConditionAccess() {
		return pCondition;
	}
	
	public ParserRule getConditionRule() {
		return getConditionAccess().getRule();
	}

	//VariableReference:
	//	model=ModelReference?
	//	name=ID ('[' indices+=INT ']')*;
	public VariableReferenceElements getVariableReferenceAccess() {
		return pVariableReference;
	}
	
	public ParserRule getVariableReferenceRule() {
		return getVariableReferenceAccess().getRule();
	}

	//ModelReference:
	//	name=ID '.';
	public ModelReferenceElements getModelReferenceAccess() {
		return pModelReference;
	}
	
	public ParserRule getModelReferenceRule() {
		return getModelReferenceAccess().getRule();
	}

	//BooleanExpression:
	//	Comparison (({AndOrExpression.left=current} operator=BooleanOperator) right=Comparison)*;
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return pBooleanExpression;
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}

	//Comparison Expression:
	//	leftSide=VariableReference
	//	relation=CompareOperator
	//	rightSide=Operand
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}

	//Operand:
	//	variable=VariableReference
	//	| literal=Literal;
	public OperandElements getOperandAccess() {
		return pOperand;
	}
	
	public ParserRule getOperandRule() {
		return getOperandAccess().getRule();
	}

	//Literal:
	//	INT | FLOAT | STRING;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//enum CompareOperator returns OperatorType:
	//	EQ="=" | LT="<" | LEQ="<=" | GT=">" | GEQ=">=" | NE="!=";
	public CompareOperatorElements getCompareOperatorAccess() {
		return eCompareOperator;
	}
	
	public EnumRule getCompareOperatorRule() {
		return getCompareOperatorAccess().getRule();
	}

	//enum BooleanOperator returns BooleanOperatorType:
	//	AND="and" | OR="or";
	public BooleanOperatorElements getBooleanOperatorAccess() {
		return eBooleanOperator;
	}
	
	public EnumRule getBooleanOperatorRule() {
		return getBooleanOperatorAccess().getRule();
	}

	//terminal fragment DIGIT:
	//	'0'..'9';
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	} 

	//terminal INT returns ecore::EInt:
	//	DIGIT+;
	public TerminalRule getINTRule() {
		return tINT;
	} 

	//terminal FLOAT returns ecore::EFloatObject:
	//	DIGIT+ ('.' DIGIT*) (("e" | "E") ("+" | "-")? DIGIT+)? 'f'? | DIGIT+ 'f';
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	} 

	//terminal BOOLEAN returns ecore::EBooleanObject:
	//	'true' | 'false';
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	} 

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
