/*
 * KIELER - Kiel Integrated Environment for Layout Eclipse RichClient
 * 
 * http://www.informatik.uni-kiel.de/rtsys/kieler/
 * 
 * Copyright 2015 by
 * + Kiel University
 *   + Department of Computer Science
 *     + Real-Time and Embedded Systems Group
 * 
 * This code is provided under the terms of the Eclipse Public License (EPL).
 * See the file epl-v10.html for the license text.
 */
package de.cau.cs.kieler.prom.templates

import com.google.common.base.Charsets
import com.google.common.io.Files
import com.google.common.io.LineProcessor
import de.cau.cs.kieler.prom.ModelImporter
import de.cau.cs.kieler.prom.data.FileData
import de.cau.cs.kieler.prom.data.MacroCallData
import freemarker.template.Template
import java.io.File
import java.io.FileFilter
import java.io.IOException
import java.io.StringWriter
import java.util.List
import java.util.Map
import java.util.regex.Pattern
import org.eclipse.core.resources.IProject
import org.eclipse.core.runtime.CoreException
import org.eclipse.core.runtime.IConfigurationElement
import org.eclipse.core.runtime.Platform
import org.eclipse.emf.ecore.EObject

/**
 * This class generates wrapper code for models.
 * Annotations are mapped to macro calls which are injected in the input template.
 * Afterwards the macro calls are evaluated by the template engine and the wrapper code which they define is inserted.
 * 
 * @author aas
 */
class TemplateManager {

    /**
     * The id of the extension point for wrapper code annotation analyzers.
     */
    private static val MODEL_ANALYZER_EXTENSION_POINT_ID = "de.cau.cs.kieler.prom.modelAnalyzer"

    /**
     * List with all wrapper code annotation analyzers loaded from extensions.
     */
    private static var List<ModelAnalyzer> modelAnalyzers

    /**
     * A template variable which is replaced with the name of the last analyzed model.
     */
    public static val MODEL_NAME_VARIABLE = "model_name"
    /**
     * A template variable which is replaced with the names of the models.
     */
    public static val MODEL_NAMES_VARIABLE = "model_names"
    
    /**
     * A template variable which is replaced with the name of the template file (without file extension).
     */
    public static val FILE_NAME_VARIABLE = "file_name"
    
    /**
     * The variable name in the target template
     * for code generated by KiCo.
     */
    public static val KICO_GENERATED_CODE_VARIABLE = "kico_code"
    
    /**
     * Macro definitions to use <@init>, <@input>, <@output> in wrapper code snippets.
     */
    public static var String macroDefinitions = null
    
    /**
     * The project
     */
    private IProject project

    /**
     * Constructor
     */
    new(IProject project) {
        this.project = project
    }
    
    /**
     * Generates wrapper code for a list of annotated model files.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param datas The model files to generate wrapper code for
     * @return the generated wrapper code
     */
    def public String generateWrapperCode(String templatePath, FileData... datas) {
        val List<MacroCallData> annotationDatas = newArrayList()
        var List<String> modelNames = newArrayList()
        var String modelName = ""
        for(data : datas) {
            val model = ModelImporter.load(data.getFile(project))
            getAnnotationInterface(model, annotationDatas)
            modelName = Files.getNameWithoutExtension(datas.get(0).name)
            modelNames += modelName
        }

        // Set model names
        val mapping = #{MODEL_NAME_VARIABLE -> modelName,
                        MODEL_NAMES_VARIABLE -> modelNames}
        return generateWrapperCode(templatePath, annotationDatas, mapping)
    }
    
    /**
     * Generates wrapper code using the given macro call datas.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param macroCallDatas The macro calls to be injected in the template
     * @return the generated wrapper code
     */
    def public String generateWrapperCode(String templatePath, List<MacroCallData> macroCallDatas) {
        generateWrapperCode(templatePath, macroCallDatas, #{})
    }
    
    /**
     * Generates code by running the template engine on a template file.
     * 
     * @param templatePath The project relative path to the template
     * @param additionalMappings Additional mappings of placeholder variables to their corresponding values
     */
    def public String processTemplate(String templatePath, Map<String, Object> additionalMappings) {
        
        // Check consistency of path
        if (!templatePath.isNullOrEmpty()) {
            FreemarkerConfiguration.newConfiguration(project.location.toOSString)
            
            val template = FreemarkerConfiguration.configuration.getTemplate(templatePath)

            val writer = new StringWriter()
            template.process(additionalMappings, writer)
    
            return writer.toString()
        }
        return ""
    }
    
    /**
     * Generates wrapper code with the given macro call datas and additional mappings.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param macroCallDatas The macro calls to be injected in the template
     * @param additionalMappings Additional mappings of placeholder variables to their corresponding values
     * @return the generated wrapper code
     */
    def public String generateWrapperCode(String templatePath, List<MacroCallData> macroCallDatas, Map<String, Object> additionalMappings) {

        // Check consistency of path
        if (!templatePath.isNullOrEmpty()) {
            val templateWithMacroCalls = getTemplateWithMacroCalls(templatePath, macroCallDatas)
            
            // Debug log macro calls
//            System.err.println(templateWithMacroCalls)

            // Create mappings
            val map = <String, Object> newHashMap
            
            // Add name of model 
            if(!map.containsKey(MODEL_NAME_VARIABLE) && !macroCallDatas.isEmpty) {
                val modelName = macroCallDatas.get(0).modelName
                map.put(MODEL_NAME_VARIABLE, modelName)
                map.put(MODEL_NAMES_VARIABLE, #[modelName])
            }
            
            // Add name of output file 
            if(!map.containsKey(FILE_NAME_VARIABLE)) {
                val fileName = new File(templatePath).name
                val fileNameWithoutExtension = Files.getNameWithoutExtension(fileName)
                map.put(FILE_NAME_VARIABLE, fileNameWithoutExtension)
            }
            
            // Add additional mappings
            if(additionalMappings != null) {
                map.putAll(additionalMappings)
            }
        
            // Process template with macro calls and the mappings created above
            val wrapperCode = processTemplateWithSnippetDefinitions(templateWithMacroCalls, map)
            return wrapperCode
        }
        return ""
    }

    /**
     * Searches for wrapper code annotations in the models
     * and injects macro calls accordingly in the template.
     * 
     * @param templatePath The project relative path to the wrapper code template
     * @param additionalMappings Additional mappings of placeholder variables to their corresponding values
     * @param annotationDatas The annotations that injected as macro calls
     * @return a String with the input template,
     *         where placeholders for the different phases are replaced with the corresponding macro calls
     *         that have been injected.
     */
    private def String getTemplateWithMacroCalls(String templatePath, List<MacroCallData> annotationDatas) {
        
        // Create macro calls from annotations
        val map = getMacroCalls(annotationDatas)
        
        // Inject macro calls in input template
        val lineProcessor = new LineProcessor<String>() {
            String text = ""
            
            override getResult() {
                return text
            }
            
            override processLine(String line) throws IOException {
                // Replace placeholders in the line
                // Freemarker should process the templates only after the macro calls have been injected.
                // Otherwise things like includes are processed, not needed in this case, yet gone in the next iteration,
                // in which macro calls should be processed.
                // Thus, injecting the macro calls is done here, before Freemarker is used.
                var lineWithoutPlaceholders = line
                for(entry : map.entrySet) {
                    val placeholderRegex = Pattern.quote("${"+entry.key+"}")
                    lineWithoutPlaceholders = lineWithoutPlaceholders.replaceAll(placeholderRegex, entry.value)
                }
                text += lineWithoutPlaceholders+"\n"
                // Continue reading the lines
                return true
            }
        }
        val templateText = Files.readLines(new File(project.location.append(templatePath).toOSString),
                                           Charsets.UTF_8,
                                           lineProcessor)
        return templateText
    }

    /**
     * Processes the given template and saves the output to the target location of this generator.
     * The template is processed using all macro definitions from the wrapper code snippet directory.
     * 
     * @param templateWithMacroCalls The template text to be processed 
     */
    private def String processTemplateWithSnippetDefinitions(String templateWithMacroCalls, Map<String, Object> additionalMappings) {
        
        FreemarkerConfiguration.newConfiguration(project.location.toOSString)
        
        // Add implicit include of assignment macros such as <@init> and <@output>
        FreemarkerConfiguration.stringTemplateLoader.putTemplate("injectionMacros", getOrInitializeMacroDefinitions )
        FreemarkerConfiguration.configuration.addAutoInclude("injectionMacros")
        
        // Process template with macro calls and now implicitly loaded snippet definitions.
        val template = new Template("templateWithMacroCalls", templateWithMacroCalls, FreemarkerConfiguration.configuration)

        // Process template and write output in string
        val map = if(additionalMappings != null)
                      additionalMappings
                  else
                    newHashMap
        val writer = new StringWriter()
        template.process(map, writer)
        writer.close()
        return writer.toString
    }

    /**
     * Initializes the macro definitions when they are not yet initialized.
     * Afterwards they are returned.
     * 
     * @return the macro definitions of assignment macros such as <@input>
     */
    private def String getOrInitializeMacroDefinitions() {
        // Initialize if not done yet
        if(macroDefinitions == null){
            macroDefinitions = ""
            
            for(phase : CodeGenerationPhase.PHASES ){
                for(macro : phase.injectionMacros){
                    macroDefinitions += macro.freeMarkerDefinition
                    macroDefinitions += "\n"
                }                
            }
        }
        return macroDefinitions
    }
    
    /**
     * Creates macro calls from wrapper code annotation datas.
     * 
     * @param annotationDatas List with the datas to generate macro calls for 
     * @return a map where the keys 'inits', 'inputs' and 'outputs'
     *         are mapped to the corresponding macro calls for the given annotations.
     */
    private def Map<String, String> getMacroCalls(MacroCallData... annotationDatas) {
        val Map<String, String> map = newHashMap
        
        // The assignment macros such as <@init> and <@output> use a variable
        // to determine if their snippet should be inserted.
        for(phase : CodeGenerationPhase.PHASES) {
            phase.codeToInject = phase.freeMarkerAssignment+"\n"
        }

        // Keep track of the annotations that were already seen before in this collection
        val doneDatas = <MacroCallData> newHashSet
        var isDoneAlready = false
        
        // Add macro calls for annotations to the different phases
        var MacroCallData prev = null; 
        for (data : annotationDatas) {
            
            isDoneAlready = true
            if (!doneDatas.contains(data)) {
                doneDatas.add(data)
                isDoneAlready = false
            }

            for(phase : CodeGenerationPhase.PHASES) {
                // We initialize every annotation only once
                // although the same annotation might be used twice: as input and output.
                if(!phase.singleton || (phase.singleton && !isDoneAlready) ) {
                    // Use input annotations on inputs only, and output annotations on outputs only
                    if(phase.isApplicable(data)) {
                        // The macro of this annotation should be called in this phase
                        phase.codeToInject = phase.codeToInject + getTemplateCodeForAnnotation(data)
                    }
                }
            }
            prev = data;
        }

        // Send FreeMarker the text to replace the placeholder of each phase
        for(phase : CodeGenerationPhase.PHASES) {
            map.putAll(phase.injectionMacroMappings)
        }
        return map
    }

    /**
     * Creates meta assignments and macro calls for an wrapper code annotation data.
     * 
     * @param data The annotation data
     * @return a string to set information about the variable which the annotation is used for.
     *         as well as the macro call for the annotation.    
     */
    private static def String getTemplateCodeForAnnotation(MacroCallData data) {
        return getMetaAssignments(data) + getMacroCall(data);
    }

    /**
     * Creates a statements that sets meta information about the next variable to be used.
     * 
     * @param data The wrapper code annotation data 
     * @return a string which globally sets meta information.  
     */
    private static def String getMetaAssignments(MacroCallData data) {
        return '''<#assign varname = '«data.varName»' vartype = '«data.varType»' />'''+"\n"
    }

    /**
     * Creates a statement that calls a macro to generate code for the wrapper code annotation data.
     * 
     * @param data The wrapper code annotation data
     * @return a string with the macro call for an wrapper code annotation data.
     */
    private static def String getMacroCall(MacroCallData data) {
        var txt = ""
        // Ignore non existing macro <=> only call if macro exists
        if (data.ignoreNonExistingSnippet)
            txt += '''<#if «data.name»??>'''

        txt += '''<@«data.name» '''
        // Append arguments
        var boolean isBooleanArgument
        var boolean isFloatArgument
        for (String arg : data.arguments) {
            isBooleanArgument = (arg.equalsIgnoreCase("true") || arg.equalsIgnoreCase("false"))
            try {
                isFloatArgument = (Float.valueOf(arg) != null)
            } catch (NumberFormatException e) {
                isFloatArgument = false
            }
            val isNonStringArgument = isBooleanArgument || isFloatArgument
            // Only string arguments need to be surrounded by single quotation marks
            if(isNonStringArgument)
                txt += '''«arg» '''   
            else 
                txt += ''''«arg»' '''
        }
        // Close macro call
        txt += '''/>''';

        // Close if
        if (data.ignoreNonExistingSnippet)
            txt += '''</#if>'''
        
        txt += "\n"

        return txt
    }
    
    /**
     * Auxilary method for getFilesRecursive(...).
     * Searches for files in the given folder and recursive in all sub folders.
     * Each file which is not filtered is added to the list.
     * 
     * @param folder the current folder to be searched for files
     * @param list A list of found files
     * @param filter A filter that found files must match
     */
    private def void getFilesRecursiveHelper(File folder, List<File> list, FileFilter filter) {
        // Iterate over files in the folder.
        // Add found files and remember folders for later.
        val subFolders = newArrayList()
        for (fileEntry : folder.listFiles(filter)) {
            if (fileEntry.isDirectory()) {
                subFolders += fileEntry
            } else {
                list.add(fileEntry)
            }
        }
        
        // Go into next folder level
        for (subFolder : subFolders) {
            getFilesRecursiveHelper(subFolder, list, filter);
        }
    }

    /**
     * Fetches all annotation datas from the file data in the given project
     * 
     * @param project the project
     * @param data the FileData with information which model file will be analyzed
     * @return the annotation datas
     */
    public static def List<MacroCallData> getAnnotationInterface(IProject project, FileData data) {
        val List<MacroCallData> annotationDatas = newArrayList()
        val model = ModelImporter.load(data.getFile(project))
        getAnnotationInterface(model, annotationDatas)
        return annotationDatas
    }

    /**
     * Adds wrapper code data objects to the annotationDatas list,
     * which where found in the given files.
     * 
     * @param data File data holding a path to a model file
     * @param annotationDatas List to add found annotation datas to
     */
    public static def void getAnnotationInterface(EObject model,
        List<MacroCallData> annotationDatas) {

        // Load EObject from file
        if (model != null) {
            initAnalyzers()
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : TemplateManager.modelAnalyzers) {
                val annotations = analyzer.getAnnotationInterface(model)
                if (annotations != null) {
                    annotationDatas.addAll(annotations)    
                }
            }

        }
    }

    /**
     * Looks for the interface (inputs / outputs) in the model
     * and based on this, creates data objects suited for simulation of the model.
     * 
     * @param model The model
     * @param datas List to add found datas objects to
     */
    public static def void getSimulationInterfaceData(EObject model,
        List<MacroCallData> simulationDatas) {

        // Load EObject from file
        if (model != null) {
            initAnalyzers()
            
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : TemplateManager.modelAnalyzers) {
                val datas = analyzer.getSimulationInterface(model)
                if (!datas.isNullOrEmpty) {
                    simulationDatas.addAll(datas)    
                }
            }

        }
    }
    
    /**
     * Adds wrapper code data objects to the annotationDatas list,
     * which where found in the given files.
     * 
     * @param data File data holding a path to a model file
     * @param annotationDatas List to add found annotation datas to
     */
    public static def String getModelName(EObject model) {
        // Load EObject from file
        if (model != null) {
            initAnalyzers()
            
            // Analyze the model with all wrapper code annotation analyzers
            for (analyzer : TemplateManager.modelAnalyzers) {
                val modelName = analyzer.getModelName(model)
                if(modelName != null) {
                    return modelName
                }
            }

        }
    }
    
    /**
     * Load and initialize wrapper code annotation analyzers from all implementing extensions
     * if not yet done.
     */
    private static def void initAnalyzers(){
        if(TemplateManager.modelAnalyzers == null){
            // Initialize list
            TemplateManager.modelAnalyzers = newArrayList()
            
            // Fill list with wrapper code annotation analyzers from extensions.
            val config = Platform.getExtensionRegistry().getConfigurationElementsFor(TemplateManager.MODEL_ANALYZER_EXTENSION_POINT_ID);
            try {
                for (IConfigurationElement e : config) {
                    val o = e.createExecutableExtension("class");
                    if (o instanceof ModelAnalyzer) {
                        TemplateManager.modelAnalyzers += o
                    }
                }
            } catch (CoreException ex) {
                System.err.println(ex.getMessage());
            }
        }
    }
}