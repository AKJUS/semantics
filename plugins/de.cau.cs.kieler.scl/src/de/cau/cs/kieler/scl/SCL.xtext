grammar de.cau.cs.kieler.scl.SCL with org.yakindu.sct.model.stext.SText 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.yakindu.org/sct/sgraph/2.0.0" as sgraph
import "http://www.yakindu.org/base/types/2.0.0" as types
import "http://www.yakindu.org/base/base/2.0.0" as base
import "http://www.yakindu.org/sct/statechart/SText" as stext
//import "http://kieler.cs.cau.de/yakindu/stext/" as synctext
//import "http://kieler.cs.cau.de/yakindu/sccharts/stext/" as scchartsexp

generate scl "http://www.cau.de/cs/kieler/scl/scl"



Program :
	'module' name = ID
	(interface+=VariableDeclaration)*
	'{'
        program = InstructionList
    '}' 
;

VariableDeclaration:
    (Input?='input')? (Output?='output')? 'signal' (name=ID)(':'type=[types::Type])?';'
;

Instruction:
    (Assignment | Conditional | Goto | Parallel | Pause)
    (priority=INT)?
;

Assignment:
    assignment=Expression
;

InstructionList:
  {InstructionList}
  (
  (
      (
          (instructions += Instruction';')
          |
          (instructions += Annotation)
          |
          (instructions += Label)
      )*
      (instructions += Instruction)
      |
      (instructions += Annotation)
      |
      (instructions += Label)
  )*
  )
  |
  {InstructionList}
  (
 '{'
      (interface+=VariableDeclaration)*
  (
      (
          (instructions += Instruction';')
          |
          (instructions += Annotation)
          |
          (instructions += Label)
      )*
      (instructions += Instruction)
      |
      (instructions += Annotation)
      |
      (instructions += Label)
  )*    
 '}'
  )    
;

//VariableScope:
//  {InstructionList}
// '<'
//      (interface+=VariableDeclaration)*
//  (
//      (
//          (instructions += Instruction';')
//          |
//          (instructions += Annotation)
//          |
//          (instructions += Label)
//      )*
//      (instructions += Instruction)
//      |
//      (instructions += Annotation)
//      |
//      (instructions += Label)
//  )*    
// '>'
//;

Label:
    'label' name = ID ':'
;

Conditional:
    'if' expression = Expression 'then'
        conditional = InstructionList
    'end' 
;

Goto:
    'goto' name = ID 
;

Parallel:
    'fork'
    (    threads += InstructionList
    ('par'
         threads += InstructionList)+)
    'join'
;


Pause:
    'pause' {Pause}
;

Annotation:
    comment = SL_COMMENT
;

